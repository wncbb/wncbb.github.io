<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>leetcode on WNCBB&#39;s blog</title>
    <link>https://wncbb.github.io/series/leetcode/</link>
    <description>Recent content in leetcode on WNCBB&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 10 Mar 2021 16:05:29 +0800</lastBuildDate>
    
	<atom:link href="https://wncbb.github.io/series/leetcode/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>0078</title>
      <link>https://wncbb.github.io/posts/leetcode/0078.subsets/</link>
      <pubDate>Wed, 10 Mar 2021 16:05:29 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/0078.subsets/</guid>
      <description>func subsets(nums []int) [][]int { rst:=make([][]int, 0) var dfs func(curIdx int) curRst:=make([]int, 0, len(nums)) dfs=func(curIdx int){ if curIdx==len(nums){ // 既然copy的是curRst,那么tmpRst的长度就跟curRst一样 tmpRst:=make([]int, len(curRst), len(curRst)) copy(tmpRst, curRst) rst=append(rst, tmpRst) return } // 要么有这个元素 curRst=append(curRst, nums[curIdx]) dfs(curIdx+1) // 要么没有这个元素 curRst=curRst[:len(curRst)-1] dfs(curIdx+1) } dfs(0) return rst }  </description>
    </item>
    
    <item>
      <title>0128.longest-consecutive-sequence</title>
      <link>https://wncbb.github.io/posts/leetcode/0128.longest-consecutive-sequence/</link>
      <pubDate>Wed, 10 Mar 2021 15:49:05 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/0128.longest-consecutive-sequence/</guid>
      <description>/* 举个例子: nums: 100, 4, 200, 1, 3, 2 line22 m:map[100:1] line22 m:map[4:1 100:1] line22 m:map[4:1 100:1 200:1] line22 m:map[1:1 4:1 100:1 200:1] line22 m:map[1:1 3:2 4:2 100:1 200:1] line22 m:map[1:4 2:4 3:2 4:4 100:1 200:1] 最终效果就是: 对于连续的数组: [i, j] (且[i-1, j][i, j+1]都不是) map里的map[i], map[j]一定是最长的连续序列的长度 */ func longestConsecutive(nums []int) int { maxLen := 0 m := make(map[int]int) for _, v := range nums { _, ok := m[v] if ok { continue } leftLen := m[v-1] rightLen := m[v+1] curLen := leftLen + rightLen + 1 m[v] = curLen maxLen = getMax(maxLen, curLen) // 更新左右边界的值，因为下次用到的话，一定是只用到边界 m[v-leftLen] = curLen m[v+rightLen] = curLen // fmt.</description>
    </item>
    
    <item>
      <title>0543.diameter-of-binary-tree</title>
      <link>https://wncbb.github.io/posts/leetcode/0543.diameter-of-binary-tree/</link>
      <pubDate>Wed, 10 Mar 2021 15:29:09 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/0543.diameter-of-binary-tree/</guid>
      <description>/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func diameterOfBinaryTree(root *TreeNode) int { if root==nil{ return 0 } rst:=0 var getDepth func(root *TreeNode)int getDepth=func(root *TreeNode)int{ if root==nil{ return 0 } left:=getDepth(root.Left) right:=getDepth(root.Right) rst=getMax(rst, left+right) return getMax(left, right)+1 } getDepth(root) return rst } func getMax(a, b int)int{ if a&amp;gt;b{ return a } return b }  </description>
    </item>
    
    <item>
      <title>0322.coin-change</title>
      <link>https://wncbb.github.io/posts/leetcode/0322.coin-change/</link>
      <pubDate>Wed, 10 Mar 2021 15:09:43 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/0322.coin-change/</guid>
      <description>dfs func coinChange(coins []int, amount int) int { if amount == 0 { return 0 } sort.Slice(coins, func(i, j int) bool { return coins[i] &amp;gt; coins[j] }) ans := math.MaxInt32 var dfs func(coins []int, curAmount, curCoinIndex, curCount int) dfs = func(coins []int, curAmount, curCoinIndex, curCount int) { if curAmount == 0 { ans = getMin(ans, curCount) return } if curCoinIndex == len(coins) { return } for k := curAmount / coins[curCoinIndex]; k &amp;gt;= 0 &amp;amp;&amp;amp; (k+curCount) &amp;lt; ans; k-- { dfs(coins, curAmount-k*coins[curCoinIndex], curCoinIndex+1, curCount+k) } } dfs(coins, amount, 0, 0) if ans == math.</description>
    </item>
    
    <item>
      <title>0175.combine-two-tables</title>
      <link>https://wncbb.github.io/posts/leetcode/0175.combine-two-tables/</link>
      <pubDate>Wed, 10 Mar 2021 14:30:50 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/0175.combine-two-tables/</guid>
      <description>select FirstName, LastName, City, State from Person left join Address on Person.PersonId = Address.PersonId ;  </description>
    </item>
    
    <item>
      <title>0300.longest-increasing-subsequence</title>
      <link>https://wncbb.github.io/posts/leetcode/0300.longest-increasing-subsequence/</link>
      <pubDate>Wed, 10 Mar 2021 14:28:58 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/0300.longest-increasing-subsequence/</guid>
      <description>func lengthOfLIS(nums []int) int { numLen := len(nums) if numLen &amp;lt;= 1 { return numLen } // 长度为i+1的递增子序列，的最后一个元素 tail := make([]int, numLen, numLen) tail[0] = nums[0] end := 0 for i := 1; i &amp;lt; numLen; i++ { if nums[i] &amp;gt; tail[end] { end++ tail[end] = nums[i] } else { left := 0 right := end for left &amp;lt; right { mid := left + (right-left)/2 if nums[i] &amp;lt;= tail[mid] { right = mid } else { left = mid + 1 } } // fmt.</description>
    </item>
    
    <item>
      <title>0112.path-sum</title>
      <link>https://wncbb.github.io/posts/leetcode/0112.path-sum/</link>
      <pubDate>Wed, 10 Mar 2021 13:33:22 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/0112.path-sum/</guid>
      <description>/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func hasPathSum(root *TreeNode, targetSum int) bool { if root==nil { return false } if root.Left==nil &amp;amp;&amp;amp; root.Right==nil &amp;amp;&amp;amp; root.Val==targetSum{ return true } return hasPathSum(root.Left, targetSum-root.Val) || hasPathSum(root.Right, targetSum-root.Val) }  </description>
    </item>
    
    <item>
      <title>0093.restore-ip-addresses</title>
      <link>https://wncbb.github.io/posts/leetcode/0093.restore-ip-addresses/</link>
      <pubDate>Wed, 10 Mar 2021 13:14:56 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/0093.restore-ip-addresses/</guid>
      <description>func restoreIpAddresses(s string) []string { rst := make([]string, 0) var dfs func(curRst []string, start int) dfs = func(curRst []string, start int) { if len(curRst) == 4 { if start == len(s) { rst = append(rst, strings.Join(curRst, &amp;quot;.&amp;quot;)) return } else { return } } for length := 1; length &amp;lt;= 3; length++ { // 2+2 2 3 4 if start+length &amp;gt; len(s) { return } curStr := s[start : start+length] if length &amp;gt; 1 &amp;amp;&amp;amp; curStr[0] == &#39;0&#39; { return } curNum, _ := strconv.</description>
    </item>
    
    <item>
      <title>0445.add-two-numbers-ii</title>
      <link>https://wncbb.github.io/posts/leetcode/0445.add-two-numbers-ii/</link>
      <pubDate>Wed, 10 Mar 2021 12:52:31 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/0445.add-two-numbers-ii/</guid>
      <description>/** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode { if l1==nil{ return l2 } if l2==nil{ return l1 } l1Stack:=getStackFromList(l1) l2Stack:=getStackFromList(l2) carry:=0 dummy:=&amp;amp;ListNode{} for !l1Stack.Empty() || !l2Stack.Empty() || carry&amp;gt;0{ cur:=carry if !l1Stack.Empty(){ cur+=l1Stack.Pop() } if !l2Stack.Empty(){ cur+=l2Stack.Pop() } newNode:=&amp;amp;ListNode{ Val: cur%10, } carry=cur/10 newNode.Next=dummy.Next dummy.Next=newNode } return dummy.Next } func getStackFromList(l *ListNode)*Stack{ stack:=&amp;amp;Stack{ raw: make([]int, 0), } for l!</description>
    </item>
    
    <item>
      <title>0415.add-strings</title>
      <link>https://wncbb.github.io/posts/leetcode/0415.add-strings/</link>
      <pubDate>Wed, 10 Mar 2021 12:38:19 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/0415.add-strings/</guid>
      <description>func addStrings(num1 string, num2 string) string { num1Bytes:=[]byte(num1) num2Bytes:=[]byte(num2) carry:=0 // 需要从后面往前计算，因为最后一位都是个位 i:=len(num1)-1 j:=len(num2)-1 rst:=make([]byte, 0) for i&amp;gt;=0 || j&amp;gt;=0 || carry&amp;gt;0{ cur:=carry if i&amp;gt;=0{ cur+=int(num1Bytes[i]-&#39;0&#39;) i-- } if j&amp;gt;=0{ cur+=int(num2Bytes[j]-&#39;0&#39;) j-- } carry=cur/10 cur=cur%10 rst=append(rst, byte(cur+&#39;0&#39;)) } return string(reverseBytes(rst)) } func reverseBytes(s [] byte)[]byte{ if len(s)&amp;lt;=1{ return s } left:=0 right:=len(s)-1 for left&amp;lt;right{ s[left], s[right]=s[right], s[left] left++ right-- } return s }  </description>
    </item>
    
    <item>
      <title>0160.intersection-of-two-linked-lists</title>
      <link>https://wncbb.github.io/posts/leetcode/0160.intersection-of-two-linked-lists/</link>
      <pubDate>Wed, 10 Mar 2021 12:26:32 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/0160.intersection-of-two-linked-lists/</guid>
      <description>遍历A+B跟遍历B+A A=1, 3, 5, 7, 8 B=2, 6, 7, 8 A与B的最后一部分肯定相同，所以第一个相同的就是交叉点 A+B: 1 3 5 7 8 2 6 7 8 B+A: 2 6 7 8 1 3 5 7 8  /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func getIntersectionNode(headA, headB *ListNode) *ListNode { pA:=headA pB:=headB for pA!=pB{ if pA!=nil{ pA=pA.Next }else{ pA=headB } if pB!=nil{ pB=pB.</description>
    </item>
    
    <item>
      <title>0023.merge-k-sorted-lists</title>
      <link>https://wncbb.github.io/posts/leetcode/0023.merge-k-sorted-lists/</link>
      <pubDate>Wed, 10 Mar 2021 12:15:16 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/0023.merge-k-sorted-lists/</guid>
      <description>/** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func mergeKLists(lists []*ListNode) *ListNode { if len(lists)==0{ return nil } if len(lists)==1{ return lists[0] } // 看做left=0, right=len(lists)-1 mid:=(len(lists)-1+0)/2 // mid放在第一段里， [left, mid] (mid, right] left:=mergeKLists(lists[:mid+1]) right:=mergeKLists(lists[mid+1:]) return merge2List(left, right) } func merge2List(l1, l2 *ListNode)*ListNode{ // 一定要判断下l1,l2是否有nil的情况 if l1==nil{ return l2 } if l2==nil{ return l1 } dummy:=&amp;amp;ListNode{} tail:=dummy for l1!</description>
    </item>
    
    <item>
      <title>0143.reorder-list</title>
      <link>https://wncbb.github.io/posts/leetcode/0143.reorder-list/</link>
      <pubDate>Wed, 10 Mar 2021 11:56:29 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/0143.reorder-list/</guid>
      <description>/** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func reorderList(head *ListNode) { if head==nil || head.Next==nil{ return } firstPart, secondPart:=cutMid(head) secondPart=reverseList(secondPart) dummy:=&amp;amp;ListNode{} tail:=dummy for firstPart!=nil &amp;amp;&amp;amp; secondPart!=nil{ tail.Next=firstPart firstPart=firstPart.Next tail=tail.Next tail.Next=secondPart secondPart=secondPart.Next tail=tail.Next } if firstPart!=nil{ tail.Next=firstPart } } // 1 2 3 4 5 // s // f func cutMid(head *ListNode)(*ListNode, *ListNode){ fast:=head slow:=head for fast!=nil &amp;amp;&amp;amp; fast.</description>
    </item>
    
    <item>
      <title>0054.spiral-matrix</title>
      <link>https://wncbb.github.io/posts/leetcode/0054.spiral-matrix/</link>
      <pubDate>Wed, 10 Mar 2021 11:46:17 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/0054.spiral-matrix/</guid>
      <description>func spiralOrder(matrix [][]int) []int { allNums:=len(matrix)*len(matrix[0]) left:=0 right:=len(matrix[0])-1 top:=0 bottom:=len(matrix)-1 rst:=make([]int, 0, allNums) for allNums&amp;gt;0{ for i:=left; i&amp;lt;=right &amp;amp;&amp;amp;allNums&amp;gt;0; i++{ rst=append(rst, matrix[top][i]) allNums-- } top++ for i:=top; i&amp;lt;=bottom &amp;amp;&amp;amp;allNums&amp;gt;0; i++{ rst=append(rst, matrix[i][right]) allNums-- } right-- // i的左边界是left，不是0 for i:=right; i&amp;gt;=left &amp;amp;&amp;amp;allNums&amp;gt;0; i--{ rst=append(rst, matrix[bottom][i]) allNums-- } bottom-- for i:=bottom; i&amp;gt;=top &amp;amp;&amp;amp;allNums&amp;gt;0; i--{ rst=append(rst, matrix[i][left]) allNums-- } left++ } return rst }  </description>
    </item>
    
    <item>
      <title>0200</title>
      <link>https://wncbb.github.io/posts/leetcode/0200.number-of-islands/</link>
      <pubDate>Wed, 10 Mar 2021 11:31:02 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/0200.number-of-islands/</guid>
      <description>func numIslands(grid [][]byte) int { rst:=0 for i:=0; i&amp;lt;len(grid); i++{ for j:=0; j&amp;lt;len(grid[0]); j++{ if grid[i][j]==&#39;0&#39;{ continue } rst++ delIsland(grid, i, j) } } return rst } func delIsland(grid [][]byte, i, j int){ // 千万别忘记这一个，如果是0, 直接返回，不然直接死循环 if grid[i][j]==&#39;0&#39;{ return } grid[i][j]=&#39;0&#39; dirs:=[][]int{{0, 1},{0, -1},{1, 0},{-1, 0}} for _, dir:=range dirs{ newI:=i+dir[0] newJ:=j+dir[1] if newI&amp;gt;=0 &amp;amp;&amp;amp; newI&amp;lt;len(grid) &amp;amp;&amp;amp; newJ&amp;gt;=0 &amp;amp;&amp;amp; newJ&amp;lt;len(grid[0]){ delIsland(grid, newI, newJ) } } }  </description>
    </item>
    
    <item>
      <title>0007.reverse-integer</title>
      <link>https://wncbb.github.io/posts/leetcode/0007.reverse-integer/</link>
      <pubDate>Wed, 10 Mar 2021 11:17:01 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/0007.reverse-integer/</guid>
      <description>func reverse(x int) int { ret := 0 for x != 0 { ret = ret*10 + x % 10 x /= 10 if ret &amp;lt; math.MinInt32 || ret &amp;gt; math.MaxInt32 { return 0 } } return ret }  </description>
    </item>
    
    <item>
      <title>0020.valid-parentheses</title>
      <link>https://wncbb.github.io/posts/leetcode/0020.valid-parentheses/</link>
      <pubDate>Wed, 10 Mar 2021 11:02:58 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/0020.valid-parentheses/</guid>
      <description>func isValid(s string) bool { sBytes:=[]byte(s) stack:=&amp;amp;Stack{ raw: make([]byte, 0, len(sBytes)), } for _, v:=range sBytes{ switch(v){ case &#39;(&#39;: stack.Push(v) case &#39;)&#39;: if stack.Empty(){ return false } if stack.Top()==&#39;(&#39;{ stack.Pop() }else{ stack.Push(v) } case &#39;[&#39;: stack.Push(v) case &#39;]&#39;: if stack.Empty(){ return false } if stack.Top()==&#39;[&#39;{ stack.Pop() }else{ stack.Push(v) } case &#39;{&#39;: stack.Push(v) case &#39;}&#39;: if stack.Empty(){ return false } if stack.Top()==&#39;{&#39;{ stack.Pop() }else{ stack.Push(v) } } } return stack.Empty() } type Stack struct{ raw []byte } func (s *Stack)Push(v byte){ s.</description>
    </item>
    
    <item>
      <title>0221.maximal-square</title>
      <link>https://wncbb.github.io/posts/leetcode/0221.maximal-square/</link>
      <pubDate>Wed, 10 Mar 2021 10:52:31 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/0221.maximal-square/</guid>
      <description>func maximalSquare(matrix [][]byte) int { dp:=make([][]int, 0, len(matrix)) for i:=0; i&amp;lt;len(matrix); i++{ dp=append(dp, make([]int, len(matrix[0]), len(matrix[0]))) } rst:=0 for i:=0; i&amp;lt;len(matrix); i++{ for j:=0; j&amp;lt;len(matrix[0]); j++{ if matrix[i][j]==&#39;0&#39;{ continue } if i==0 || j==0{ dp[i][j]=1 }else{ dp[i][j]=getMin(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])+1 } if rst&amp;lt;dp[i][j]{ rst=dp[i][j] } } } return rst*rst } func getMin(a int, s ... int)int{ ret:=a for _, v:=range s{ if ret&amp;gt;v{ ret=v } } return ret }  </description>
    </item>
    
    <item>
      <title>0012</title>
      <link>https://wncbb.github.io/posts/leetcode/0102.binary-tree-level-order-traversal/</link>
      <pubDate>Wed, 10 Mar 2021 00:05:49 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/0102.binary-tree-level-order-traversal/</guid>
      <description>/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func levelOrder(root *TreeNode) [][]int { rst:=make([][]int, 0) q:=make([]*TreeNode, 0) q=append(q, root) for len(q)&amp;gt;0{ nextQ:=make([]*TreeNode, 0) curRst:=make([]int, 0) for i:=0; i&amp;lt;len(q); i++{ curRst=append(curRst, q[i].Val) if q[i].Left!=nil{ nextQ=append(nextQ, q[i].Left) } if q[i].Right!=nil{ nextQ=append(nextQ, q[i].Right) } } rst=append(rst, curRst) q=nextQ } return rst }  </description>
    </item>
    
    <item>
      <title>0022</title>
      <link>https://wncbb.github.io/posts/leetcode/0022.generate-parentheses/</link>
      <pubDate>Tue, 09 Mar 2021 23:47:50 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/0022.generate-parentheses/</guid>
      <description>var rst []string func generateParenthesis(n int) []string { rst=make([]string, 0) cur:=make([]byte, 0, n*2) bt(cur, n, n) return rst } func bt(s []byte, openNum, closeNum int){ fmt.Printf(&amp;quot;s:%+v, openNum:%d closeNum:%d\n&amp;quot;, s, openNum, closeNum) if openNum==0 &amp;amp;&amp;amp; closeNum==0{ rst=append(rst, string(s)) return } if openNum&amp;gt;0 { openNum-- s=append(s, &#39;(&#39;) bt(s, openNum, closeNum) s=s[:len(s)-1] openNum++ } // 剩下的close的个数要大于open if closeNum&amp;gt;0 &amp;amp;&amp;amp; openNum&amp;lt;closeNum{ closeNum-- s=append(s, &#39;)&#39;) bt(s, openNum, closeNum) s=s[:len(s)-1] closeNum++ } }  </description>
    </item>
    
    <item>
      <title>0079</title>
      <link>https://wncbb.github.io/posts/leetcode/0079.word-search/</link>
      <pubDate>Tue, 09 Mar 2021 23:22:34 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/0079.word-search/</guid>
      <description>func exist(board [][]byte, word string) bool { for i:=0; i&amp;lt;len(board); i++{ for j:=0; j&amp;lt;len(board[0]); j++{ if findWord(board, i, j, word){ return true } } } return false } func findWord(board [][]byte, i, j int, word string)bool{ visited:=make([][]bool, 0, len(board)) for i:=0; i&amp;lt;len(board); i++{ visited=append(visited, make([]bool, len(board[0]), len(board[0]))) } dirs:=[][]int{ {0, 1}, {0, -1}, {1, 0}, {-1, 0}, } wordBytes:=[]byte(word) var inner func(i, j, k int)bool inner = func(i, j, k int)bool{ if wordBytes[k]!</description>
    </item>
    
    <item>
      <title>0739 Daily Temperatures</title>
      <link>https://wncbb.github.io/posts/leetcode/0739-daily-temperatures/</link>
      <pubDate>Tue, 09 Mar 2021 23:19:44 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/0739-daily-temperatures/</guid>
      <description>func dailyTemperatures(T []int) []int { if len(T)==0{ return []int{} } ret:=make([]int, len(T)) s:=&amp;amp;Stack{ raw: make([]int, 0), } s.Push(0) for i:=1; i&amp;lt;len(T); i++{ for !s.Empty() &amp;amp;&amp;amp; T[s.Top()]&amp;lt;T[i]{ targetIdx:=s.Pop() ret[targetIdx]=i-targetIdx } s.Push(i) } return ret } type Stack struct{ raw []int } func (s *Stack)Empty()bool{ return len(s.raw)==0 } func (s *Stack)Push(v int){ s.raw=append(s.raw, v) } func (s *Stack)Pop()int{ ret:=s.raw[len(s.raw)-1] s.raw=s.raw[:len(s.raw)-1] return ret } func (s *Stack)Top()int{ return s.raw[len(s.raw)-1] }  </description>
    </item>
    
    <item>
      <title>0019</title>
      <link>https://wncbb.github.io/posts/leetcode/0019.remove-nth-node-from-end-of-list/</link>
      <pubDate>Tue, 09 Mar 2021 23:17:58 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/0019.remove-nth-node-from-end-of-list/</guid>
      <description>/** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func removeNthFromEnd(head *ListNode, n int) *ListNode { if head==nil{ return nil } dummy:=&amp;amp;ListNode{} dummy.Next=head fastNode:=dummy slowNode:=dummy for i:=0; i&amp;lt;n; i++{ fastNode=fastNode.Next } for fastNode.Next!=nil{ fastNode=fastNode.Next slowNode=slowNode.Next } slowNode.Next=slowNode.Next.Next return dummy.Next }  </description>
    </item>
    
    <item>
      <title>0033</title>
      <link>https://wncbb.github.io/posts/leetcode/0033.search-in-rotated-sorted-array/</link>
      <pubDate>Sun, 07 Mar 2021 14:15:20 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/0033.search-in-rotated-sorted-array/</guid>
      <description>func search(nums []int, target int) int { left:=0 right:=len(nums)-1 for left&amp;lt;=right{ mid:=(left+right)/2 if nums[mid]==target{ return mid } // 分为两种情况，要么左边是有序的(左半边，最左侧数据&amp;lt;=最右侧数据)，要是是右边 if nums[left]&amp;lt;=nums[mid]{ // 在左侧数据里，既然是有序的，如果target在左侧左右边界里，那么right=mid // 否则就不在左侧，那么left=mid+1 if nums[left]&amp;lt;=target &amp;amp;&amp;amp; target&amp;lt;=nums[mid]{ right=mid }else{ left=mid+1 } }else{ if nums[mid+1]&amp;lt;=target &amp;amp;&amp;amp; target&amp;lt;=nums[right]{ left=mid+1 }else{ right=mid } } } return -1 }  </description>
    </item>
    
    <item>
      <title>0005</title>
      <link>https://wncbb.github.io/posts/leetcode/0005.longest-palindromic-substring/</link>
      <pubDate>Sat, 06 Mar 2021 22:30:31 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/0005.longest-palindromic-substring/</guid>
      <description>func longestPalindrome(s string) string { start:=0 end:=0 sBytes:=[]byte(s) dp:=make([][]bool, 0, len(sBytes)) for i:=0; i&amp;lt;len(sBytes); i++{ dp=append(dp, make([]bool, len(sBytes), len(sBytes))) } for l:=0; l&amp;lt;len(sBytes); l++{ for i:=0; i+l&amp;lt;len(sBytes); i++{ j:=i+l if l==0{ dp[i][j]=true }else if l==1{ if sBytes[i]==sBytes[j]{ dp[i][j]=true } }else{ if sBytes[i]==sBytes[j]{ dp[i][j]=dp[i+1][j-1] } } if dp[i][j] &amp;amp;&amp;amp; end-start&amp;lt;j-i{ end=j start=i } } } return string(sBytes[start:end+1]) }  </description>
    </item>
    
    <item>
      <title>0015.3sum</title>
      <link>https://wncbb.github.io/posts/leetcode/0015.3sum/</link>
      <pubDate>Sat, 06 Mar 2021 22:28:39 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/0015.3sum/</guid>
      <description>import( &amp;quot;sort&amp;quot; ) func threeSum(nums []int) [][]int { sort.Ints(nums) res:=make([][]int, 0) if len(nums)&amp;lt;=2{ return res } for i:=0; i&amp;lt;len(nums)-2; i++{ // 这里不会存在，0， 0， 0， 0，结果没有数据的原因，是 // i&amp;lt;len(nums)-2, i不会从0走到len(nums)-1 if i&amp;gt;0 &amp;amp;&amp;amp; nums[i]==nums[i-1] { continue } left:=i+1 right:=len(nums)-1 target:=-1*nums[i] for left&amp;lt;right{ if nums[left]+nums[right]==target{ res=append(res, []int{nums[i], nums[left], nums[right]}) // 有结果之后要去重， 没有结果的时候不能去重，比如0， 0， 0， 0...因为都一样，直接去重就都没了 for left&amp;lt;right &amp;amp;&amp;amp; nums[left]==nums[left+1]{ left++ } for left&amp;lt;right &amp;amp;&amp;amp; nums[right]==nums[right-1]{ right-- } left++ right-- }else if nums[left]+nums[right]&amp;lt;target{ left++ }else{ right-- } } } return res }  </description>
    </item>
    
    <item>
      <title>0031</title>
      <link>https://wncbb.github.io/posts/leetcode/0031.next-permutation/</link>
      <pubDate>Sat, 06 Mar 2021 21:43:31 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/0031.next-permutation/</guid>
      <description>func nextPermutation(nums []int) { if len(nums)&amp;lt;=1{ return } /* 举个例子： 0 1 2 3 4 1 2 5 8 7 step1: 从后往前，找第一个相邻的升序对(nums[i], nums[i+1]), 这里是5，8, i=2 step2: 在i的右侧，从右往前，找第一个大于nums[i]的数nums[j],这里是7， j=4 step3: 交换i, j 得到 0 1 2 3 4 1 2 7 8 5 step4: reverse(i+1, len(nums)-1) 得到： 1 2 7 5 8 */ i:=len(nums)-2 // 从后面开始，找第一个相邻的升序对 for i&amp;gt;=0 &amp;amp;&amp;amp; nums[i]&amp;gt;=nums[i+1]{ i-- } if i&amp;gt;=0{ j:=len(nums)-1 for j&amp;gt;i &amp;amp;&amp;amp; nums[i]&amp;gt;=nums[j]{ j-- } nums[i], nums[j]=nums[j], nums[i] } reverse(nums, i+1, len(nums)-1) } func reverse(nums []int, left, right int){ for left&amp;lt;right{ nums[left], nums[right]=nums[right], nums[left] left++ right-- } } // 1 2 5 8 7  </description>
    </item>
    
    <item>
      <title>0440.k-th-smallest-lexicographical-order</title>
      <link>https://wncbb.github.io/posts/leetcode/0440.k-th-smallest-in-lexicographical-order/</link>
      <pubDate>Sat, 06 Mar 2021 18:47:29 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/0440.k-th-smallest-in-lexicographical-order/</guid>
      <description>1func findKthNumber(n int, k int) int { 2	// 第一个数字一定是1 3	cur:=1 4	k-- 5	for k&amp;gt;0{ 6	nodes:=countNodes(n, cur) 7	if k&amp;lt;nodes{ 8 // ...k...nodes... 9 // 第k个元素在cur的孩子节点中，因此下降到自己的孩子节点，k-1表示刨去cur节点(root节点) 10	k-- 11	cur*=10 12	}else{ 13 // ...nodes...k... 14 // cur的子节点的个数小于k，说明第k个节点不在自己的孩子节点内部，cur++表示转向自己的兄弟节点 15	k-=nodes 16	cur++ 17	} 18	} 19	return cur 20} 21// 以cur为根节点，且最大值为n的十叉树中，有多少个元素 22// 比如下面，以x为root的树(咱们记作tree(x))的所有节点个数, 就等于各个层(从第0层到第N层)的节点的个数的和 23// x+1为root的树是x的右边的第一棵树, 记作tree(x+1) 24// 有意思的是： 对于第i层， 且i&amp;lt;N， tree(x)的第i层的节点的个数等于= tree(x+1)的第i层的第一个节点 - tree(x)的第i层的第一个节点 25// 对于第N层，节点个数= n - tree(x)的第N层的第一个节点 + 1 因为从0开始计数，所以要加1 26// 上面合起来就是： 取 MIN( tree(x+1).</description>
    </item>
    
    <item>
      <title>0206</title>
      <link>https://wncbb.github.io/posts/leetcode/0206.reverse-linked-list/</link>
      <pubDate>Sat, 06 Mar 2021 18:33:10 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/0206.reverse-linked-list/</guid>
      <description>func reverseList(head *ListNode) *ListNode { var newHead *ListNode cur:=head for cur!=nil{ next:=cur.Next cur.Next=newHead newHead=cur cur=next } return newHead }  </description>
    </item>
    
    <item>
      <title>0316</title>
      <link>https://wncbb.github.io/posts/leetcode/0316.remove-duplicate-letters/</link>
      <pubDate>Sat, 06 Mar 2021 15:57:34 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/0316.remove-duplicate-letters/</guid>
      <description>as same as 1081
func removeDuplicateLetters(s string) string { if len(s)&amp;lt;=1{ return s } sBytes:=[]byte(s) // 判断字符是否在栈中 inStack:=make([]bool, 256) // 判断当前剩下的字符中，每个字符还剩多少个 bytesNum:=make([]int, 256) for _, v:=range sBytes{ bytesNum[v]++ } // 变量名不要跟参数重复 stack:=&amp;amp;Stack{ raw: make([]byte, 0), } for _, v:=range sBytes{ // 只要遍历到，剩下的v的个数就要-- bytesNum[v]-- // 已经在栈中了，就不管了 if inStack[v]{ continue } // 如果栈顶元素t比当前v大，且后面还有栈顶元素t，那与其tv, 还不如vt, 后者字典序更小，因此直接pop出t for stack.Len()&amp;gt;0 &amp;amp;&amp;amp; stack.Top()&amp;gt;v &amp;amp;&amp;amp; bytesNum[stack.Top()]&amp;gt;0{ //fmt.Printf(&amp;quot;pop: %c\n&amp;quot;, stack.Top()) inStack[stack.Pop()]=false } stack.Push(v) // fmt.Printf(&amp;quot;stack: %s\n&amp;quot;, string(stack.raw)) inStack[v]=true } return string(stack.</description>
    </item>
    
    <item>
      <title>0055</title>
      <link>https://wncbb.github.io/posts/leetcode/0055.jump-game/</link>
      <pubDate>Sat, 06 Mar 2021 14:23:40 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/0055.jump-game/</guid>
      <description>func canJump(nums []int) bool { // 记录当前位置之前能够到达的最远索引 maxPosition:=0 for i:=0; i&amp;lt;len(nums); i++{ // 如果i大于当前能够到达的最远索引，说明没法到达了 // 因为游戏继续进行下去的前提是能够到达i， // i&amp;gt;maxPosition 表示当前的跳远最远距离都到达不了索引i了 if i&amp;gt;maxPosition{ return false } maxPosition=getMax(maxPosition, i+nums[i]) } return true } func getMax(a, b int)int{ if a&amp;gt;b{ return a } return b }  </description>
    </item>
    
    <item>
      <title>0045</title>
      <link>https://wncbb.github.io/posts/leetcode/0045.jump-game-ii/</link>
      <pubDate>Sat, 06 Mar 2021 13:43:02 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/0045.jump-game-ii/</guid>
      <description>func jump(nums []int) int { end:=0 steps:=0 maxPosition:=0 for i:=0; i&amp;lt;len(nums)-1; i++{ maxPosition=getMax(maxPosition, i+nums[i]) if i==end{ end=maxPosition steps++ } } return steps } func getMax(a, b int)int{ if a&amp;gt;b{ return a } return b }  </description>
    </item>
    
    <item>
      <title>0304.range-sum-query-2d-immutable</title>
      <link>https://wncbb.github.io/posts/leetcode/0304.range-sum-query-2d-immutable/</link>
      <pubDate>Tue, 02 Mar 2021 13:44:15 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/0304.range-sum-query-2d-immutable/</guid>
      <description>A00 A01 A02 A03 A10 A11 A12 A13 A20 A21 A22 A23 A30 A31 A32 A33 A21表示 i&amp;lt;=2, j&amp;lt;=1的矩形的和 // 需要判断下是否越界 如果要求A21 A21=(A11)+(A20)-(A10)+s[2][1] 如果求(i=1, j=1)跟(j=2, j=2)的和 和=A22-A12-A21+A11 如果求(i1, j1)跟(i2, j2)的和, 当然需要判断下边界 和=A[i2][j2]-A[i1-1][j2]-A[i2][j1-1]+A[i1-][j1-1]  type NumMatrix struct { raw [][]int } func Constructor(matrix [][]int) NumMatrix { if len(matrix)==0{ return NumMatrix{ raw: nil, } } raw := make([][]int, 0, len(matrix[0])) for i:=0; i&amp;lt;len(matrix); i++{ raw=append(raw, make([]int, len(matrix[0]), len(matrix[0]))) } for i:=0; i&amp;lt;len(matrix); i++{ for j:=0; j&amp;lt;len(matrix[0]); j++{ raw[i][j]=matrix[i][j] if i&amp;gt;0{ raw[i][j]+=raw[i-1][j] } if j&amp;gt;0{ raw[i][j]+=raw[i][j-1] } if i&amp;gt;0 &amp;amp;&amp;amp; j&amp;gt;0{ raw[i][j]-=raw[i-1][j-1] } } } return NumMatrix{ raw: raw, } } func (this *NumMatrix) SumRegion(row1 int, col1 int, row2 int, col2 int) int { ret:=this.</description>
    </item>
    
    <item>
      <title>0215</title>
      <link>https://wncbb.github.io/posts/leetcode/0215.kth-largest-element-in-an-array/</link>
      <pubDate>Mon, 01 Mar 2021 20:00:04 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/0215.kth-largest-element-in-an-array/</guid>
      <description>func findKthLargest(nums []int, k int) int { // kth内部从0开始算，第0大的数 return kth(nums, 0, len(nums)-1, k-1) } func kth(s []int, left, right, k int) int { if left &amp;lt;= right { // 这里的m一定是s里的元素的索引 m := partition(s, left, right) if m == k { return s[m] } if m &amp;lt; k { // 最后一个参数k return kth(s, m+1, right, k) } else { // 最后一个参数k return kth(s, left, m-1, k) } } return -1 } func partition(s []int, left, right int) int { i := left - 1 j := left pivot := s[right] for ; j &amp;lt; right; j++ { if s[j] &amp;gt; pivot { i = i + 1 s[i], s[j] = s[j], s[i] } } i = i + 1 s[i], s[j] = s[j], s[i] return i }  </description>
    </item>
    
    <item>
      <title>0121</title>
      <link>https://wncbb.github.io/posts/leetcode/0121.best-time-to-buy-and-sell-stock/</link>
      <pubDate>Sun, 28 Feb 2021 22:11:58 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/0121.best-time-to-buy-and-sell-stock/</guid>
      <description>func maxProfit(prices []int) int { if len(prices)==0{ return 0 } minPrice:=0 maxProfit:=0 minPrice=prices[0] for _, v:=range prices{ if minPrice&amp;gt;v{ minPrice=v }else if maxProfit&amp;lt; v-minPrice{ maxProfit=v-minPrice } } return maxProfit }  </description>
    </item>
    
    <item>
      <title>0122.best-time-to-buy-and-sell-stock-ii</title>
      <link>https://wncbb.github.io/posts/leetcode/0122.best-time-to-buy-and-sell-stock-ii/</link>
      <pubDate>Sun, 28 Feb 2021 21:55:34 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/0122.best-time-to-buy-and-sell-stock-ii/</guid>
      <description>// dp[i][0]表示第i天结束后，不持有股票的最大收益 // dp[i][1]表示第i天结束后，持有股票的最大收益 func maxProfit(prices []int) int { n := len(prices) dp := make([][2]int, n) dp[0][1] = -prices[0] for i := 1; i &amp;lt; n; i++ { // 第i天结束后不持有股票，有两种可能： // 1. 昨天就不持有股票 // 2. 昨天持有股票，今天卖掉了 dp[i][0] = max(dp[i-1][0], dp[i-1][1]+prices[i]) // 第i天结束后持有股票，有两种可能： // 1. 昨天就持有股票 // 2. 昨天不持有股票，今天又买进了 dp[i][1] = max(dp[i-1][1], dp[i-1][0]-prices[i]) } return dp[n-1][0] } func max(a, b int) int { if a &amp;gt; b { return a } return b }  </description>
    </item>
    
    <item>
      <title>0096.unique-binary-search-trees</title>
      <link>https://wncbb.github.io/posts/leetcode/0096.unique-binary-search-trees/</link>
      <pubDate>Fri, 26 Feb 2021 15:57:23 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/0096.unique-binary-search-trees/</guid>
      <description>/* G(n): 长度为 n 的序列能构成的不同二叉搜索树的个数。 F(i, n): 以 i 为根、序列长度为 n 的不同二叉搜索树个数 G(n)=F(1, n)+F(2, n)+...+F(n, n) 1 2 3 ... i ... n A A A AAA BBB B F(i, n)=G(i-1)*G(n-i) ^^ F(i, n)， i已经是root了，那么i左边的部分A是left tree, i右边的部分B是right tree 从A组成的tree list里选一个，从B组成的tree list里选一种，总共就是两者相乘的可能数 i的范围是从1到n，对应到代码里，是从1到i, 因为求的是G[i], 此时n=i */ func numTrees(n int) int { G := make([]int, n + 1) G[0], G[1] = 1, 1 for i := 2; i &amp;lt;= n; i++ { // for j := 1; j &amp;lt;= i; j++ { G[i] += G[j-1] * G[i-j] } } return G[n] }  </description>
    </item>
    
    <item>
      <title>0105.construct-binary-tree-from-preorder-and-inorder-traversal</title>
      <link>https://wncbb.github.io/posts/leetcode/0105.construct-binary-tree-from-preorder-and-inorder-traversal/</link>
      <pubDate>Fri, 26 Feb 2021 15:37:56 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/0105.construct-binary-tree-from-preorder-and-inorder-traversal/</guid>
      <description>/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func buildTree(preorder []int, inorder []int) *TreeNode { if len(preorder)==0{ return nil } curNode:=&amp;amp;TreeNode{ Val: preorder[0], } rootValIdxInInorder:=0 for idx, v:=range inorder{ if v==preorder[0]{ rootValIdxInInorder=idx break } } // 难在构建左子树、右子树函数的参数 // preorder: root A B // inorder: A root B // 所以找到A与B在preorder/inorder里的起始位置，再将A/B part作为参数即可 curNode.Left=buildTree(preorder[1:len(inorder[:rootValIdxInInorder])+1], inorder[:rootValIdxInInorder]) curNode.Right=buildTree(preorder[len(inorder[:rootValIdxInInorder])+1:], inorder[rootValIdxInInorder+1:]) return curNode }  </description>
    </item>
    
    <item>
      <title>0103.binary-tree-zigzag-level-order-traversal</title>
      <link>https://wncbb.github.io/posts/leetcode/0103.binary-tree-zigzag-level-order-traversal/</link>
      <pubDate>Fri, 26 Feb 2021 15:22:21 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/0103.binary-tree-zigzag-level-order-traversal/</guid>
      <description>/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func zigzagLevelOrder(root *TreeNode) [][]int { if root==nil{ return nil } ret:=make([][]int, 0) nextQ:=make([]*TreeNode, 0) nextQ=append(nextQ, root) level:=0 for len(nextQ)!=0{ curQ:=nextQ nextQ=make([]*TreeNode, 0) curVals:=make([]int, 0, len(curQ)) for i:=0; i&amp;lt;len(curQ); i++{ curNode:=curQ[i] if curNode.Left!=nil{ nextQ=append(nextQ, curNode.Left) } if curNode.Right!=nil{ nextQ=append(nextQ, curNode.Right) } curVals=append(curVals, curNode.Val) } // 为了简单，直接根据层数的奇偶来做倒置 if level%2==1{ for i:=0; i&amp;lt;len(curVals)/2; i++{ curVals[i], curVals[len(curVals)-i-1]=curVals[len(curVals)-i-1], curVals[i] } } ret=append(ret, curVals) level++ } return ret }  </description>
    </item>
    
    <item>
      <title>0124.binary-tree-maximum-path-sum</title>
      <link>https://wncbb.github.io/posts/leetcode/0124.binary-tree-maximum-path-sum/</link>
      <pubDate>Fri, 26 Feb 2021 14:58:35 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/0124.binary-tree-maximum-path-sum/</guid>
      <description>```go /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ var ret int var retIsSet bool func maxPathSum(root *TreeNode) int { ret=0 retIsSet=false
helper(root) return ret  }
// 获得一定包含root，且以root为起点，且单边(左子树或右子树路径上单链，当然可以只包含root，比如root的下面的节点都是负数，就可以只包含root)的最大值 func helper(root *TreeNode) int { if root==nil{ return 0 }
// 如果helper(root.Left)为负数，还不如不包含后面的节点，直接设置为0 left:=getMax(0, helper(root.Left)) right:=getMax(0, helper(root.Right)) // 以root为最高层节点，的结果的最优值，只要遍历所有节点的最优值，且取最大值，即得到结果 curVal:=left+right+root.Val if retIsSet{ ret=getMax(ret, curVal) }else{ retIsSet=true ret=curVal } if left&amp;gt;right{ return left+root.</description>
    </item>
    
    <item>
      <title>0199.binary-tree-right-side-view</title>
      <link>https://wncbb.github.io/posts/leetcode/0199.binary_tree_right_side_view/</link>
      <pubDate>Fri, 26 Feb 2021 14:55:03 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/0199.binary_tree_right_side_view/</guid>
      <description>需要区分二叉树的这一层下一层，准备俩queue，一个当前处理的curQ， 一个q存放从curQ里出来的node的孩子节点 然后curQ=q; q=nil 继续下一次循环
/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func rightSideView(root *TreeNode) []int { if root==nil{ return nil } ret:=make([]int, 0) q:=make([]*TreeNode, 0) q=append(q, root) for len(q)!=0{ curRst:=0 curQ:=q q=nil for i:=0; i&amp;lt;len(curQ); i++{ curNode:=curQ[i] curRst=curNode.Val if curNode.Left!=nil{ q=append(q, curNode.Left) } if curNode.Right!=nil{ q=append(q, curNode.Right) } } ret=append(ret, curRst) } return ret }  </description>
    </item>
    
    <item>
      <title>0025.reverse-nodes-in-k-group</title>
      <link>https://wncbb.github.io/posts/leetcode/0025.reverse-nodes-in-k-group/</link>
      <pubDate>Thu, 25 Feb 2021 15:58:28 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/0025.reverse-nodes-in-k-group/</guid>
      <description>1package main 2 3import &amp;#34;fmt&amp;#34; 4 5// Definition for singly-linked list. 6type ListNode struct { 7	Val int 8	Next *ListNode 9} 10 11func reverseKGroup(head *ListNode, k int) *ListNode { 12	if head==nil || head.Next==nil{ 13	return head 14	} 15	if k&amp;lt;=1{ 16	return head 17	} 18 19	lastNode:=head 20	for i:=0; i &amp;lt; k-1; i++ { 21	lastNode = lastNode.Next 22	if lastNode==nil{ 23	return head 24	} 25	} 26 27	// nextPartHead是下一段的开始节点 28	nextPartHead := lastNode.</description>
    </item>
    
    <item>
      <title>0560.subarray-sum-equals-k</title>
      <link>https://wncbb.github.io/posts/leetcode/0560.subarray-sum-equals-k/</link>
      <pubDate>Thu, 31 Dec 2020 17:01:26 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/0560.subarray-sum-equals-k/</guid>
      <description>题目简介 给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。
示例 1 :
输入:nums = [1,1,1], k = 2 输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。 说明 :
数组的长度为 [1, 20,000]。 数组中元素的范围是 [-1000, 1000] ，且整数 k 的范围是 [-1e7, 1e7]。
解 解1 1/* 2比如 ABCDEFG... 3如果当前所有的和是Sum(A...G) 4如果存在Sum(A...X), 使得 Sum(A...X)+k=Sum(A...G)， 5也就是说，Sum(A...G)-k这个数存在， 6那么，(X...G]就是满足条件的 7*/ 8 9class Solution { 10 public int subarraySum(int[] nums, int k) { 11 // 扫描一遍数组, 使用map记录出现同样的和的次数, 对每个i计算累计和sum并判断map内是否有sum-k 12 Map&amp;lt;Integer, Integer&amp;gt; map = new HashMap&amp;lt;&amp;gt;(); 13 // 放0的目的是： 如果Sum(A.</description>
    </item>
    
    <item>
      <title>0435.non-overlapping-intervals</title>
      <link>https://wncbb.github.io/posts/leetcode/0435.non-overlapping-intervals/</link>
      <pubDate>Thu, 31 Dec 2020 15:23:58 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/0435.non-overlapping-intervals/</guid>
      <description>示例 1: 输入: [ [1,2], [2,3], [3,4], [1,3] ] 输出: 1 解释: 移除 [1,3] 后，剩下的区间没有重叠。 示例 2: 输入: [ [1,2], [1,2], [1,2] ] 输出: 2 解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。 贪心策略: 先按照右边界从小到大排序，然后依次遍历，不能放进去的(左边界小于左边区间的右边界)，就删掉  1import ( 2	&amp;#34;sort&amp;#34; 3) 4 5// non-overlapping-intervals 6func eraseOverlapIntervals(intervals [][]int) int { 7	if len(intervals) == 0 { 8	return 0 9	} 10	sort.Slice(intervals, func(i, j int) bool { 11	return intervals[i][1] &amp;lt; intervals[j][1] 12	}) 13 14	curRight := intervals[0][1] 15	ret := 0 16	for i := 1; i &amp;lt; len(intervals); i++ { 17	if curRight &amp;lt;= intervals[i][0] { 18	curRight = intervals[i][1] 19	} else { 20	ret++ 21	} 22	} 23	return ret 24} </description>
    </item>
    
    <item>
      <title>0003.longest-substring-without-repeating-characters</title>
      <link>https://wncbb.github.io/posts/leetcode/0003.longest-substring-without-repeating-characters/</link>
      <pubDate>Wed, 30 Dec 2020 20:48:41 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/0003.longest-substring-without-repeating-characters/</guid>
      <description>1func getMax(a, b int)int{ 2 if a&amp;gt;b{ 3 return a 4 } 5 return b 6} 7func getMin(a, b int)int{ 8 if a&amp;gt;b{ 9 return b 10 } 11 return a 12} 13 14func lengthOfLongestSubstring(s string) int { 15 lookup := make(map[rune]int) 16	curLeft := 0 17	maxLen := 0 18	for k, v := range s { 19	if lastIdx, ok := lookup[v]; ok { 20 curLeft=getMax(lastIdx+1, curLeft) 21	} 22 maxLen=getMax(maxLen, k-curLeft+1) 23 lookup[v]=k 24	} 25	return maxLen 26} </description>
    </item>
    
    <item>
      <title>0004.median-of-two-sorted-arrays</title>
      <link>https://wncbb.github.io/posts/leetcode/0004.median-of-two-sorted-arrays/</link>
      <pubDate>Wed, 30 Dec 2020 20:04:23 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/0004.median-of-two-sorted-arrays/</guid>
      <description>示例 1： 输入：nums1 = [1,3], nums2 = [2] 输出：2.00000 解释：合并数组 = [1,2,3] ，中位数 2 示例 2： 输入：nums1 = [1,2], nums2 = [3,4] 输出：2.50000 解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5 示例 3： 输入：nums1 = [0,0], nums2 = [0,0] 输出：0.00000 示例 4： 输入：nums1 = [], nums2 = [1] 输出：1.00000 示例 5： 输入：nums1 = [2], nums2 = [] 输出：2.00000  1import ( 2	&amp;#34;math&amp;#34; 3) 4 5func findMedianSortedArrays(nums1 []int, nums2 []int) float64 { 6	left := (len(nums1) + len(nums2) + 1) / 2 7	right := (len(nums1) + len(nums2) + 2) / 2 8	return (float64(findK(nums1, 0, nums2, 0, left)) + float64(findK(nums1, 0, nums2, 0, right))) / 2.</description>
    </item>
    
    <item>
      <title>0208.mplement-trie-prefix-tree</title>
      <link>https://wncbb.github.io/posts/leetcode/0208.mplement-trie-prefix-tree/</link>
      <pubDate>Wed, 30 Dec 2020 19:12:02 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/0208.mplement-trie-prefix-tree/</guid>
      <description>1type Node struct { 2	IsEnd bool 3	Val rune 4	Next map[rune]*Node 5} 6 7type Trie struct { 8	root *Node 9} 10 11/** Initialize your data structure here. */ 12func Constructor() Trie { 13	return Trie{ 14	root: &amp;amp;Node{ 15	Next: make(map[rune]*Node), 16	}, 17	} 18} 19 20/** Inserts a word into the trie. */ 21func (this *Trie) Insert(word string) { 22	cur := this.root 23	for _, v := range word { 24	if nextNode, ok := cur.</description>
    </item>
    
    <item>
      <title>1035.uncrossed-lines</title>
      <link>https://wncbb.github.io/posts/leetcode/1035.uncrossed-lines/</link>
      <pubDate>Wed, 30 Dec 2020 18:40:16 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/1035.uncrossed-lines/</guid>
      <description>给定 1 4 2 1 2 4 上下相同的数连接画一条线，最多只能画两条线 类似： 1143 本质是最长公共子序列  1func maxUncrossedLines(A []int, B []int) int { 2	dp := make([][]int, 0, len(A)+1) 3	for i := 0; i &amp;lt; len(A)+1; i++ { 4	dp = append(dp, make([]int, len(B)+1, len(B)+1)) 5	} 6 7	for i, v1 := range A { 8	for j, v2 := range B { 9	if v1 == v2 { 10	dp[i+1][j+1] = dp[i][j] + 1 11	} else { 12	dp[i+1][j+1] = getMaxInt(dp[i+1][j], dp[i][j+1]) 13	} 14	} 15	} 16 17	return dp[len(A)][len(B)] 18} 19 20func getMaxInt(a, b int) int { 21	if a &amp;gt; b { 22	return a 23	} 24	return b 25} </description>
    </item>
    
    <item>
      <title>1143.longest-common-subsequence</title>
      <link>https://wncbb.github.io/posts/leetcode/1143.longest-common-subsequence/</link>
      <pubDate>Wed, 30 Dec 2020 18:32:29 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/1143.longest-common-subsequence/</guid>
      <description>两个数组的 最长公共子序列 子序列：不一定连续 1143 子数组：一定连续 718 换汤不换药 1035  1func longestCommonSubsequence(text1 string, text2 string) int { 2	dp := make([][]int, 0, len(text1)+1) 3	for i := 0; i &amp;lt; len(text1)+1; i++ { 4	dp = append(dp, make([]int, len(text2)+1, len(text2)+1)) 5	} 6 7	for i, ch1 := range text1 { 8	for j, ch2 := range text2 { 9	if ch1 == ch2 { 10	dp[i+1][j+1] = dp[i][j] + 1 11	} else { 12	dp[i+1][j+1] = getMaxInt(dp[i+1][j], dp[i][j+1]) 13	} 14	} 15	} 16 17	return dp[len(text1)][len(text2)] 18} 19 20func getMaxInt(a, b int) int { 21	if a &amp;gt; b { 22	return a 23	} 24	return b 25} </description>
    </item>
    
    <item>
      <title>0718.maximum-length-of-repeated-subarray</title>
      <link>https://wncbb.github.io/posts/leetcode/0718.maximum-length-of-repeated-subarray/</link>
      <pubDate>Wed, 30 Dec 2020 17:26:31 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/0718.maximum-length-of-repeated-subarray/</guid>
      <description>两个数组的 最长子数组 子序列：不一定连续 1143 子数组：一定连续 718  1func findLength(A []int, B []int) int { 2	if len(A) == 0 || len(B) == 0 { 3	return 0 4	} 5	6 // dp[i][j]表示以A[i] B[j]结尾的相同子数组的长度 7	dp := make([][]int, 0, len(A)) 8	for i := 0; i &amp;lt; len(A); i++ { 9	dp = append(dp, make([]int, len(B), len(B))) 10	} 11 12 // 为了避免i=0, j=0, 此时0-1=-1，索引非法的问题，先初始化0的情况 13	for i := 0; i &amp;lt; len(A); i++ { 14	if A[i] == B[0] { 15	dp[i][0] = 1 16	} 17	} 18	for j := 0; j &amp;lt; len(B); j++ { 19	if A[0] == B[j] { 20	dp[0][j] = 1 21	} 22	} 23 24	ret := 0 25 26	for i := 1; i &amp;lt; len(A); i++ { 27	for j := 1; j &amp;lt; len(B); j++ { 28	if A[i] == B[j] { 29	dp[i][j] = dp[i-1][j-1] + 1 30	if ret &amp;lt; dp[i][j] { 31	ret = dp[i][j] 32	} 33	} 34	} 35	} 36 37	return ret 38} 或者数组多一位  1func findLength(A []int, B []int) int { 2	if len(A) == 0 || len(B) == 0 { 3	return 0 4	} 5 6	dp := make([][]int, 0, len(A)+1) 7	for i := 0; i &amp;lt; len(A)+1; i++ { 8	dp = append(dp, make([]int, len(B)+1, len(B)+1)) 9	} 10 11	ret := 0 12 13	for i := 1; i &amp;lt;= len(A); i++ { 14	for j := 1; j &amp;lt;= len(B); j++ { 15	if A[i-1] == B[j-1] { 16	dp[i][j] = dp[i-1][j-1] + 1 17	if ret &amp;lt; dp[i][j] { 18	ret = dp[i][j] 19	} 20	} 21	} 22	} 23 24	return ret 25} 26``` </description>
    </item>
    
    <item>
      <title>1206.design-skiplist</title>
      <link>https://wncbb.github.io/posts/leetcode/1206.design-skiplist/</link>
      <pubDate>Wed, 30 Dec 2020 16:37:20 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/1206.design-skiplist/</guid>
      <description>1import ( 2	&amp;#34;math/rand&amp;#34; 3) 4 5const ( 6	maxLevel = 16 7	skipListPVal = 0.5 8) 9 10// randomLevel 返回一个Next数组的高度, 高度不能超过最大值 11func randomLevel() int { 12	retLevel := 1 13	for retLevel &amp;lt; maxLevel &amp;amp;&amp;amp; rand.Float32() &amp;lt; skipListPVal { 14	retLevel++ 15	} 16	return retLevel 17} 18 19type Node struct { 20	Val int 21	Next [maxLevel]*Node 22} 23 24func NewNode(val int, next [maxLevel]*Node) *Node { 25	return &amp;amp;Node{ 26	Val: val, 27	Next: next, 28	} 29} 30 31type Skiplist struct { 32	head *Node 33	maxLevel int 34} 35 36func Constructor() Skiplist { 37	return Skiplist{ 38	// head 里的值是最小值,这里取-1 39	head: NewNode(-1, [maxLevel]*Node{}), 40	maxLevel: 1, 41	} 42} 43 44func (this *Skiplist) search(target int) [maxLevel]*Node { 45	cur := this.</description>
    </item>
    
    <item>
      <title>0032.longest-valid-parentheses</title>
      <link>https://wncbb.github.io/posts/leetcode/0032.longest-valid-parentheses/</link>
      <pubDate>Tue, 22 Dec 2020 16:27:41 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/0032.longest-valid-parentheses/</guid>
      <description>1func longestValidParentheses(s string) int { 2	rst := 0 3 // dp[i] 表示以s[i]字符结尾的最长的合法的括号长度 4	dp := make([]int, len(s), len(s)) 5	for i := 1; i &amp;lt; len(s); i++ { 6	curByte := s[i] 7 // 如果s[i]是左括号，那么以左括号为结尾的字符串，一定不是合法的，长度就是0 8	if curByte == &amp;#39;(&amp;#39; { 9	continue 10	} 11 // 如果s[i]是右括号，比如这种 ?()) 12 // 就需要看一下，s[i-1]结尾的合法字符串的前一个是不是左括号， 13 // 如果是，需要加2（一个是当前的右括号，一个是dp[i-1]之前的左括号) 14	leftIdx := i - dp[i-1] - 1 15	if leftIdx &amp;gt;= 0 &amp;amp;&amp;amp; s[leftIdx] == &amp;#39;(&amp;#39; { 16	dp[i] = dp[i-1] + 2 17	leftLeftIdx := i - dp[i-1] - 2 18 // 这里还需要加上dp[i-1]之前的合法字符串的长度 19 // 对应这种情况: ()(()) 20 // 这里只需要看一次就行，因为如果前面还有的话，一定包含在dp[i-dp[i-1]-2]里了 21	if leftLeftIdx &amp;gt;= 0 { 22	dp[i] += dp[leftLeftIdx] 23	} 24	} 25	if rst &amp;lt; dp[i] { 26	rst = dp[i] 27	} 28 29	} 30	return rst 31} </description>
    </item>
    
    <item>
      <title>0030.substring-with-concatenation-of-all-words</title>
      <link>https://wncbb.github.io/posts/leetcode/0030.substring-with-concatenation-of-all-words/</link>
      <pubDate>Fri, 18 Dec 2020 19:56:59 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/0030.substring-with-concatenation-of-all-words/</guid>
      <description>有点暴力的解法，就是遍历所有可能的窗口  1func findSubstring(s string, words []string) []int { 2	//声明返回值 3	var result []int 4 5	//判断 6	if len(s) == 0 || len(words) == 0 { 7	return result 8	} 9 10 11	//获取单词长度 12	l := len(words[0]) 13 14	//获取滑动窗口总长度 15	length := l * len(words) 16 17	//判断 18	if length &amp;gt; len(s) { 19	return result 20	} 21 22	//构造map 23	mp := make(map[string]int) 24 25	//统计 26	for _,v := range words { 27	mp[v] += 1 28	} 29 30	//开始遍历 31	for i := 0; i &amp;lt;= (len(s) - length);i++ { 32	//判断i开始length位置 33	tmpMap := map[string]int{} 34 35	//定义标志 36	//默认是true 37	fg := true 38 39	// 这里的逻辑是，如果当前的单词是需要的，且个数还没凑够，那就对应的数减一 40	// 如果遇到不需要的单词，一定就不合法了.</description>
    </item>
    
    <item>
      <title>0336.palindrome-pairs</title>
      <link>https://wncbb.github.io/posts/leetcode/0336.palindrome-pairs/</link>
      <pubDate>Fri, 18 Dec 2020 19:36:38 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/0336.palindrome-pairs/</guid>
      <description>1func palindromePairs(words []string) [][]int { 2	m := make(map[string]int, len(words)) 3	for idx, v := range words { 4	m[v] = idx 5	} 6 7	res := make([][]int, 0) 8 9	for idx, v := range words { 10	// 如果非空字符串v是回文串，且字符数组中包含空字符串，那么 v+&amp;#34;&amp;#34; 与 &amp;#34;&amp;#34;+v 都是回文串 11	if emptyStrIdx, ok := m[&amp;#34;&amp;#34;]; ok &amp;amp;&amp;amp; isPalindrome(v) &amp;amp;&amp;amp; v != &amp;#34;&amp;#34; { 12	res = append(res, []int{emptyStrIdx, idx}) 13	res = append(res, []int{idx, emptyStrIdx}) 14	} 15	// v的逆序字符串存在的话，那么这俩一拼也是回文串，注意这里只加一次( 16	// 比如A的逆序是B, 遍历到A的话，加入A,B; 17	// 遍历到B的时候，加入B,A，就不会重复 18	// ) 19 // 其实v !</description>
    </item>
    
    <item>
      <title>0010.regular-expression-matching</title>
      <link>https://wncbb.github.io/posts/leetcode/0010.regular-expression-matching/</link>
      <pubDate>Thu, 17 Dec 2020 17:22:10 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/0010.regular-expression-matching/</guid>
      <description>1func isMatch(s string, p string) bool { 2 // sBytes := []byte(s) 3 // pBytes := []byte(p) 4 // dp[i][j]表示s[:i+1] p[:j+1]是否匹配 5 dp := make([][]bool, 0, len(s)+1) 6 for i := 0; i &amp;lt; len(s)+1; i++ { 7 dp = append(dp, make([]bool, len(p)+1)) 8 } 9 // s跟p都是空字符，肯定匹配的上 10 dp[0][0] = true 11 for i := 1; i &amp;lt; len(p); i++ { 12 // 如果当前p[i]是*，那么*可以把前面的字符搞没 13 // 比如 &amp;#34;b*a*&amp;#34; 跟 &amp;#34;&amp;#34;比较，a*可以去掉，那么就变成&amp;#34;b*&amp;#34;跟&amp;#34;&amp;#34;比较 14 if p[i] == &amp;#39;*&amp;#39; { 15 dp[0][i+1] = dp[0][i-1] 16 } 17 } 18 19	for i, sByte := range s { 20	for j, pByte := range p { 21	switch { 22	case sByte == pByte: 23 // 最简单的case，俩字符一样，那么前面的如果匹配，这个一定匹配 24	dp[i+1][j+1] = dp[i+1][j+1] || dp[i][j] 25	case pByte == &amp;#39;.</description>
    </item>
    
    <item>
      <title>0076.minimum-window-substring</title>
      <link>https://wncbb.github.io/posts/leetcode/0076.minimum-window-substring/</link>
      <pubDate>Mon, 14 Dec 2020 16:47:32 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/0076.minimum-window-substring/</guid>
      <description>滑动窗口逻辑： 声明俩变量left right初始化为0 1. 右边界往右遍历，符合条件后， 2. 左边界往右遍历，直到不符合条件，再跳到1 期间符合条件时，更新下当前的最优解 for right&amp;lt;number{ handle value[right] right++ if left&amp;lt;=right and satisfy the condition { current left and right are good result, update final result left++ } }  1func minWindow(s string, t string) string { 2	retLeft := 0 3	retRight := len(s) + 100 4	left := 0 5	right := 0 6	// 记录t中，byte到个数的map 7	visited := make(map[byte]int) 8	// 实时记录，当前left到right之间的t中字符，byte到个数的映射 9	curVisited := make(map[byte]int) 10	curFitNum := 0 11	tBytes := []byte(t) 12	for _, v := range tBytes { 13	visited[v] += 1 14	} 15	for _, v := range tBytes { 16	curVisited[v] = 0 17	} 18	// t中unique的字符个数 19	fitNum := len(visited) 20	for right &amp;lt; len(s) { 21	// 遍历右边，并处理curVisited, curFitNum等中间记录当前状态的变量 22	curRightByte := s[right] 23	if _, ok := curVisited[curRightByte]; ok { 24	curVisited[curRightByte]++ 25	if curVisited[curRightByte] == visited[curRightByte] { 26	curFitNum++ 27	} 28	} 29	right++ 30 31	for left &amp;lt;= right &amp;amp;&amp;amp; curFitNum == fitNum { 32	// 当left在合法范围内，且当前符合条件时 33	// 检查下是否更新返回值 34	if right-left &amp;lt; retRight-retLeft { 35	retRight = right 36	retLeft = left 37	} 38 39 // 去掉left的字符后，处理curVisited, curFitNum等中间记录当前状态的变量 40	curLeftByte := s[left] 41	if v, ok := curVisited[curLeftByte]; ok { 42	if v == visited[curLeftByte] { 43	curFitNum-- 44	} 45	curVisited[curLeftByte]-- 46 47	} 48	left++ 49	} 50	} 51	if retRight &amp;gt; len(s) { 52	return &amp;#34;&amp;#34; 53	} 54	return s[retLeft:retRight] 55} </description>
    </item>
    
    <item>
      <title>0042.rapping-rain-water</title>
      <link>https://wncbb.github.io/posts/leetcode/0042.trapping-rain-water/</link>
      <pubDate>Thu, 10 Dec 2020 19:03:01 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/0042.trapping-rain-water/</guid>
      <description>单调栈解法 1func trap(height []int) int { 2 if len(height)&amp;lt;=2{ 3 return 0 4 } 5 6 s:=&amp;amp;Stack{ 7 raw: make([]int, 0), 8 } 9 s.Push(0) 10 rst:=0 11 for i:=1; i&amp;lt;len(height); i++{ 12 v:=height[i] 13 for s.Len()&amp;gt;0 &amp;amp;&amp;amp; v&amp;gt;height[s.Top()]{ 14	// 其实要算的是targetIdx位置的雨水 15 targetIdx:=s.Pop() 16 if s.Len()&amp;gt;0{ 17	// 栈顶元素是左边界 18 leftIdx:=s.Top() 19	// i是右边界 20 rightIdx:=i 21	// 存储水量取决于左右边界的最低值，然后减去target的高度，就是存水量的高, 再乘以宽度，就是水量 22	// 宽度是 rightIdx-leftIdx-1， 比如 3， 4， 5， 6， 7 23	// 如果leftIdx=3, rightIdx=7， 那么要取4， 5， 6的宽度3， 7-3=4， 需要再减去1 24 rst+= (getMin(height[leftIdx], height[rightIdx])-height[targetIdx])*(rightIdx-leftIdx-1) 25 } 26 } 27 s.</description>
    </item>
    
    <item>
      <title>0053.maximum-subarray</title>
      <link>https://wncbb.github.io/posts/leetcode/0053.maximum-subarra/</link>
      <pubDate>Thu, 10 Dec 2020 16:33:51 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/0053.maximum-subarra/</guid>
      <description>1func maxSubArray(nums []int) int { 2	if len(nums) == 0 { 3	return 0 4	} 5	// dp[i]表示以i结尾的和 6	dp := make([]int, len(nums), len(nums)) 7	dp[0] = nums[0] 8	rst := nums[0] 9	for i := 1; i &amp;lt; len(nums); i++ { 10	// 对于以i结尾的连续数组，要么就他自己，要么他自己加上以i-1为结尾的最大值 11	dp[i] = max(nums[i], nums[i]+dp[i-1]) 12	if dp[i] &amp;gt; rst { 13	rst = dp[i] 14	} 15	} 16 17	return rst 18} 19 20func max(a, b int) int { 21	if a &amp;gt; b { 22	return a 23	} 24	return b 25} </description>
    </item>
    
    <item>
      <title>0041.first-missing-positive</title>
      <link>https://wncbb.github.io/posts/leetcode/0041.first-missing-positive/</link>
      <pubDate>Thu, 10 Dec 2020 16:17:11 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/0041.first-missing-positive/</guid>
      <description>比如2， 3，-1， 6 遍历一遍，负数变成默认值: 数组长度 原因是需要拿负号做标记，所以先把原来的负数干掉 先变成 2， 3， 5， 6 然后，遇到2，如果2在len里面，且对应位置的数是整数，就改成负数 2, -3, -5, 6 这样，遍历一遍，第一个正数对应的位置，就是第一个缺失的正整数  1func firstMissingPositive(nums []int) int { 2	for i, _ := range nums { 3	if nums[i] &amp;lt;= 0 { 4	nums[i] = len(nums) + 1 5	} 6	} 7	8	for i, _ := range nums { 9	// abs(nums[i]) 10	// is for 3, 4, -1, 1 11	// otherwise 12	// after checking negative, would be 3, 4, 5, 1 13	// after this lookp, would be 3, 4, -5, -1 14	// then 1 would be returned 15	// the reason is that the last value 1 is set to negative 16	// so we need to ignore negative, just use abs value 17	cur := abs(nums[i]) 18	// nums[cur-1] &amp;gt; 0 19	// is for 1, 1 20	// otherwise 21	// after checking ne4tative, would be 1, 1 22	// after this lookup, would be -1, 1, then 1, 1 23	// the zero index was set two times, and -1*-1=1 24	// so for one index, we only need to set one time 25	if cur &amp;gt; 0 &amp;amp;&amp;amp; cur &amp;lt; len(nums)+1 &amp;amp;&amp;amp; nums[cur-1] &amp;gt; 0 { 26	nums[cur-1] *= -1 27	} 28	} 29 30	for i, _ := range nums { 31	if nums[i] &amp;gt; 0 { 32	return i + 1 33	} 34	} 35 36	return len(nums) + 1 37} 38 39func abs(a int) int { 40	if a &amp;lt; 0 { 41	a *= -1 42	} 43	return a 44} </description>
    </item>
    
    <item>
      <title>0051.n-queens</title>
      <link>https://wncbb.github.io/posts/leetcode/0051.n-queens/</link>
      <pubDate>Thu, 10 Dec 2020 15:34:43 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/0051.n-queens/</guid>
      <description>1func solveNQueens(n int) [][]string { 2	rst := make([][]string, 0) 3	4	// initialize chess 5	chess := make([][]byte, 0, n) 6	for i := 0; i &amp;lt; n; i++ { 7	chess = append(chess, getLine(n)) 8	} 9 10	var bs func(row int) 11	bs = func(row int) { 12	if row == n { 13	rst = append(rst, getRst(chess)) 14	return 15	} 16	for col := 0; col &amp;lt; n; col++ { 17	// if location with row and col can not add a Q 18	// then just continue 19	if !</description>
    </item>
    
    <item>
      <title>0056.merge-intervals</title>
      <link>https://wncbb.github.io/posts/leetcode/0056.merge-intervals/</link>
      <pubDate>Thu, 10 Dec 2020 13:44:21 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/0056.merge-intervals/</guid>
      <description>1func merge(intervals [][]int) [][]int { 2	if len(intervals) == 0 { 3	return [][]int{} 4	} 5	if len(intervals) == 1 { 6	return intervals 7	} 8	// need to sort by the start value 9	sort.Slice(intervals, func(i, j int) bool { 10	return intervals[i][0] &amp;lt; intervals[j][0] 11	}) 12	rst := make([][]int, 0) 13	cur := intervals[0] 14	for i := 1; i &amp;lt; len(intervals); i++ { 15	if intervals[i][0] &amp;lt;= cur[1] { 16	// cur = [1, 3] intervals[i]=[2, 5] 17	// 对于这种，需要合并，合并后开始还是cur[0], cur[1]=两个结束值的最大值 18	cur[1] = getMaxInt(cur[1], intervals[i][1]) 19	} else { 20	// cur = [1, 3] intervals[i]=[4, 5] 21	rst = append(rst, cur) 22	cur = intervals[i] 23	} 24	} 25 26	rst = append(rst, cur) 27	return rst 28 29} 30 31func getMaxInt(a, b int) int { 32	if a &amp;gt; b { 33	return a 34	} 35	return b 36} </description>
    </item>
    
    <item>
      <title>0047.permutations_II</title>
      <link>https://wncbb.github.io/posts/leetcode/0047.permutations-ii/</link>
      <pubDate>Thu, 10 Dec 2020 13:31:12 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/0047.permutations-ii/</guid>
      <description>1func permuteUnique(s []int) [][]int { 2 // need to sort the s first, so it&amp;#39;s easy for us to skip the duplicated value 3	sort.Ints(s) 4	rst := make([][]int, 0) 5	visited := make([]bool, len(s), len(s)) 6 7	var bs func(idx int, cur []int) 8 9	bs = func(idx int, cur []int) { 10	if idx == len(s) { 11	curRst := make([]int, len(cur), len(cur)) 12	copy(curRst, cur) 13	rst = append(rst, curRst) 14	return 15	} 16 17	for i := 0; i &amp;lt; len(s); i++ { 18	if visited[i] { 19	continue 20	} 21	// s[i]==s[i-1] means the value with last idx equals current value 22	// 23	// i-1 is in front of i 24	// so i-1 must have been handled before i 25	// and visited[i-1]==false means the result of this value has been added to rst 26	// then deleting i-1 from current result and hanlde i 27	if i &amp;gt; 0 &amp;amp;&amp;amp; s[i] == s[i-1] &amp;amp;&amp;amp; !</description>
    </item>
    
    <item>
      <title>0046.permutations</title>
      <link>https://wncbb.github.io/posts/leetcode/0046.permutations/</link>
      <pubDate>Thu, 10 Dec 2020 13:21:18 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/0046.permutations/</guid>
      <description>1func permute(s []int) [][]int { 2	rst := make([][]int, 0) 3	// to judge if the value of this index has been visited 4	visited := make([]bool, len(s), len(s)) 5 6	var bs func(idx int, cur []int) 7 8	bs = func(idx int, cur []int) { 9	// satisfied 10	if idx == len(s) { 11	curRst := make([]int, len(cur), len(cur)) 12	copy(curRst, cur) 13	rst = append(rst, curRst) 14	return 15	} 16 17	for i := 0; i &amp;lt; len(s); i++ { 18	if visited[i] { 19	continue 20	} 21 22 // visit the value with index i 23	visited[i] = true 24	cur = append(cur, s[i]) 25	26	bs(idx+1, cur) 27	28	// restore the context 29	visited[i] = false 30	cur = cur[:len(cur)-1] 31	} 32	} 33	34	// initialize the state 35	bs(0, make([]int, 0, len(s))) 36	return rst 37} </description>
    </item>
    
    <item>
      <title>0084.largest-rectangle-in-histogram</title>
      <link>https://wncbb.github.io/posts/leetcode/0084.largest-rectangle-in-histogram/</link>
      <pubDate>Sun, 23 Aug 2020 18:14:56 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/0084.largest-rectangle-in-histogram/</guid>
      <description>https://leetcode-cn.com/problems/largest-rectangle-in-histogram/
单调栈
1func largestRectangleArea(heights []int) int { 2	h:=make([]int, 0, len(heights)+2) 3	h=append(h, 0) 4	h=append(h, heights...) 5	h=append(h, 0) 6	// stack里存储的是单调递增的索引 7	stack:=make([]int, 0) 8	res:=0 9 10 // 遍历的是h，not heights 11	for i, v:=range h{ 12	for len(stack)!=0 &amp;amp;&amp;amp; h[stack[len(stack)-1]]&amp;gt;v{ 13	// 如果当前的值小于栈顶位置的元素，说明可以计算栈顶位置元素的矩形面积 14	t:=stack[len(stack)-1] 15	stack=stack[:len(stack)-1] 16	// 出栈之后，栈顶位置的元素为小于t位置的索引 17	left:=stack[len(stack)-1] 18	right:=i 19	// left是小于t的最左侧，right是小于t的最右侧, 1xxx5, 比如计算xxx的长度,5-1=4,需要再减一个1 20	res=getMaxInt(res, (right-left-1)*h[t]) 21	} 22	stack=append(stack, i) 23	} 24 25	return res 26} 27 28func getMaxInt(a, b int)int{ 29	if a&amp;gt;b{ 30	return a 31	} 32	return b 33} </description>
    </item>
    
  </channel>
</rss>