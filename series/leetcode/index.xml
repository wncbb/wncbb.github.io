<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>leetcode on WNCBB&#39;s blog</title>
    <link>https://wncbb.github.io/series/leetcode/</link>
    <description>Recent content in leetcode on WNCBB&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 30 Dec 2020 17:26:31 +0800</lastBuildDate>
    
	<atom:link href="https://wncbb.github.io/series/leetcode/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>0718.maximum-length-of-repeated-subarray</title>
      <link>https://wncbb.github.io/posts/leetcode/0718.maximum-length-of-repeated-subarray/</link>
      <pubDate>Wed, 30 Dec 2020 17:26:31 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/0718.maximum-length-of-repeated-subarray/</guid>
      <description>两个数组的 最长子数组 子序列：不一定连续 子数组：一定连续  1func findLength(A []int, B []int) int { 2	if len(A) == 0 || len(B) == 0 { 3	return 0 4	} 5	6 // dp[i][j]表示以A[i] B[j]结尾的相同子数组的长度 7	dp := make([][]int, 0, len(A)) 8	for i := 0; i &amp;lt; len(A); i++ { 9	dp = append(dp, make([]int, len(B), len(B))) 10	} 11 12 // 为了避免i=0, j=0, 此时0-1=-1，索引非法的问题，先初始化0的情况 13	for i := 0; i &amp;lt; len(A); i++ { 14	if A[i] == B[0] { 15	dp[i][0] = 1 16	} 17	} 18	for j := 0; j &amp;lt; len(B); j++ { 19	if A[0] == B[j] { 20	dp[0][j] = 1 21	} 22	} 23 24	ret := 0 25 26	for i := 1; i &amp;lt; len(A); i++ { 27	for j := 1; j &amp;lt; len(B); j++ { 28	if A[i] == B[j] { 29	dp[i][j] = dp[i-1][j-1] + 1 30	if ret &amp;lt; dp[i][j] { 31	ret = dp[i][j] 32	} 33	} 34	} 35	} 36 37	return ret 38} 或者数组多一位  1func findLength(A []int, B []int) int { 2	if len(A) == 0 || len(B) == 0 { 3	return 0 4	} 5 6	dp := make([][]int, 0, len(A)+1) 7	for i := 0; i &amp;lt; len(A)+1; i++ { 8	dp = append(dp, make([]int, len(B)+1, len(B)+1)) 9	} 10 11	ret := 0 12 13	for i := 1; i &amp;lt;= len(A); i++ { 14	for j := 1; j &amp;lt;= len(B); j++ { 15	if A[i-1] == B[j-1] { 16	dp[i][j] = dp[i-1][j-1] + 1 17	if ret &amp;lt; dp[i][j] { 18	ret = dp[i][j] 19	} 20	} 21	} 22	} 23 24	return ret 25} 26``` </description>
    </item>
    
    <item>
      <title>1206.design-skiplist</title>
      <link>https://wncbb.github.io/posts/leetcode/1206.design-skiplist/</link>
      <pubDate>Wed, 30 Dec 2020 16:37:20 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/1206.design-skiplist/</guid>
      <description>1import ( 2	&amp;#34;math/rand&amp;#34; 3) 4 5const ( 6	maxLevel = 16 7	skipListPVal = 0.5 8) 9 10// randomLevel 返回一个Next数组的高度, 高度不能超过最大值 11func randomLevel() int { 12	retLevel := 1 13	for retLevel &amp;lt; maxLevel &amp;amp;&amp;amp; rand.Float32() &amp;lt; skipListPVal { 14	retLevel++ 15	} 16	return retLevel 17} 18 19type Node struct { 20	Val int 21	Next [maxLevel]*Node 22} 23 24func NewNode(val int, next [maxLevel]*Node) *Node { 25	return &amp;amp;Node{ 26	Val: val, 27	Next: next, 28	} 29} 30 31type Skiplist struct { 32	head *Node 33	maxLevel int 34} 35 36func Constructor() Skiplist { 37	return Skiplist{ 38	// head 里的值是最小值,这里取-1 39	head: NewNode(-1, [maxLevel]*Node{}), 40	maxLevel: 1, 41	} 42} 43 44func (this *Skiplist) search(target int) [maxLevel]*Node { 45	cur := this.</description>
    </item>
    
    <item>
      <title>0032.longest-valid-parentheses</title>
      <link>https://wncbb.github.io/posts/leetcode/0032.longest-valid-parentheses/</link>
      <pubDate>Tue, 22 Dec 2020 16:27:41 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/0032.longest-valid-parentheses/</guid>
      <description>1func longestValidParentheses(s string) int { 2	rst := 0 3 // dp[i] 表示以s[i]字符结尾的最长的合法的括号长度 4	dp := make([]int, len(s), len(s)) 5	for i := 1; i &amp;lt; len(s); i++ { 6	curByte := s[i] 7 // 如果s[i]是左括号，那么以左括号为结尾的字符串，一定不是合法的，长度就是0 8	if curByte == &amp;#39;(&amp;#39; { 9	continue 10	} 11 // 如果s[i]是右括号，比如这种 ?()) 12 // 就需要看一下，s[i-1]结尾的合法字符串的前一个是不是左括号， 13 // 如果是，需要加2（一个是当前的右括号，一个是dp[i-1]之前的左括号) 14	leftIdx := i - dp[i-1] - 1 15	if leftIdx &amp;gt;= 0 &amp;amp;&amp;amp; s[leftIdx] == &amp;#39;(&amp;#39; { 16	dp[i] = dp[i-1] + 2 17	leftLeftIdx := i - dp[i-1] - 2 18 // 这里还需要加上dp[i-1]之前的合法字符串的长度 19 // 对应这种情况: ()(()) 20 // 这里只需要看一次就行，因为如果前面还有的话，一定包含在dp[i-dp[i-1]-2]里了 21	if leftLeftIdx &amp;gt;= 0 { 22	dp[i] += dp[leftLeftIdx] 23	} 24	} 25	if rst &amp;lt; dp[i] { 26	rst = dp[i] 27	} 28 29	} 30	return rst 31} </description>
    </item>
    
    <item>
      <title>0030.substring-with-concatenation-of-all-words</title>
      <link>https://wncbb.github.io/posts/leetcode/0030.substring-with-concatenation-of-all-words/</link>
      <pubDate>Fri, 18 Dec 2020 19:56:59 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/0030.substring-with-concatenation-of-all-words/</guid>
      <description>有点暴力的解法，就是遍历所有可能的窗口  1func findSubstring(s string, words []string) []int { 2	//生命返回值 3	var result []int 4 5	//判断 6	if len(s) == 0 || len(words) == 0 { 7	return result 8	} 9 10 11	//获取单词长度 12	l := len(words[0]) 13 14	//获取滑动窗口总长度 15	length := l * len(words) 16 17	//判断 18	if length &amp;gt; len(s) { 19	return result 20	} 21 22	//构造map 23	mp := make(map[string]int) 24 25	//统计 26	for _,v := range words { 27	mp[v] += 1 28	} 29 30	//开始遍历 31	for i := 0; i &amp;lt;= (len(s) - length);i++ { 32	//判断i开始length位置 33	tmpMap := map[string]int{} 34 35	//定义标志 36	fg := true 37 38	for j := i; j &amp;lt; i + length; j += l { 39	str := string(s[j: j + l]) 40	if mp[str] &amp;lt;= 0 { 41 // 这里还没减少，也就是说，必须当前的单词str是需要的，且mp里个数还充足 42	fg = false 43	break 44	} else { 45	mp[str] -- 46	tmpMap[str] ++ 47	} 48 49	} 50 51	//判断标志 52	if fg == true{ 53	result = append(result,i) 54	} 55	56	//回复mp 57	for k,v := range tmpMap { 58	mp[k] += v 59	} 60 61	} 62	//返回 63	return result 64 65} </description>
    </item>
    
    <item>
      <title>0336.palindrome-pairs</title>
      <link>https://wncbb.github.io/posts/leetcode/0336.palindrome-pairs/</link>
      <pubDate>Fri, 18 Dec 2020 19:36:38 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/0336.palindrome-pairs/</guid>
      <description>1func palindromePairs(words []string) [][]int { 2	m := make(map[string]int, len(words)) 3	for idx, v := range words { 4	m[v] = idx 5	} 6 7	res := make([][]int, 0) 8 9	for idx, v := range words { 10	// 如果非空字符串v是回文串，且字符数组中包含空字符串，那么 v+&amp;#34;&amp;#34; 与 &amp;#34;&amp;#34;+v 都是回文串 11	if emptyStrIdx, ok := m[&amp;#34;&amp;#34;]; ok &amp;amp;&amp;amp; isPalindrome(v) &amp;amp;&amp;amp; v != &amp;#34;&amp;#34; { 12	res = append(res, []int{emptyStrIdx, idx}) 13	res = append(res, []int{idx, emptyStrIdx}) 14	} 15	// v的逆序字符串存在的话，那么这俩一拼也是回文串，注意这里只加一次( 16	// 比如A的逆序是B, 遍历到A的话，加入A,B; 17	// 遍历到B的时候，加入B,A，就不会重复 18	// ) 19 // 其实v !</description>
    </item>
    
    <item>
      <title>0010.regular-expression-matching</title>
      <link>https://wncbb.github.io/posts/leetcode/0010.regular-expression-matching/</link>
      <pubDate>Thu, 17 Dec 2020 17:22:10 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/0010.regular-expression-matching/</guid>
      <description>1func isMatch(s string, p string) bool { 2 // sBytes := []byte(s) 3 // pBytes := []byte(p) 4 // dp[i][j]表示s[:i+1] p[:j+1]是否匹配 5 dp := make([][]bool, 0, len(s)+1) 6 for i := 0; i &amp;lt; len(s)+1; i++ { 7 dp = append(dp, make([]bool, len(p)+1)) 8 } 9 // s跟p都是空字符，肯定匹配的上 10 dp[0][0] = true 11 for i := 1; i &amp;lt; len(p); i++ { 12 // 如果当前p[i]是*，那么*可以把前面的字符搞没 13 // 比如 &amp;#34;b*a*&amp;#34; 跟 &amp;#34;&amp;#34;比较，a*可以去掉，那么就变成&amp;#34;b*&amp;#34;跟&amp;#34;&amp;#34;比较 14 if p[i] == &amp;#39;*&amp;#39; { 15 dp[0][i+1] = dp[0][i-1] 16 } 17 } 18 19	for i, sByte := range s { 20	for j, pByte := range p { 21	switch { 22	case sByte == pByte: 23 // 最简单的case，俩字符一样，那么前面的如果匹配，这个一定匹配 24	dp[i+1][j+1] = dp[i+1][j+1] || dp[i][j] 25	case pByte == &amp;#39;.</description>
    </item>
    
    <item>
      <title>0076.minimum-window-substring</title>
      <link>https://wncbb.github.io/posts/leetcode/0076.minimum-window-substring/</link>
      <pubDate>Mon, 14 Dec 2020 16:47:32 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/0076.minimum-window-substring/</guid>
      <description>滑动窗口逻辑： 声明俩变量left right初始化为0 1. 右边界往右遍历，符合条件后， 2. 左边界往右遍历，直到不符合条件，再跳到1 期间符合条件时，更新下当前的最优解  1func minWindow(s string, t string) string { 2	retLeft := 0 3	retRight := len(s) + 100 4	left := 0 5	right := 0 6	// 记录t中，byte到个数的map 7	visited := make(map[byte]int) 8	// 实时记录，当前left到right之间的t中字符，byte到个数的映射 9	curVisited := make(map[byte]int) 10	curFitNum := 0 11	tBytes := []byte(t) 12	for _, v := range tBytes { 13	visited[v] += 1 14	} 15	for _, v := range tBytes { 16	curVisited[v] = 0 17	} 18	// t中unique的字符个数 19	fitNum := len(visited) 20	for right &amp;lt; len(s) { 21	// 遍历右边，并处理curVisited, curFitNum等中间记录当前状态的变量 22	curRightByte := s[right] 23	if _, ok := curVisited[curRightByte]; ok { 24	curVisited[curRightByte]++ 25	if curVisited[curRightByte] == visited[curRightByte] { 26	curFitNum++ 27	} 28	} 29	right++ 30 31	for left &amp;lt;= right &amp;amp;&amp;amp; curFitNum == fitNum { 32	// 当left在合法范围内，且当前符合条件时 33	// 检查下是否更新返回值 34	if right-left &amp;lt; retRight-retLeft { 35	retRight = right 36	retLeft = left 37	} 38 39 // 去掉left的字符后，处理curVisited, curFitNum等中间记录当前状态的变量 40	curLeftByte := s[left] 41	if v, ok := curVisited[curLeftByte]; ok { 42	if v == visited[curLeftByte] { 43	curFitNum-- 44	} 45	curVisited[curLeftByte]-- 46 47	} 48	left++ 49	} 50	} 51	if retRight &amp;gt; len(s) { 52	return &amp;#34;&amp;#34; 53	} 54	return s[retLeft:retRight] 55} </description>
    </item>
    
    <item>
      <title>0042.rapping-rain-water</title>
      <link>https://wncbb.github.io/posts/leetcode/0042.trapping-rain-water/</link>
      <pubDate>Thu, 10 Dec 2020 19:03:01 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/0042.trapping-rain-water/</guid>
      <description>1func trap(height []int) int { 2	rst := 0 3	stack := make([]int, 0) 4	for i := 0; i &amp;lt; len(height); i++ { 5	for !stackIsEmpty(stack) &amp;amp;&amp;amp; height[stackPeek(stack)] &amp;lt; height[i] { 6	// height = [3, 2, 1, 0] 7	// stack= index(value) 0(3) 1(2) 2(1) 3(0) height[i]=4 8	// 这个时候，处理对象是stack里的3(0)，3(0)的左边比他高的最近的是2，3(0)的右边比他高的最近的是i(4) 9	var curIdx int 10	stack, curIdx = stackPop(stack) 11	if !stackIsEmpty(stack) { 12	rst = rst + (i-stackPeek(stack)-1)*(getMin(height[stackPeek(stack)], height[i])-height[curIdx]) 13	} 14	} 15	// 当前元素无论如何会入栈 16	stack = stackPush(stack, i) 17	} 18	return rst 19} 20func stackPush(stack []int, v int) []int { 21	stack = append(stack, v) 22	return stack 23} 24 25func stackIsEmpty(stack []int) bool { 26	return len(stack) == 0 27} 28 29func stackPeek(stack []int) int { 30	if stackIsEmpty(stack) { 31	return 0 32	} 33	return stack[len(stack)-1] 34} 35 36func stackPop(stack []int) ([]int, int) { 37	if stackIsEmpty(stack) { 38	return stack, 0 39	} 40	rst := stack[len(stack)-1] 41	stack = stack[:len(stack)-1] 42	return stack, rst 43} 44 45func getMin(a, b int) int { 46	if a &amp;lt; b { 47	return a 48	} 49	return b 50} </description>
    </item>
    
    <item>
      <title>0053.maximum-subarra</title>
      <link>https://wncbb.github.io/posts/leetcode/0053.maximum-subarra/</link>
      <pubDate>Thu, 10 Dec 2020 16:33:51 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/0053.maximum-subarra/</guid>
      <description>1func maxSubArray(nums []int) int { 2	if len(nums) == 0 { 3	return 0 4	} 5	// dp[i]表示以i结尾的和 6	dp := make([]int, len(nums), len(nums)) 7	dp[0] = nums[0] 8	rst := nums[0] 9	for i := 1; i &amp;lt; len(nums); i++ { 10	// 对于以i结尾的连续数组，要么就他自己，要么他自己加上以i-1为结尾的最大值 11	dp[i] = max(nums[i], nums[i]+dp[i-1]) 12	if dp[i] &amp;gt; rst { 13	rst = dp[i] 14	} 15	} 16 17	return rst 18} 19 20func max(a, b int) int { 21	if a &amp;gt; b { 22	return a 23	} 24	return b 25} </description>
    </item>
    
    <item>
      <title>0041.first-missing-positive</title>
      <link>https://wncbb.github.io/posts/leetcode/0041.first-missing-positive/</link>
      <pubDate>Thu, 10 Dec 2020 16:17:11 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/0041.first-missing-positive/</guid>
      <description>1func firstMissingPositive(nums []int) int { 2	for i, _ := range nums { 3	if nums[i] &amp;lt;= 0 { 4	nums[i] = len(nums) + 1 5	} 6	} 7	8	for i, _ := range nums { 9	// abs(nums[i]) 10	// is for 3, 4, -1, 1 11	// otherwise 12	// after checking negative, would be 3, 4, 5, 1 13	// after this lookp, would be 3, 4, -5, -1 14	// then 1 would be returned 15	// the reason is that the last value 1 is set to negative 16	// so we need to ignore negative, just use abs value 17	cur := abs(nums[i]) 18	// nums[cur-1] &amp;gt; 0 19	// is for 1, 1 20	// otherwise 21	// after checking ne4tative, would be 1, 1 22	// after this lookup, would be -1, 1, then 1, 1 23	// the zero index was set two times, and -1*-1=1 24	// so for one index, we only need to set one time 25	if cur &amp;gt; 0 &amp;amp;&amp;amp; cur &amp;lt; len(nums)+1 &amp;amp;&amp;amp; nums[cur-1] &amp;gt; 0 { 26	nums[cur-1] *= -1 27	} 28	} 29 30	for i, _ := range nums { 31	if nums[i] &amp;gt; 0 { 32	return i + 1 33	} 34	} 35 36	return len(nums) + 1 37} 38 39func abs(a int) int { 40	if a &amp;lt; 0 { 41	a *= -1 42	} 43	return a 44} </description>
    </item>
    
    <item>
      <title>0051.n-queens</title>
      <link>https://wncbb.github.io/posts/leetcode/0051.n-queens/</link>
      <pubDate>Thu, 10 Dec 2020 15:34:43 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/0051.n-queens/</guid>
      <description>1func solveNQueens(n int) [][]string { 2	rst := make([][]string, 0) 3	4	// initialize chess 5	chess := make([][]byte, 0, n) 6	for i := 0; i &amp;lt; n; i++ { 7	chess = append(chess, getLine(n)) 8	} 9 10	var bs func(row int) 11	bs = func(row int) { 12	if row == n { 13	rst = append(rst, getRst(chess)) 14	return 15	} 16	for col := 0; col &amp;lt; n; col++ { 17	// if location with row and col can not add a Q 18	// then just continue 19	if !</description>
    </item>
    
    <item>
      <title>0056.merge-intervals</title>
      <link>https://wncbb.github.io/posts/leetcode/0056.merge-intervals/</link>
      <pubDate>Thu, 10 Dec 2020 13:44:21 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/0056.merge-intervals/</guid>
      <description>1func merge(intervals [][]int) [][]int { 2	if len(intervals) == 0 { 3	return [][]int{} 4	} 5	if len(intervals) == 1 { 6	return intervals 7	} 8	// need to sort by the start value 9	sort.Slice(intervals, func(i, j int) bool { 10	return intervals[i][0] &amp;lt; intervals[j][0] 11	}) 12	rst := make([][]int, 0) 13	cur := intervals[0] 14	for i := 1; i &amp;lt; len(intervals); i++ { 15	if intervals[i][0] &amp;lt;= cur[1] { 16	// cur = [1, 3] intervals[i]=[2, 5] 17	// 对于这种，需要合并，合并后开始还是cur[0], cur[1]=两个结束值的最大值 18	cur[1] = getMaxInt(cur[1], intervals[i][1]) 19	} else { 20	// cur = [1, 3] intervals[i]=[4, 5] 21	rst = append(rst, cur) 22	cur = intervals[i] 23	} 24	} 25 26	rst = append(rst, cur) 27	return rst 28 29} 30 31func getMaxInt(a, b int) int { 32	if a &amp;gt; b { 33	return a 34	} 35	return b 36} </description>
    </item>
    
    <item>
      <title>0047.permutations_II</title>
      <link>https://wncbb.github.io/posts/leetcode/0047.permutations-ii/</link>
      <pubDate>Thu, 10 Dec 2020 13:31:12 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/0047.permutations-ii/</guid>
      <description>1func permuteUnique(s []int) [][]int { 2 // need to sort the s first, so it&amp;#39;s easy for us to skip the duplicated value 3	sort.Ints(s) 4	rst := make([][]int, 0) 5	visited := make([]bool, len(s), len(s)) 6 7	var bs func(idx int, cur []int) 8 9	bs = func(idx int, cur []int) { 10	if idx == len(s) { 11	curRst := make([]int, len(cur), len(cur)) 12	copy(curRst, cur) 13	rst = append(rst, curRst) 14	return 15	} 16 17	for i := 0; i &amp;lt; len(s); i++ { 18	if visited[i] { 19	continue 20	} 21	// s[i]==s[i-1] means the value with last idx equals current value 22	// 23	// i-1 is in front of i 24	// so i-1 must have been handled before i 25	// and visited[i-1]==false means the result of this value has been added to rst 26	// then deleting i-1 from current result and hanlde i 27	if i &amp;gt; 0 &amp;amp;&amp;amp; s[i] == s[i-1] &amp;amp;&amp;amp; !</description>
    </item>
    
    <item>
      <title>0046.permutations</title>
      <link>https://wncbb.github.io/posts/leetcode/0046.permutations/</link>
      <pubDate>Thu, 10 Dec 2020 13:21:18 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/0046.permutations/</guid>
      <description>1func permute(s []int) [][]int { 2	rst := make([][]int, 0) 3	// to judge if the value of this index has been visited 4	visited := make([]bool, len(s), len(s)) 5 6	var bs func(idx int, cur []int) 7 8	bs = func(idx int, cur []int) { 9	// satisfied 10	if idx == len(s) { 11	curRst := make([]int, len(cur), len(cur)) 12	copy(curRst, cur) 13	rst = append(rst, curRst) 14	return 15	} 16 17	for i := 0; i &amp;lt; len(s); i++ { 18	if visited[i] { 19	continue 20	} 21 22 // visit the value with index i 23	visited[i] = true 24	cur = append(cur, s[i]) 25	26	bs(idx+1, cur) 27	28	// restore the context 29	visited[i] = false 30	cur = cur[:len(cur)-1] 31	} 32	} 33	34	// initialize the state 35	bs(0, make([]int, 0, len(s))) 36	return rst 37} </description>
    </item>
    
    <item>
      <title>0084.largest-rectangle-in-histogram</title>
      <link>https://wncbb.github.io/posts/leetcode/0084.largest-rectangle-in-histogram/</link>
      <pubDate>Sun, 23 Aug 2020 18:14:56 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/0084.largest-rectangle-in-histogram/</guid>
      <description>https://leetcode-cn.com/problems/largest-rectangle-in-histogram/
单调栈
1func largestRectangleArea(heights []int) int { 2	h:=make([]int, 0, len(heights)+2) 3	h=append(h, 0) 4	h=append(h, heights...) 5	h=append(h, 0) 6	// stack里存储的是单调递增的索引 7	stack:=make([]int, 0) 8	res:=0 9 10 // 遍历的是h，not heights 11	for i, v:=range h{ 12	for len(stack)!=0 &amp;amp;&amp;amp; h[stack[len(stack)-1]]&amp;gt;v{ 13	// 如果当前的值小于栈顶位置的元素，说明可以计算栈顶位置元素的矩形面积 14	t:=stack[len(stack)-1] 15	stack=stack[:len(stack)-1] 16	// 出栈之后，栈顶位置的元素为小于t位置的索引 17	left:=stack[len(stack)-1] 18	right:=i 19	// left是小于t的最左侧，right是小于t的最右侧, 1xxx5, 比如计算xxx的长度,5-1=4,需要再减一个1 20	res=getMaxInt(res, (right-left-1)*h[t]) 21	} 22	stack=append(stack, i) 23	} 24 25	return res 26} 27 28func getMaxInt(a, b int)int{ 29	if a&amp;gt;b{ 30	return a 31	} 32	return b 33} </description>
    </item>
    
  </channel>
</rss>