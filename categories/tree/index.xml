<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>tree on WNCBB&#39;s blog</title>
    <link>https://wncbb.github.io/categories/tree/</link>
    <description>Recent content in tree on WNCBB&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 26 Feb 2021 15:37:56 +0800</lastBuildDate>
    
	<atom:link href="https://wncbb.github.io/categories/tree/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>0105.construct-binary-tree-from-preorder-and-inorder-traversal</title>
      <link>https://wncbb.github.io/posts/leetcode/0105.construct-binary-tree-from-preorder-and-inorder-traversal/</link>
      <pubDate>Fri, 26 Feb 2021 15:37:56 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/0105.construct-binary-tree-from-preorder-and-inorder-traversal/</guid>
      <description>/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func buildTree(preorder []int, inorder []int) *TreeNode { if len(preorder)==0{ return nil } curNode:=&amp;amp;TreeNode{ Val: preorder[0], } rootValIdxInInorder:=0 for idx, v:=range inorder{ if v==preorder[0]{ rootValIdxInInorder=idx break } } // 难在构建左子树、右子树函数的参数 // preorder: root A B // inorder: A root B // 所以找到A与B在preorder/inorder里的起始位置，再将A/B part作为参数即可 curNode.Left=buildTree(preorder[1:len(inorder[:rootValIdxInInorder])+1], inorder[:rootValIdxInInorder]) curNode.Right=buildTree(preorder[len(inorder[:rootValIdxInInorder])+1:], inorder[rootValIdxInInorder+1:]) return curNode }  </description>
    </item>
    
    <item>
      <title>0103.binary-tree-zigzag-level-order-traversal</title>
      <link>https://wncbb.github.io/posts/leetcode/0103.binary-tree-zigzag-level-order-traversal/</link>
      <pubDate>Fri, 26 Feb 2021 15:22:21 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/0103.binary-tree-zigzag-level-order-traversal/</guid>
      <description>/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func zigzagLevelOrder(root *TreeNode) [][]int { if root==nil{ return nil } ret:=make([][]int, 0) nextQ:=make([]*TreeNode, 0) nextQ=append(nextQ, root) level:=0 for len(nextQ)!=0{ curQ:=nextQ nextQ=make([]*TreeNode, 0) curVals:=make([]int, 0, len(curQ)) for i:=0; i&amp;lt;len(curQ); i++{ curNode:=curQ[i] if curNode.Left!=nil{ nextQ=append(nextQ, curNode.Left) } if curNode.Right!=nil{ nextQ=append(nextQ, curNode.Right) } curVals=append(curVals, curNode.Val) } // 为了简单，直接根据层数的奇偶来做倒置 if level%2==1{ for i:=0; i&amp;lt;len(curVals)/2; i++{ curVals[i], curVals[len(curVals)-i-1]=curVals[len(curVals)-i-1], curVals[i] } } ret=append(ret, curVals) level++ } return ret }  </description>
    </item>
    
    <item>
      <title>0124.binary-tree-maximum-path-sum</title>
      <link>https://wncbb.github.io/posts/leetcode/0124.binary-tree-maximum-path-sum/</link>
      <pubDate>Fri, 26 Feb 2021 14:58:35 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/0124.binary-tree-maximum-path-sum/</guid>
      <description>```go /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ var ret int var retIsSet bool func maxPathSum(root *TreeNode) int { ret=0 retIsSet=false
helper(root) return ret  }
// 获得一定包含root，且以root为起点，且单边(左子树或右子树路径上单链，当然可以只包含root，比如root的下面的节点都是负数，就可以只包含root)的最大值 func helper(root *TreeNode) int { if root==nil{ return 0 }
// 如果helper(root.Left)为负数，还不如不包含后面的节点，直接设置为0 left:=getMax(0, helper(root.Left)) right:=getMax(0, helper(root.Right)) // 以root为最高层节点，的结果的最优值，只要遍历所有节点的最优值，且取最大值，即得到结果 curVal:=left+right+root.Val if retIsSet{ ret=getMax(ret, curVal) }else{ retIsSet=true ret=curVal } if left&amp;gt;right{ return left+root.</description>
    </item>
    
    <item>
      <title>0199.binary-tree-right-side-view</title>
      <link>https://wncbb.github.io/posts/leetcode/0199.binary_tree_right_side_view/</link>
      <pubDate>Fri, 26 Feb 2021 14:55:03 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/0199.binary_tree_right_side_view/</guid>
      <description>需要区分二叉树的这一层下一层，准备俩queue，一个当前处理的curQ， 一个q存放从curQ里出来的node的孩子节点 然后curQ=q; q=nil 继续下一次循环
/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func rightSideView(root *TreeNode) []int { if root==nil{ return nil } ret:=make([]int, 0) q:=make([]*TreeNode, 0) q=append(q, root) for len(q)!=0{ curRst:=0 curQ:=q q=nil for i:=0; i&amp;lt;len(curQ); i++{ curNode:=curQ[i] curRst=curNode.Val if curNode.Left!=nil{ q=append(q, curNode.Left) } if curNode.Right!=nil{ q=append(q, curNode.Right) } } ret=append(ret, curRst) } return ret }  </description>
    </item>
    
  </channel>
</rss>