<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on WNCBB&#39;s blog</title>
    <link>https://wncbb.github.io/posts/</link>
    <description>Recent content in Posts on WNCBB&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 09 Mar 2021 23:17:58 +0800</lastBuildDate>
    
	<atom:link href="https://wncbb.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>0019</title>
      <link>https://wncbb.github.io/posts/leetcode/0019.remove-nth-node-from-end-of-list/</link>
      <pubDate>Tue, 09 Mar 2021 23:17:58 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/0019.remove-nth-node-from-end-of-list/</guid>
      <description></description>
    </item>
    
    <item>
      <title>0033</title>
      <link>https://wncbb.github.io/posts/leetcode/0033.search-in-rotated-sorted-array/</link>
      <pubDate>Sun, 07 Mar 2021 14:15:20 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/0033.search-in-rotated-sorted-array/</guid>
      <description>func search(nums []int, target int) int { left:=0 right:=len(nums)-1 for left&amp;lt;=right{ mid:=(left+right)/2 if nums[mid]==target{ return mid } // 分为两种情况，要么左边是有序的(左半边，最左侧数据&amp;lt;=最右侧数据)，要是是右边 if nums[left]&amp;lt;=nums[mid]{ // 在左侧数据里，既然是有序的，如果target在左侧左右边界里，那么right=mid // 否则就不在左侧，那么left=mid+1 if nums[left]&amp;lt;=target &amp;amp;&amp;amp; target&amp;lt;=nums[mid]{ right=mid }else{ left=mid+1 } }else{ if nums[mid+1]&amp;lt;=target &amp;amp;&amp;amp; target&amp;lt;=nums[right]{ left=mid+1 }else{ right=mid } } } return -1 }  </description>
    </item>
    
    <item>
      <title>0005</title>
      <link>https://wncbb.github.io/posts/leetcode/0005.longest-palindromic-substring/</link>
      <pubDate>Sat, 06 Mar 2021 22:30:31 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/0005.longest-palindromic-substring/</guid>
      <description>func longestPalindrome(s string) string { start:=0 end:=0 sBytes:=[]byte(s) dp:=make([][]bool, 0, len(sBytes)) for i:=0; i&amp;lt;len(sBytes); i++{ dp=append(dp, make([]bool, len(sBytes), len(sBytes))) } for l:=0; l&amp;lt;len(sBytes); l++{ for i:=0; i+l&amp;lt;len(sBytes); i++{ j:=i+l if l==0{ dp[i][j]=true }else if l==1{ if sBytes[i]==sBytes[j]{ dp[i][j]=true } }else{ if sBytes[i]==sBytes[j]{ dp[i][j]=dp[i+1][j-1] } } if dp[i][j] &amp;amp;&amp;amp; end-start&amp;lt;j-i{ end=j start=i } } } return string(sBytes[start:end+1]) }  </description>
    </item>
    
    <item>
      <title>0015.3sum</title>
      <link>https://wncbb.github.io/posts/leetcode/0015.3sum/</link>
      <pubDate>Sat, 06 Mar 2021 22:28:39 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/0015.3sum/</guid>
      <description>import( &amp;quot;sort&amp;quot; ) func threeSum(nums []int) [][]int { sort.Ints(nums) res:=make([][]int, 0) if len(nums)&amp;lt;=2{ return res } for i:=0; i&amp;lt;len(nums)-2; i++{ // 这里不会存在，0， 0， 0， 0，结果没有数据的原因，是 // i&amp;lt;len(nums)-2, i不会从0走到len(nums)-1 if i&amp;gt;0 &amp;amp;&amp;amp; nums[i]==nums[i-1] { continue } left:=i+1 right:=len(nums)-1 target:=-1*nums[i] for left&amp;lt;right{ if nums[left]+nums[right]==target{ res=append(res, []int{nums[i], nums[left], nums[right]}) // 有结果之后要去重， 没有结果的时候不能去重，比如0， 0， 0， 0...因为都一样，直接去重就都没了 for left&amp;lt;right &amp;amp;&amp;amp; nums[left]==nums[left+1]{ left++ } for left&amp;lt;right &amp;amp;&amp;amp; nums[right]==nums[right-1]{ right-- } left++ right-- }else if nums[left]+nums[right]&amp;lt;target{ left++ }else{ right-- } } } return res }  </description>
    </item>
    
    <item>
      <title>0031</title>
      <link>https://wncbb.github.io/posts/leetcode/0031.next-permutation/</link>
      <pubDate>Sat, 06 Mar 2021 21:43:31 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/0031.next-permutation/</guid>
      <description>func nextPermutation(nums []int) { if len(nums)&amp;lt;=1{ return } /* 举个例子： 0 1 2 3 4 1 2 5 8 7 step1: 从后往前，找第一个相邻的升序对(nums[i], nums[i+1]), 这里是5，8, i=2 step2: 在i的右侧，从右往前，找第一个大于nums[i]的数nums[j],这里是7， j=4 step3: 交换i, j 得到 0 1 2 3 4 1 2 7 8 5 step4: reverse(i+1, len(nums)-1) 得到： 1 2 7 5 8 */ i:=len(nums)-2 // 从后面开始，找第一个相邻的升序对 for i&amp;gt;=0 &amp;amp;&amp;amp; nums[i]&amp;gt;=nums[i+1]{ i-- } if i&amp;gt;=0{ j:=len(nums)-1 for j&amp;gt;i &amp;amp;&amp;amp; nums[i]&amp;gt;=nums[j]{ j-- } nums[i], nums[j]=nums[j], nums[i] } reverse(nums, i+1, len(nums)-1) } func reverse(nums []int, left, right int){ for left&amp;lt;right{ nums[left], nums[right]=nums[right], nums[left] left++ right-- } } // 1 2 5 8 7  </description>
    </item>
    
    <item>
      <title>0440.k-th-smallest-lexicographical-order</title>
      <link>https://wncbb.github.io/posts/leetcode/0440.k-th-smallest-in-lexicographical-order/</link>
      <pubDate>Sat, 06 Mar 2021 18:47:29 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/0440.k-th-smallest-in-lexicographical-order/</guid>
      <description>1func findKthNumber(n int, k int) int { 2	// 第一个数字一定是1 3	cur:=1 4	k-- 5	for k&amp;gt;0{ 6	nodes:=countNodes(n, cur) 7	if k&amp;lt;nodes{ 8 // ...k...nodes... 9 // 第k个元素在cur的孩子节点中，因此下降到自己的孩子节点，k-1表示刨去cur节点(root节点) 10	k-- 11	cur*=10 12	}else{ 13 // ...nodes...k... 14 // cur的子节点的个数小于k，说明第k个节点不在自己的孩子节点内部，cur++表示转向自己的兄弟节点 15	k-=nodes 16	cur++ 17	} 18	} 19	return cur 20} 21// 以cur为根节点，且最大值为n的十叉树中，有多少个元素 22// 比如下面，以x为root的树(咱们记作tree(x))的所有节点个数, 就等于各个层(从第0层到第N层)的节点的个数的和 23// x+1为root的树是x的右边的第一棵树, 记作tree(x+1) 24// 有意思的是： 对于第i层， 且i&amp;lt;N， tree(x)的第i层的节点的个数等于= tree(x+1)的第i层的第一个节点 - tree(x)的第i层的第一个节点 25// 对于第N层，节点个数= n - tree(x)的第N层的第一个节点 + 1 因为从0开始计数，所以要加1 26// 上面合起来就是： 取 MIN( tree(x+1).</description>
    </item>
    
    <item>
      <title>0206</title>
      <link>https://wncbb.github.io/posts/leetcode/0206.reverse-linked-list/</link>
      <pubDate>Sat, 06 Mar 2021 18:33:10 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/0206.reverse-linked-list/</guid>
      <description>func reverseList(head *ListNode) *ListNode { var newHead *ListNode cur:=head for cur!=nil{ next:=cur.Next cur.Next=newHead newHead=cur cur=next } return newHead }  </description>
    </item>
    
    <item>
      <title>0002</title>
      <link>https://wncbb.github.io/posts/leetcode/0002.add-two-numbers/</link>
      <pubDate>Sat, 06 Mar 2021 16:50:28 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/0002.add-two-numbers/</guid>
      <description>/** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode { dummy:=&amp;amp;ListNode{} tail:=dummy carry:=0 for l1!=nil || l2!=nil{ n1:=0 n2:=0 if l1!=nil{ n1=l1.Val l1=l1.Next } if l2!=nil{ n2=l2.Val l2=l2.Next } curRst:=n1+n2+carry tail.Next=&amp;amp;ListNode{ Val: curRst%10, } tail=tail.Next carry=curRst/10 } // 千万别忘了，最后可能还有进位 if carry!=0{ tail.Next=&amp;amp;ListNode{ Val: carry, } } return dummy.Next }  </description>
    </item>
    
    <item>
      <title>0316</title>
      <link>https://wncbb.github.io/posts/leetcode/0316.remove-duplicate-letters/</link>
      <pubDate>Sat, 06 Mar 2021 15:57:34 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/0316.remove-duplicate-letters/</guid>
      <description>as same as 1081
func removeDuplicateLetters(s string) string { if len(s)&amp;lt;=1{ return s } sBytes:=[]byte(s) // 判断字符是否在栈中 inStack:=make([]bool, 256) // 判断当前剩下的字符中，每个字符还剩多少个 bytesNum:=make([]int, 256) for _, v:=range sBytes{ bytesNum[v]++ } // 变量名不要跟参数重复 stack:=&amp;amp;Stack{ raw: make([]byte, 0), } for _, v:=range sBytes{ // 只要遍历到，剩下的v的个数就要-- bytesNum[v]-- // 已经在栈中了，就不管了 if inStack[v]{ continue } // 如果栈顶元素t比当前v大，且后面还有栈顶元素t，那与其tv, 还不如vt, 后者字典序更小，因此直接pop出t for stack.Len()&amp;gt;0 &amp;amp;&amp;amp; stack.Top()&amp;gt;v &amp;amp;&amp;amp; bytesNum[stack.Top()]&amp;gt;0{ //fmt.Printf(&amp;quot;pop: %c\n&amp;quot;, stack.Top()) inStack[stack.Pop()]=false } stack.Push(v) // fmt.Printf(&amp;quot;stack: %s\n&amp;quot;, string(stack.raw)) inStack[v]=true } return string(stack.</description>
    </item>
    
    <item>
      <title>0407</title>
      <link>https://wncbb.github.io/posts/leetcode/0407.trapping-rain-water-ii/</link>
      <pubDate>Sat, 06 Mar 2021 15:11:56 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/0407.trapping-rain-water-ii/</guid>
      <description>有youtue视频，讲解的很好 https://happygirlzt.com/code/407.html
a b c d e f g h i j k l 对于a, b,  import( &amp;quot;container/heap&amp;quot; ) /* a b c d e f g h i j k l 对于矩阵， a b c d e i h l i j k l 等边界位置，不可能存住水 我们把边界的情况压入优先队列，那么pop出的第一个元素，一定是height最小的，记作curCell 因为一个位置的存水量，取决于四周最矮的高度 因此可以算curCell四个方向的结果，遍历4次，每次的target记作tRow, tCol, tVal target的值为 max(0, curCell.Val-tVal) 然后将target存到优先队列里，因为这个位置的水已经存上去了，高度就变成 max(curVal, tVal) 如果担心某个target位置的存水量会变化，比如 4 4 4 4 4 4 3 3 3 4 4 3 2 3 4 4 3 3 3 4 4 4 4 4 4 担心2第一次存水量算作1，因为周围是3，但是最外层是4，所以应该是2 但是实际上，2不会比3先弹出来， 因为优先队列里存的都是边界，从边界开始向内计算，会先算3的存水量，然后更新成4， 所以2的存水量是正确的 */ */ type Cell struct{ row int col int val int } type PQ struct{ cells []Cell } func(p *PQ)Len()int{ return len(p.</description>
    </item>
    
    <item>
      <title>0055</title>
      <link>https://wncbb.github.io/posts/leetcode/0055.jump-game/</link>
      <pubDate>Sat, 06 Mar 2021 14:23:40 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/0055.jump-game/</guid>
      <description>func canJump(nums []int) bool { // 记录当前位置之前能够到达的最远索引 maxPosition:=0 for i:=0; i&amp;lt;len(nums); i++{ // 如果i大于当前能够到达的最远索引，说明没法到达了 // 因为游戏继续进行下去的前提是能够到达i， // i&amp;gt;maxPosition 表示当前的跳远最远距离都到达不了索引i了 if i&amp;gt;maxPosition{ return false } maxPosition=getMax(maxPosition, i+nums[i]) } return true } func getMax(a, b int)int{ if a&amp;gt;b{ return a } return b }  </description>
    </item>
    
    <item>
      <title>0045</title>
      <link>https://wncbb.github.io/posts/leetcode/0045.jump-game-ii/</link>
      <pubDate>Sat, 06 Mar 2021 13:43:02 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/0045.jump-game-ii/</guid>
      <description>func jump(nums []int) int { end:=0 steps:=0 maxPosition:=0 for i:=0; i&amp;lt;len(nums)-1; i++{ maxPosition=getMax(maxPosition, i+nums[i]) if i==end{ end=maxPosition steps++ } } return steps } func getMax(a, b int)int{ if a&amp;gt;b{ return a } return b }  </description>
    </item>
    
    <item>
      <title>403</title>
      <link>https://wncbb.github.io/posts/leetcode/403/</link>
      <pubDate>Fri, 05 Mar 2021 17:13:02 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/403/</guid>
      <description>package main import &amp;quot;fmt&amp;quot; func canCross(stones []int) bool { // stone2Prevs 表示石头，到上一次跳到这块石头上的步数的集合 stone2Prevs:=make(map[int]map[int]struct{}, len(stones)) for _, v:=range stones{ stone2Prevs[v]=make(map[int]struct{}) } stone2Prevs[stones[0]][0]= struct{}{} for i:=0; i&amp;lt;len(stones); i++{ // 跳到这一块石头的上一次的步数的集合 prevs:=stone2Prevs[stones[i]] for prev, _:=range prevs{ for curStep:=prev-1; curStep&amp;lt;=prev+1; curStep++{ // 向左跳或者不动是非法的 if curStep&amp;lt;=0{ continue } // 下一跳的位置 nextStone:=stones[i]+curStep // 如果这个位置没有石头，就continue if _, ok:=stone2Prevs[nextStone]; !ok{ continue } stone2Prevs[nextStone][curStep]= struct{}{} } } } return len(stone2Prevs[stones[len(stones)-1]])&amp;gt;0 } func main(){ var stones []int stones=[]int{0,1,3,5,6,8,12,17} stones=[]int{0,1,2,3,4,5,6,12} stones=[]int{0,2} fmt.</description>
    </item>
    
    <item>
      <title>0092</title>
      <link>https://wncbb.github.io/posts/leetcode/0092/</link>
      <pubDate>Fri, 05 Mar 2021 15:11:12 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/0092/</guid>
      <description>// reverse m~n
func reverseBetween(head *ListNode, m, n int) *ListNode { dummy := &amp;amp;ListNode{} dummy.Next = head // m-1+1 比如dummy-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;6 m=2, n=5 // m=2其实是取前m-1个，因为m属于第二部分 // 由于dummy的存在，需要加一个1跳过dummy firstPartTail, secondPartHead := splitN(dummy, m-1+1) // n-m+1 因为n跟m都属于第二部分，所以总共有n-m+1个元素 _, thirdPartHead := splitN(secondPartHead, n-m+1) //printList(&amp;quot;secondPartHead&amp;quot;, secondPartHead) //printList(&amp;quot;thirdPartHead&amp;quot;, thirdPartHead) reversedSecondPartHead := reverseList(secondPartHead) reversedSecondPartTail := secondPartHead firstPartTail.Next = reversedSecondPartHead reversedSecondPartTail.Next = thirdPartHead return dummy.Next } // 比如 dummy-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;6 k=3 // 就是取前三个，然后断开，分成两部分: // dummy-&amp;gt;1-&amp;gt;2 与 3-&amp;gt;4-&amp;gt;5-&amp;gt;6 // 然后返回第一部分的最后一个: 2 // 跟第二部分第一个：3 func splitN(head *ListNode, k int) (*ListNode, *ListNode) { k-- cur := head for cur !</description>
    </item>
    
    <item>
      <title>0092</title>
      <link>https://wncbb.github.io/posts/content/leetcode/0092/</link>
      <pubDate>Fri, 05 Mar 2021 15:10:18 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/content/leetcode/0092/</guid>
      <description></description>
    </item>
    
    <item>
      <title>480.sliding-window-median</title>
      <link>https://wncbb.github.io/posts/leetcode/480/</link>
      <pubDate>Thu, 04 Mar 2021 11:41:45 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/480/</guid>
      <description>package main import ( &amp;quot;container/heap&amp;quot; &amp;quot;fmt&amp;quot; ) func top(h *MyHeap) int { elem := heap.Pop(h).(int) heap.Push(h, elem) return elem } func getMid(firstHeap, secondHeap *MyHeap, k int) float64 { firstElem := top(firstHeap) if k%2 == 1 { return float64(firstElem) } secondElem := top(secondHeap) return float64(secondElem+firstElem) / 2 } func medianSlidingWindow(nums []int, k int) []float64 { /* if k == 0 { return nil } if k == 1 { numsFloat64 := make([]float64, 0, len(nums)) for _, v := range nums { numsFloat64 = append(numsFloat64, float64(v)) } return numsFloat64 } if len(nums) &amp;lt; k { return nil } */ firstHeap := NewHeap(make([]int, 0), func(a, b int) bool { return a &amp;gt; b }) secondHeap := NewHeap(make([]int, 0), func(a, b int) bool { return a &amp;lt; b }) for i := 0; i &amp;lt; k; i++ { heap.</description>
    </item>
    
    <item>
      <title>Heap</title>
      <link>https://wncbb.github.io/posts/golang/heap/</link>
      <pubDate>Thu, 04 Mar 2021 11:34:19 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/golang/heap/</guid>
      <description>package main import ( &amp;quot;container/heap&amp;quot; &amp;quot;fmt&amp;quot; ) // An IntHeap is a min-heap of ints. type IntHeap []int func (h IntHeap) Len() int { return len(h) } func (h IntHeap) Less(i, j int) bool { return h[i] &amp;lt; h[j] } func (h IntHeap) Swap(i, j int) { h[i], h[j] = h[j], h[i] } func (h *IntHeap) Push(x interface{}) { // Push and Pop use pointer receivers because they modify the slice&#39;s length, // not just its contents.</description>
    </item>
    
    <item>
      <title>Kmp</title>
      <link>https://wncbb.github.io/posts/algo/kmp/</link>
      <pubDate>Thu, 04 Mar 2021 11:26:13 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/algo/kmp/</guid>
      <description>package main import ( &amp;quot;fmt&amp;quot; ) func main() { s := &amp;quot;atoddasdfasdtodd&amp;quot; p := &amp;quot;abab&amp;quot; rst := match(s, p) fmt.Printf(&amp;quot;rst: %+v\n&amp;quot;, rst) } func match(s, p string) []int { nxt := build(p) ret := make([]int, 0) for i, j := 0, 0; i &amp;lt; len(s); i++ { for j &amp;gt; 0 &amp;amp;&amp;amp; s[i] != p[j] { j = nxt[j] } if s[i] == p[j] { j++ } if j == len(p) { ret = append(ret, i-len(p)+1) j = nxt[j] } } return ret } // build would build the next array // a b a b // 0 0 0 1 2 // nxt[i]表示，p[:i]字符串，最长的相同的前缀跟后缀的长度 // 比如nxt[3], p[:3]=&amp;quot;aba&amp;quot;, 前缀a，跟后缀a // 比如nxt[4], p[:4]=&amp;quot;abab&amp;quot;, 前缀ab，跟后缀ab func build(p string) []int { ret := make([]int, 0, len(p)) ret = append(ret, 0) ret = append(ret, 0) for i, j := 1, 0; i &amp;lt; len(p); i++ { for j &amp;gt; 0 &amp;amp;&amp;amp; p[i] !</description>
    </item>
    
    <item>
      <title>Eviction</title>
      <link>https://wncbb.github.io/posts/redis/eviction/</link>
      <pubDate>Wed, 03 Mar 2021 17:42:48 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/redis/eviction/</guid>
      <description>volatile: 易变的;无定性的;无常性的;可能急剧波动的;不稳定的;易恶化的;易挥发的;易发散的 lru: Least Recently Used 默认策略是 volatile-lru，即超过最大内存后，在过期键中使用 lru 算法进行 key 的剔除，保证不过期数据不被删除，但是可能会出现 OOM 问题。 allkeys-lru：根据 LRU 算法删除键，不管数据有没有设置超时属性，直到腾出足够空间为止。 allkeys-random：随机删除所有键，直到腾出足够空间为止。 volatile-random:随机删除过期键，直到腾出足够空间为止。 volatile-ttl：根据键值对象的 ttl 属性，删除最近将要过期数据。如果没有，回退到 noeviction 策略。 noeviction：不会剔除任何数据，拒绝所有写入操作并返回客户端错误信息&amp;quot;(error) OOM command not allowed when used memory&amp;quot;，此时 Redis 只响应读操作。  </description>
    </item>
    
    <item>
      <title>Command</title>
      <link>https://wncbb.github.io/posts/redis/command/</link>
      <pubDate>Wed, 03 Mar 2021 15:37:35 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/redis/command/</guid>
      <description>Available since 1.0.0. Time complexity: O(1) Set key to hold the string value. If key already holds a value, it is overwritten, regardless of its type. Any previous time to live associated with the key is discarded on successful SET operation. Options The SET command supports a set of options that modify its behavior: EX seconds -- Set the specified expire time, in seconds. PX milliseconds -- Set the specified expire time, in milliseconds.</description>
    </item>
    
    <item>
      <title>Type</title>
      <link>https://wncbb.github.io/posts/mysql/type/</link>
      <pubDate>Wed, 03 Mar 2021 14:50:40 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/mysql/type/</guid>
      <description>varchar不定长度 存储: 实际字符串，加上1/2/3字节的字符串长度 &amp;quot; a &amp;quot; 取出来也是&amp;quot; a &amp;quot;, 长度是3 对于未指定varchar字段not null的表，会有1个字节专门表示该字段是否为null char定长 存储: 实际字符串 &amp;quot; a &amp;quot; 取出来也是&amp;quot; a&amp;quot;, 长度是2 因为定长，默认就是空格，a后面的空格，分不清是用户指定输入的，还是默认值 mysql&amp;gt; create table test_string ( -&amp;gt; char_value char(5), -&amp;gt; varchar_value varchar(5), -&amp;gt; text_value text default &amp;quot;&amp;quot;) engine=innodb charset=utf8; ERROR 1101 (42000): BLOB, TEXT, GEOMETRY or JSON column &#39;text_value&#39; can&#39;t have a default value mysql&amp;gt; varchar和text两种数据类型，使用建议是能用varchar就用varchar而不用text（存储效率高），varchar(M)的M有长度限制，之前说过，如果大于限制，可以使用mediumtext（16M）或者longtext（4G）。 至于text和blob，简单过一下就是text存储的是字符串而blob存储的是二进制字符串，简单说blob是用于存储例如图片、音视频这种文件的二进制数据的。  mysql&amp;gt; create table td(a decimal(10,5)); Query OK, 0 rows affected (0.02 sec) mysql&amp;gt; insert into td(a) values(1.</description>
    </item>
    
    <item>
      <title>Base</title>
      <link>https://wncbb.github.io/posts/mysql/base/</link>
      <pubDate>Wed, 03 Mar 2021 14:12:14 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/mysql/base/</guid>
      <description>  </description>
    </item>
    
    <item>
      <title>Segment Tree</title>
      <link>https://wncbb.github.io/posts/algo/segment-tree/</link>
      <pubDate>Tue, 02 Mar 2021 15:14:44 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/algo/segment-tree/</guid>
      <description>n(i) represents the node number of binary tree having i child/s sum = n(0)+n(1)+n(2) 另一个角度，所有节点分两类： 孩子节点， 非孩子节点(有且只有一个，就是root节点) n(1)*1就是有一个孩子节点的所有节点的孩子总数 n(2)*2就是有两个孩子节点的所有节点的孩子总数 sum = sum(孩子节点) + sum(非孩子节点) =n(1)+2*n(2) + 1 因此n(0)+n(1)+n(2)=n(1)+2*n(2)+1 =&amp;gt; n(0)=n(2)+1 对于线段树，n(1)=0 然后对于输入的原始数组，长度为N，也就是n(0)=N， n(2)=n(0)-1=N-1 最好情况，满二叉树： sum = n(0)+n(2)=N+N-1=2N-1 最坏情况: x / \ a x // 倒数第二层 / \ a a // 倒数第一层 倒数第二层的a类型的节点个数:(N-2) 倒数第二层以及上面的节点个数: sum(倒数第二层以及以上) = 2(N-2)+1=2N-4+1=2N-3 sum(倒数第二层节点个数, 虽有只有两个，但是因为是数组，前面全部填空) = (N-2)*2=2N-4 所以sum=2N-3+2N-4=4N-7 所以4N个肯定够用了  package main import &amp;quot;fmt&amp;quot; var merge func(v1, v2 int) int type Node struct { start int end int value int left *Node right *Node } func buildTree(start, end int, vals []int) *Node { if start == end { return &amp;amp;Node{ start: start, end: end, value: vals[start], } } mid := start + (end-start)/2 leftChild := buildTree(start, mid, vals) rightChild := buildTree(mid+1, end, vals) return &amp;amp;Node{ start: start, end: end, value: merge(leftChild.</description>
    </item>
    
    <item>
      <title>Binary Index Tree</title>
      <link>https://wncbb.github.io/posts/algo/binary-index-tree/</link>
      <pubDate>Tue, 02 Mar 2021 13:53:38 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/algo/binary-index-tree/</guid>
      <description>package main import &amp;quot;fmt&amp;quot; type BinaryIndexTree struct { raw []int } // lowbit的作用： // x的二进制表示： xxxx...10...0 // 返回 10...0 // 换句话说，返回二进制表示形式中，最低位1所组成的数字 func lowbit(x int) int { return x &amp;amp; (-1 * x) } // Build创建 假设原始数组是s, 新的数组是a 为了方便，全部假设下标从1开始计数 // 1 第三层root // 1 5 第二层root // 1 3 5 7 第一层root // 1 2 3 4 5 6 7 8 新数组的下标，为了方便，从1开始计数，浪费下标0 // // 对于给定一个下标， // 对于奇数2i+1，a[2i+1]=s[2i+1] // // 换个角度，算下s[i]会影响数组a的哪些数值 // 答案：a[i]一定会被影响，然后影响右侧的包含s[i]的树 // 如何求i的右侧的第一棵树？ i+lowbit(i) 可以把i的二进制形式看做一颗树 // 1表示树，那么右侧第一棵树，就是i的最低位的1，这一位加1，就是右边第一棵树的索引 // 创建的时候，从左到右依次处理，那么每个元素只需要处理自己右侧最近的一棵树tree1即可(后面的树tree2,再计算tree1的时候，会修改tree2, 依次传递下去) func (b *BinaryIndexTree) Build(s []int) { b.</description>
    </item>
    
    <item>
      <title>0304.range-sum-query-2d-immutable</title>
      <link>https://wncbb.github.io/posts/leetcode/0304.range-sum-query-2d-immutable/</link>
      <pubDate>Tue, 02 Mar 2021 13:44:15 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/0304.range-sum-query-2d-immutable/</guid>
      <description>A00 A01 A02 A03 A10 A11 A12 A13 A20 A21 A22 A23 A30 A31 A32 A33 A21表示 i&amp;lt;=2, j&amp;lt;=1的矩形的和 // 需要判断下是否越界 如果要求A21 A21=(A11)+(A20)-(A10)+s[2][1] 如果求(i=1, j=1)跟(j=2, j=2)的和 和=A22-A12-A21+A11 如果求(i1, j1)跟(i2, j2)的和, 当然需要判断下边界 和=A[i2][j2]-A[i1-1][j2]-A[i2][j1-1]+A[i1-][j1-1]  type NumMatrix struct { raw [][]int } func Constructor(matrix [][]int) NumMatrix { if len(matrix)==0{ return NumMatrix{ raw: nil, } } raw := make([][]int, 0, len(matrix[0])) for i:=0; i&amp;lt;len(matrix); i++{ raw=append(raw, make([]int, len(matrix[0]), len(matrix[0]))) } for i:=0; i&amp;lt;len(matrix); i++{ for j:=0; j&amp;lt;len(matrix[0]); j++{ raw[i][j]=matrix[i][j] if i&amp;gt;0{ raw[i][j]+=raw[i-1][j] } if j&amp;gt;0{ raw[i][j]+=raw[i][j-1] } if i&amp;gt;0 &amp;amp;&amp;amp; j&amp;gt;0{ raw[i][j]-=raw[i-1][j-1] } } } return NumMatrix{ raw: raw, } } func (this *NumMatrix) SumRegion(row1 int, col1 int, row2 int, col2 int) int { ret:=this.</description>
    </item>
    
    <item>
      <title>0215</title>
      <link>https://wncbb.github.io/posts/leetcode/0215.kth-largest-element-in-an-array/</link>
      <pubDate>Mon, 01 Mar 2021 20:00:04 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/0215.kth-largest-element-in-an-array/</guid>
      <description>func findKthLargest(nums []int, k int) int { // kth内部从0开始算，第0大的数 return kth(nums, 0, len(nums)-1, k-1) } func kth(s []int, left, right, k int) int { if left &amp;lt;= right { // 这里的m一定是s里的元素的索引 m := partition(s, left, right) if m == k { return s[m] } if m &amp;lt; k { // 最后一个参数k return kth(s, m+1, right, k) } else { // 最后一个参数k return kth(s, left, m-1, k) } } return -1 } func partition(s []int, left, right int) int { i := left - 1 j := left pivot := s[right] for ; j &amp;lt; right; j++ { if s[j] &amp;gt; pivot { i = i + 1 s[i], s[j] = s[j], s[i] } } i = i + 1 s[i], s[j] = s[j], s[i] return i }  </description>
    </item>
    
    <item>
      <title>0121</title>
      <link>https://wncbb.github.io/posts/leetcode/0121.best-time-to-buy-and-sell-stock/</link>
      <pubDate>Sun, 28 Feb 2021 22:11:58 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/0121.best-time-to-buy-and-sell-stock/</guid>
      <description>func maxProfit(prices []int) int { if len(prices)==0{ return 0 } minPrice:=0 maxProfit:=0 minPrice=prices[0] for _, v:=range prices{ if minPrice&amp;gt;v{ minPrice=v }else if maxProfit&amp;lt; v-minPrice{ maxProfit=v-minPrice } } return maxProfit }  </description>
    </item>
    
    <item>
      <title>0122.best-time-to-buy-and-sell-stock-ii</title>
      <link>https://wncbb.github.io/posts/leetcode/0122.best-time-to-buy-and-sell-stock-ii/</link>
      <pubDate>Sun, 28 Feb 2021 21:55:34 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/0122.best-time-to-buy-and-sell-stock-ii/</guid>
      <description>// dp[i][0]表示第i天结束后，不持有股票的最大收益 // dp[i][1]表示第i天结束后，持有股票的最大收益 func maxProfit(prices []int) int { n := len(prices) dp := make([][2]int, n) dp[0][1] = -prices[0] for i := 1; i &amp;lt; n; i++ { // 第i天结束后不持有股票，有两种可能： // 1. 昨天就不持有股票 // 2. 昨天持有股票，今天卖掉了 dp[i][0] = max(dp[i-1][0], dp[i-1][1]+prices[i]) // 第i天结束后持有股票，有两种可能： // 1. 昨天就持有股票 // 2. 昨天不持有股票，今天又买进了 dp[i][1] = max(dp[i-1][1], dp[i-1][0]-prices[i]) } return dp[n-1][0] } func max(a, b int) int { if a &amp;gt; b { return a } return b }  </description>
    </item>
    
    <item>
      <title>0096.unique-binary-search-trees</title>
      <link>https://wncbb.github.io/posts/leetcode/0096.unique-binary-search-trees/</link>
      <pubDate>Fri, 26 Feb 2021 15:57:23 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/0096.unique-binary-search-trees/</guid>
      <description>/* G(n): 长度为 n 的序列能构成的不同二叉搜索树的个数。 F(i, n): 以 i 为根、序列长度为 n 的不同二叉搜索树个数 G(n)=F(1, n)+F(2, n)+...+F(n, n) 1 2 3 ... i ... n A A A AAA BBB B F(i, n)=G(i-1)*G(n-i) ^^ F(i, n)， i已经是root了，那么i左边的部分A是left tree, i右边的部分B是right tree 从A组成的tree list里选一个，从B组成的tree list里选一种，总共就是两者相乘的可能数 i的范围是从1到n，对应到代码里，是从1到i, 因为求的是G[i], 此时n=i */ func numTrees(n int) int { G := make([]int, n + 1) G[0], G[1] = 1, 1 for i := 2; i &amp;lt;= n; i++ { // for j := 1; j &amp;lt;= i; j++ { G[i] += G[j-1] * G[i-j] } } return G[n] }  </description>
    </item>
    
    <item>
      <title>0105.construct-binary-tree-from-preorder-and-inorder-traversal</title>
      <link>https://wncbb.github.io/posts/leetcode/0105.construct-binary-tree-from-preorder-and-inorder-traversal/</link>
      <pubDate>Fri, 26 Feb 2021 15:37:56 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/0105.construct-binary-tree-from-preorder-and-inorder-traversal/</guid>
      <description>/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func buildTree(preorder []int, inorder []int) *TreeNode { if len(preorder)==0{ return nil } curNode:=&amp;amp;TreeNode{ Val: preorder[0], } rootValIdxInInorder:=0 for idx, v:=range inorder{ if v==preorder[0]{ rootValIdxInInorder=idx break } } // 难在构建左子树、右子树函数的参数 // preorder: root A B // inorder: A root B // 所以找到A与B在preorder/inorder里的起始位置，再将A/B part作为参数即可 curNode.Left=buildTree(preorder[1:len(inorder[:rootValIdxInInorder])+1], inorder[:rootValIdxInInorder]) curNode.Right=buildTree(preorder[len(inorder[:rootValIdxInInorder])+1:], inorder[rootValIdxInInorder+1:]) return curNode }  </description>
    </item>
    
    <item>
      <title>0103.binary-tree-zigzag-level-order-traversal</title>
      <link>https://wncbb.github.io/posts/leetcode/0103.binary-tree-zigzag-level-order-traversal/</link>
      <pubDate>Fri, 26 Feb 2021 15:22:21 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/0103.binary-tree-zigzag-level-order-traversal/</guid>
      <description>/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func zigzagLevelOrder(root *TreeNode) [][]int { if root==nil{ return nil } ret:=make([][]int, 0) nextQ:=make([]*TreeNode, 0) nextQ=append(nextQ, root) level:=0 for len(nextQ)!=0{ curQ:=nextQ nextQ=make([]*TreeNode, 0) curVals:=make([]int, 0, len(curQ)) for i:=0; i&amp;lt;len(curQ); i++{ curNode:=curQ[i] if curNode.Left!=nil{ nextQ=append(nextQ, curNode.Left) } if curNode.Right!=nil{ nextQ=append(nextQ, curNode.Right) } curVals=append(curVals, curNode.Val) } // 为了简单，直接根据层数的奇偶来做倒置 if level%2==1{ for i:=0; i&amp;lt;len(curVals)/2; i++{ curVals[i], curVals[len(curVals)-i-1]=curVals[len(curVals)-i-1], curVals[i] } } ret=append(ret, curVals) level++ } return ret }  </description>
    </item>
    
    <item>
      <title>0124.binary-tree-maximum-path-sum</title>
      <link>https://wncbb.github.io/posts/leetcode/0124.binary-tree-maximum-path-sum/</link>
      <pubDate>Fri, 26 Feb 2021 14:58:35 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/0124.binary-tree-maximum-path-sum/</guid>
      <description>```go /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ var ret int var retIsSet bool func maxPathSum(root *TreeNode) int { ret=0 retIsSet=false
helper(root) return ret  }
// 获得一定包含root，且以root为起点，且单边(左子树或右子树路径上单链，当然可以只包含root，比如root的下面的节点都是负数，就可以只包含root)的最大值 func helper(root *TreeNode) int { if root==nil{ return 0 }
// 如果helper(root.Left)为负数，还不如不包含后面的节点，直接设置为0 left:=getMax(0, helper(root.Left)) right:=getMax(0, helper(root.Right)) // 以root为最高层节点，的结果的最优值，只要遍历所有节点的最优值，且取最大值，即得到结果 curVal:=left+right+root.Val if retIsSet{ ret=getMax(ret, curVal) }else{ retIsSet=true ret=curVal } if left&amp;gt;right{ return left+root.</description>
    </item>
    
    <item>
      <title>0199.binary-tree-right-side-view</title>
      <link>https://wncbb.github.io/posts/leetcode/0199.binary_tree_right_side_view/</link>
      <pubDate>Fri, 26 Feb 2021 14:55:03 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/0199.binary_tree_right_side_view/</guid>
      <description>需要区分二叉树的这一层下一层，准备俩queue，一个当前处理的curQ， 一个q存放从curQ里出来的node的孩子节点 然后curQ=q; q=nil 继续下一次循环
/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func rightSideView(root *TreeNode) []int { if root==nil{ return nil } ret:=make([]int, 0) q:=make([]*TreeNode, 0) q=append(q, root) for len(q)!=0{ curRst:=0 curQ:=q q=nil for i:=0; i&amp;lt;len(curQ); i++{ curNode:=curQ[i] curRst=curNode.Val if curNode.Left!=nil{ q=append(q, curNode.Left) } if curNode.Right!=nil{ q=append(q, curNode.Right) } } ret=append(ret, curRst) } return ret }  </description>
    </item>
    
    <item>
      <title>0025.reverse-nodes-in-k-group</title>
      <link>https://wncbb.github.io/posts/leetcode/0025.reverse-nodes-in-k-group/</link>
      <pubDate>Thu, 25 Feb 2021 15:58:28 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/0025.reverse-nodes-in-k-group/</guid>
      <description>1package main 2 3import &amp;#34;fmt&amp;#34; 4 5// Definition for singly-linked list. 6type ListNode struct { 7	Val int 8	Next *ListNode 9} 10 11func reverseKGroup(head *ListNode, k int) *ListNode { 12	if head==nil || head.Next==nil{ 13	return head 14	} 15	if k&amp;lt;=1{ 16	return head 17	} 18 19	lastNode:=head 20	for i:=0; i &amp;lt; k-1; i++ { 21	lastNode = lastNode.Next 22	if lastNode==nil{ 23	return head 24	} 25	} 26 27	// nextPartHead是下一段的开始节点 28	nextPartHead := lastNode.</description>
    </item>
    
    <item>
      <title>Pointer_struct</title>
      <link>https://wncbb.github.io/posts/golang/pointer_struct/</link>
      <pubDate>Sat, 20 Feb 2021 17:58:58 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/golang/pointer_struct/</guid>
      <description>package main import ( &amp;quot;fmt&amp;quot; ) type A struct { PointerValue string StructValue string } func (a *A) PointerSet(v string) { a.PointerValue = v } func (a A) StructSet(v string) { a.StructValue = v } func main() { s := A{PointerValue: &amp;quot;beforeChange&amp;quot;, StructValue: &amp;quot;beforeChange&amp;quot;} p := &amp;amp;A{PointerValue: &amp;quot;beforeChange&amp;quot;, StructValue: &amp;quot;beforeChange&amp;quot;} fmt.Printf(&amp;quot;s: %+v\n&amp;quot;, s) // s: {PointerValue:beforeChange StructValue:beforeChange} // changed s.PointerSet(&amp;quot;afterChange&amp;quot;) // not changed s.StructSet(&amp;quot;afterChange&amp;quot;) fmt.Printf(&amp;quot;s: %+v\n&amp;quot;, s) // s: {PointerValue:afterChange StructValue:beforeChange} fmt.</description>
    </item>
    
    <item>
      <title>Interface_pointer_struct</title>
      <link>https://wncbb.github.io/posts/golang/interface_pointer_struct/</link>
      <pubDate>Sat, 20 Feb 2021 17:56:54 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/golang/interface_pointer_struct/</guid>
      <description>package main import &amp;quot;fmt&amp;quot; type Inter interface { SetName(name string) } type A struct { Name string } func (a A) SetName(name string) { a.Name = name } type B struct { Name string } func (b *B) SetName(name string) { b.Name = name } func main() { var a Inter = A{Name: &amp;quot;todd&amp;quot;} a.SetName(&amp;quot;alice&amp;quot;) fmt.Printf(&amp;quot;a: %+v\n&amp;quot;, a) // ?相当于 SetName((复制ap然后解引用(*copy_ap)), &amp;quot;alice&amp;quot;) // ?修改的不是同一个值 // 修改失败 var ap Inter = &amp;amp;A{Name: &amp;quot;todd&amp;quot;} ap.</description>
    </item>
    
    <item>
      <title>Interface</title>
      <link>https://wncbb.github.io/posts/golang/interface/</link>
      <pubDate>Fri, 19 Feb 2021 11:05:14 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/golang/interface/</guid>
      <description>https://cmc.gitbook.io/go-internals/chapter-ii-interfaces</description>
    </item>
    
    <item>
      <title>0560.subarray-sum-equals-k</title>
      <link>https://wncbb.github.io/posts/leetcode/0560.subarray-sum-equals-k/</link>
      <pubDate>Thu, 31 Dec 2020 17:01:26 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/0560.subarray-sum-equals-k/</guid>
      <description>题目简介 给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。
示例 1 :
输入:nums = [1,1,1], k = 2 输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。 说明 :
数组的长度为 [1, 20,000]。 数组中元素的范围是 [-1000, 1000] ，且整数 k 的范围是 [-1e7, 1e7]。
解 解1 1/* 2比如 ABCDEFG... 3如果当前所有的和是Sum(A...G) 4如果存在Sum(A...X), 使得 Sum(A...X)+k=Sum(A...G)， 5也就是说，Sum(A...G)-k这个数存在， 6那么，(X...G]就是满足条件的 7*/ 8 9class Solution { 10 public int subarraySum(int[] nums, int k) { 11 // 扫描一遍数组, 使用map记录出现同样的和的次数, 对每个i计算累计和sum并判断map内是否有sum-k 12 Map&amp;lt;Integer, Integer&amp;gt; map = new HashMap&amp;lt;&amp;gt;(); 13 // 放0的目的是： 如果Sum(A.</description>
    </item>
    
    <item>
      <title>0435.non-overlapping-intervals</title>
      <link>https://wncbb.github.io/posts/leetcode/0435.non-overlapping-intervals/</link>
      <pubDate>Thu, 31 Dec 2020 15:23:58 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/0435.non-overlapping-intervals/</guid>
      <description>示例 1: 输入: [ [1,2], [2,3], [3,4], [1,3] ] 输出: 1 解释: 移除 [1,3] 后，剩下的区间没有重叠。 示例 2: 输入: [ [1,2], [1,2], [1,2] ] 输出: 2 解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。 贪心策略: 先按照右边界从小到大排序，然后依次遍历，不能放进去的(左边界小于左边区间的右边界)，就删掉  1import ( 2	&amp;#34;sort&amp;#34; 3) 4 5// non-overlapping-intervals 6func eraseOverlapIntervals(intervals [][]int) int { 7	if len(intervals) == 0 { 8	return 0 9	} 10	sort.Slice(intervals, func(i, j int) bool { 11	return intervals[i][1] &amp;lt; intervals[j][1] 12	}) 13 14	curRight := intervals[0][1] 15	ret := 0 16	for i := 1; i &amp;lt; len(intervals); i++ { 17	if curRight &amp;lt;= intervals[i][0] { 18	curRight = intervals[i][1] 19	} else { 20	ret++ 21	} 22	} 23	return ret 24} </description>
    </item>
    
    <item>
      <title>0003.longest-substring-without-repeating-characters</title>
      <link>https://wncbb.github.io/posts/leetcode/0003.longest-substring-without-repeating-characters/</link>
      <pubDate>Wed, 30 Dec 2020 20:48:41 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/0003.longest-substring-without-repeating-characters/</guid>
      <description>1func getMax(a, b int)int{ 2 if a&amp;gt;b{ 3 return a 4 } 5 return b 6} 7func getMin(a, b int)int{ 8 if a&amp;gt;b{ 9 return b 10 } 11 return a 12} 13 14func lengthOfLongestSubstring(s string) int { 15 lookup := make(map[rune]int) 16	curLeft := 0 17	maxLen := 0 18	for k, v := range s { 19	if lastIdx, ok := lookup[v]; ok { 20 curLeft=getMax(lastIdx+1, curLeft) 21	} 22 maxLen=getMax(maxLen, k-curLeft+1) 23 lookup[v]=k 24	} 25	return maxLen 26} </description>
    </item>
    
    <item>
      <title>0004.median-of-two-sorted-arrays</title>
      <link>https://wncbb.github.io/posts/leetcode/0004.median-of-two-sorted-arrays/</link>
      <pubDate>Wed, 30 Dec 2020 20:04:23 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/0004.median-of-two-sorted-arrays/</guid>
      <description>示例 1： 输入：nums1 = [1,3], nums2 = [2] 输出：2.00000 解释：合并数组 = [1,2,3] ，中位数 2 示例 2： 输入：nums1 = [1,2], nums2 = [3,4] 输出：2.50000 解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5 示例 3： 输入：nums1 = [0,0], nums2 = [0,0] 输出：0.00000 示例 4： 输入：nums1 = [], nums2 = [1] 输出：1.00000 示例 5： 输入：nums1 = [2], nums2 = [] 输出：2.00000  1import ( 2	&amp;#34;math&amp;#34; 3) 4 5func findMedianSortedArrays(nums1 []int, nums2 []int) float64 { 6	left := (len(nums1) + len(nums2) + 1) / 2 7	right := (len(nums1) + len(nums2) + 2) / 2 8	return (float64(findK(nums1, 0, nums2, 0, left)) + float64(findK(nums1, 0, nums2, 0, right))) / 2.</description>
    </item>
    
    <item>
      <title>0208.mplement-trie-prefix-tree</title>
      <link>https://wncbb.github.io/posts/leetcode/0208.mplement-trie-prefix-tree/</link>
      <pubDate>Wed, 30 Dec 2020 19:12:02 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/0208.mplement-trie-prefix-tree/</guid>
      <description>1type Node struct { 2	IsEnd bool 3	Val rune 4	Next map[rune]*Node 5} 6 7type Trie struct { 8	root *Node 9} 10 11/** Initialize your data structure here. */ 12func Constructor() Trie { 13	return Trie{ 14	root: &amp;amp;Node{ 15	Next: make(map[rune]*Node), 16	}, 17	} 18} 19 20/** Inserts a word into the trie. */ 21func (this *Trie) Insert(word string) { 22	cur := this.root 23	for _, v := range word { 24	if nextNode, ok := cur.</description>
    </item>
    
    <item>
      <title>1035.uncrossed-lines</title>
      <link>https://wncbb.github.io/posts/leetcode/1035.uncrossed-lines/</link>
      <pubDate>Wed, 30 Dec 2020 18:40:16 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/1035.uncrossed-lines/</guid>
      <description>给定 1 4 2 1 2 4 上下相同的数连接画一条线，最多只能画两条线 类似： 1143 本质是最长公共子序列  1func maxUncrossedLines(A []int, B []int) int { 2	dp := make([][]int, 0, len(A)+1) 3	for i := 0; i &amp;lt; len(A)+1; i++ { 4	dp = append(dp, make([]int, len(B)+1, len(B)+1)) 5	} 6 7	for i, v1 := range A { 8	for j, v2 := range B { 9	if v1 == v2 { 10	dp[i+1][j+1] = dp[i][j] + 1 11	} else { 12	dp[i+1][j+1] = getMaxInt(dp[i+1][j], dp[i][j+1]) 13	} 14	} 15	} 16 17	return dp[len(A)][len(B)] 18} 19 20func getMaxInt(a, b int) int { 21	if a &amp;gt; b { 22	return a 23	} 24	return b 25} </description>
    </item>
    
    <item>
      <title>1143.longest-common-subsequence</title>
      <link>https://wncbb.github.io/posts/leetcode/1143.longest-common-subsequence/</link>
      <pubDate>Wed, 30 Dec 2020 18:32:29 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/1143.longest-common-subsequence/</guid>
      <description>两个数组的 最长公共子序列 子序列：不一定连续 1143 子数组：一定连续 718 换汤不换药 1035  1func longestCommonSubsequence(text1 string, text2 string) int { 2	dp := make([][]int, 0, len(text1)+1) 3	for i := 0; i &amp;lt; len(text1)+1; i++ { 4	dp = append(dp, make([]int, len(text2)+1, len(text2)+1)) 5	} 6 7	for i, ch1 := range text1 { 8	for j, ch2 := range text2 { 9	if ch1 == ch2 { 10	dp[i+1][j+1] = dp[i][j] + 1 11	} else { 12	dp[i+1][j+1] = getMaxInt(dp[i+1][j], dp[i][j+1]) 13	} 14	} 15	} 16 17	return dp[len(text1)][len(text2)] 18} 19 20func getMaxInt(a, b int) int { 21	if a &amp;gt; b { 22	return a 23	} 24	return b 25} </description>
    </item>
    
    <item>
      <title>0718.maximum-length-of-repeated-subarray</title>
      <link>https://wncbb.github.io/posts/leetcode/0718.maximum-length-of-repeated-subarray/</link>
      <pubDate>Wed, 30 Dec 2020 17:26:31 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/0718.maximum-length-of-repeated-subarray/</guid>
      <description>两个数组的 最长子数组 子序列：不一定连续 1143 子数组：一定连续 718  1func findLength(A []int, B []int) int { 2	if len(A) == 0 || len(B) == 0 { 3	return 0 4	} 5	6 // dp[i][j]表示以A[i] B[j]结尾的相同子数组的长度 7	dp := make([][]int, 0, len(A)) 8	for i := 0; i &amp;lt; len(A); i++ { 9	dp = append(dp, make([]int, len(B), len(B))) 10	} 11 12 // 为了避免i=0, j=0, 此时0-1=-1，索引非法的问题，先初始化0的情况 13	for i := 0; i &amp;lt; len(A); i++ { 14	if A[i] == B[0] { 15	dp[i][0] = 1 16	} 17	} 18	for j := 0; j &amp;lt; len(B); j++ { 19	if A[0] == B[j] { 20	dp[0][j] = 1 21	} 22	} 23 24	ret := 0 25 26	for i := 1; i &amp;lt; len(A); i++ { 27	for j := 1; j &amp;lt; len(B); j++ { 28	if A[i] == B[j] { 29	dp[i][j] = dp[i-1][j-1] + 1 30	if ret &amp;lt; dp[i][j] { 31	ret = dp[i][j] 32	} 33	} 34	} 35	} 36 37	return ret 38} 或者数组多一位  1func findLength(A []int, B []int) int { 2	if len(A) == 0 || len(B) == 0 { 3	return 0 4	} 5 6	dp := make([][]int, 0, len(A)+1) 7	for i := 0; i &amp;lt; len(A)+1; i++ { 8	dp = append(dp, make([]int, len(B)+1, len(B)+1)) 9	} 10 11	ret := 0 12 13	for i := 1; i &amp;lt;= len(A); i++ { 14	for j := 1; j &amp;lt;= len(B); j++ { 15	if A[i-1] == B[j-1] { 16	dp[i][j] = dp[i-1][j-1] + 1 17	if ret &amp;lt; dp[i][j] { 18	ret = dp[i][j] 19	} 20	} 21	} 22	} 23 24	return ret 25} 26``` </description>
    </item>
    
    <item>
      <title>1206.design-skiplist</title>
      <link>https://wncbb.github.io/posts/leetcode/1206.design-skiplist/</link>
      <pubDate>Wed, 30 Dec 2020 16:37:20 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/1206.design-skiplist/</guid>
      <description>1import ( 2	&amp;#34;math/rand&amp;#34; 3) 4 5const ( 6	maxLevel = 16 7	skipListPVal = 0.5 8) 9 10// randomLevel 返回一个Next数组的高度, 高度不能超过最大值 11func randomLevel() int { 12	retLevel := 1 13	for retLevel &amp;lt; maxLevel &amp;amp;&amp;amp; rand.Float32() &amp;lt; skipListPVal { 14	retLevel++ 15	} 16	return retLevel 17} 18 19type Node struct { 20	Val int 21	Next [maxLevel]*Node 22} 23 24func NewNode(val int, next [maxLevel]*Node) *Node { 25	return &amp;amp;Node{ 26	Val: val, 27	Next: next, 28	} 29} 30 31type Skiplist struct { 32	head *Node 33	maxLevel int 34} 35 36func Constructor() Skiplist { 37	return Skiplist{ 38	// head 里的值是最小值,这里取-1 39	head: NewNode(-1, [maxLevel]*Node{}), 40	maxLevel: 1, 41	} 42} 43 44func (this *Skiplist) search(target int) [maxLevel]*Node { 45	cur := this.</description>
    </item>
    
    <item>
      <title>0032.longest-valid-parentheses</title>
      <link>https://wncbb.github.io/posts/leetcode/0032.longest-valid-parentheses/</link>
      <pubDate>Tue, 22 Dec 2020 16:27:41 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/0032.longest-valid-parentheses/</guid>
      <description>1func longestValidParentheses(s string) int { 2	rst := 0 3 // dp[i] 表示以s[i]字符结尾的最长的合法的括号长度 4	dp := make([]int, len(s), len(s)) 5	for i := 1; i &amp;lt; len(s); i++ { 6	curByte := s[i] 7 // 如果s[i]是左括号，那么以左括号为结尾的字符串，一定不是合法的，长度就是0 8	if curByte == &amp;#39;(&amp;#39; { 9	continue 10	} 11 // 如果s[i]是右括号，比如这种 ?()) 12 // 就需要看一下，s[i-1]结尾的合法字符串的前一个是不是左括号， 13 // 如果是，需要加2（一个是当前的右括号，一个是dp[i-1]之前的左括号) 14	leftIdx := i - dp[i-1] - 1 15	if leftIdx &amp;gt;= 0 &amp;amp;&amp;amp; s[leftIdx] == &amp;#39;(&amp;#39; { 16	dp[i] = dp[i-1] + 2 17	leftLeftIdx := i - dp[i-1] - 2 18 // 这里还需要加上dp[i-1]之前的合法字符串的长度 19 // 对应这种情况: ()(()) 20 // 这里只需要看一次就行，因为如果前面还有的话，一定包含在dp[i-dp[i-1]-2]里了 21	if leftLeftIdx &amp;gt;= 0 { 22	dp[i] += dp[leftLeftIdx] 23	} 24	} 25	if rst &amp;lt; dp[i] { 26	rst = dp[i] 27	} 28 29	} 30	return rst 31} </description>
    </item>
    
    <item>
      <title>0030.substring-with-concatenation-of-all-words</title>
      <link>https://wncbb.github.io/posts/leetcode/0030.substring-with-concatenation-of-all-words/</link>
      <pubDate>Fri, 18 Dec 2020 19:56:59 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/0030.substring-with-concatenation-of-all-words/</guid>
      <description>有点暴力的解法，就是遍历所有可能的窗口  1func findSubstring(s string, words []string) []int { 2	//声明返回值 3	var result []int 4 5	//判断 6	if len(s) == 0 || len(words) == 0 { 7	return result 8	} 9 10 11	//获取单词长度 12	l := len(words[0]) 13 14	//获取滑动窗口总长度 15	length := l * len(words) 16 17	//判断 18	if length &amp;gt; len(s) { 19	return result 20	} 21 22	//构造map 23	mp := make(map[string]int) 24 25	//统计 26	for _,v := range words { 27	mp[v] += 1 28	} 29 30	//开始遍历 31	for i := 0; i &amp;lt;= (len(s) - length);i++ { 32	//判断i开始length位置 33	tmpMap := map[string]int{} 34 35	//定义标志 36	//默认是true 37	fg := true 38 39	// 这里的逻辑是，如果当前的单词是需要的，且个数还没凑够，那就对应的数减一 40	// 如果遇到不需要的单词，一定就不合法了.</description>
    </item>
    
    <item>
      <title>0336.palindrome-pairs</title>
      <link>https://wncbb.github.io/posts/leetcode/0336.palindrome-pairs/</link>
      <pubDate>Fri, 18 Dec 2020 19:36:38 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/0336.palindrome-pairs/</guid>
      <description>1func palindromePairs(words []string) [][]int { 2	m := make(map[string]int, len(words)) 3	for idx, v := range words { 4	m[v] = idx 5	} 6 7	res := make([][]int, 0) 8 9	for idx, v := range words { 10	// 如果非空字符串v是回文串，且字符数组中包含空字符串，那么 v+&amp;#34;&amp;#34; 与 &amp;#34;&amp;#34;+v 都是回文串 11	if emptyStrIdx, ok := m[&amp;#34;&amp;#34;]; ok &amp;amp;&amp;amp; isPalindrome(v) &amp;amp;&amp;amp; v != &amp;#34;&amp;#34; { 12	res = append(res, []int{emptyStrIdx, idx}) 13	res = append(res, []int{idx, emptyStrIdx}) 14	} 15	// v的逆序字符串存在的话，那么这俩一拼也是回文串，注意这里只加一次( 16	// 比如A的逆序是B, 遍历到A的话，加入A,B; 17	// 遍历到B的时候，加入B,A，就不会重复 18	// ) 19 // 其实v !</description>
    </item>
    
    <item>
      <title>0010.regular-expression-matching</title>
      <link>https://wncbb.github.io/posts/leetcode/0010.regular-expression-matching/</link>
      <pubDate>Thu, 17 Dec 2020 17:22:10 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/0010.regular-expression-matching/</guid>
      <description>1func isMatch(s string, p string) bool { 2 // sBytes := []byte(s) 3 // pBytes := []byte(p) 4 // dp[i][j]表示s[:i+1] p[:j+1]是否匹配 5 dp := make([][]bool, 0, len(s)+1) 6 for i := 0; i &amp;lt; len(s)+1; i++ { 7 dp = append(dp, make([]bool, len(p)+1)) 8 } 9 // s跟p都是空字符，肯定匹配的上 10 dp[0][0] = true 11 for i := 1; i &amp;lt; len(p); i++ { 12 // 如果当前p[i]是*，那么*可以把前面的字符搞没 13 // 比如 &amp;#34;b*a*&amp;#34; 跟 &amp;#34;&amp;#34;比较，a*可以去掉，那么就变成&amp;#34;b*&amp;#34;跟&amp;#34;&amp;#34;比较 14 if p[i] == &amp;#39;*&amp;#39; { 15 dp[0][i+1] = dp[0][i-1] 16 } 17 } 18 19	for i, sByte := range s { 20	for j, pByte := range p { 21	switch { 22	case sByte == pByte: 23 // 最简单的case，俩字符一样，那么前面的如果匹配，这个一定匹配 24	dp[i+1][j+1] = dp[i+1][j+1] || dp[i][j] 25	case pByte == &amp;#39;.</description>
    </item>
    
    <item>
      <title>0076.minimum-window-substring</title>
      <link>https://wncbb.github.io/posts/leetcode/0076.minimum-window-substring/</link>
      <pubDate>Mon, 14 Dec 2020 16:47:32 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/0076.minimum-window-substring/</guid>
      <description>滑动窗口逻辑： 声明俩变量left right初始化为0 1. 右边界往右遍历，符合条件后， 2. 左边界往右遍历，直到不符合条件，再跳到1 期间符合条件时，更新下当前的最优解 for right&amp;lt;number{ handle value[right] right++ if left&amp;lt;=right and satisfy the condition { current left and right are good result, update final result left++ } }  1func minWindow(s string, t string) string { 2	retLeft := 0 3	retRight := len(s) + 100 4	left := 0 5	right := 0 6	// 记录t中，byte到个数的map 7	visited := make(map[byte]int) 8	// 实时记录，当前left到right之间的t中字符，byte到个数的映射 9	curVisited := make(map[byte]int) 10	curFitNum := 0 11	tBytes := []byte(t) 12	for _, v := range tBytes { 13	visited[v] += 1 14	} 15	for _, v := range tBytes { 16	curVisited[v] = 0 17	} 18	// t中unique的字符个数 19	fitNum := len(visited) 20	for right &amp;lt; len(s) { 21	// 遍历右边，并处理curVisited, curFitNum等中间记录当前状态的变量 22	curRightByte := s[right] 23	if _, ok := curVisited[curRightByte]; ok { 24	curVisited[curRightByte]++ 25	if curVisited[curRightByte] == visited[curRightByte] { 26	curFitNum++ 27	} 28	} 29	right++ 30 31	for left &amp;lt;= right &amp;amp;&amp;amp; curFitNum == fitNum { 32	// 当left在合法范围内，且当前符合条件时 33	// 检查下是否更新返回值 34	if right-left &amp;lt; retRight-retLeft { 35	retRight = right 36	retLeft = left 37	} 38 39 // 去掉left的字符后，处理curVisited, curFitNum等中间记录当前状态的变量 40	curLeftByte := s[left] 41	if v, ok := curVisited[curLeftByte]; ok { 42	if v == visited[curLeftByte] { 43	curFitNum-- 44	} 45	curVisited[curLeftByte]-- 46 47	} 48	left++ 49	} 50	} 51	if retRight &amp;gt; len(s) { 52	return &amp;#34;&amp;#34; 53	} 54	return s[retLeft:retRight] 55} </description>
    </item>
    
    <item>
      <title>0042.rapping-rain-water</title>
      <link>https://wncbb.github.io/posts/leetcode/0042.trapping-rain-water/</link>
      <pubDate>Thu, 10 Dec 2020 19:03:01 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/0042.trapping-rain-water/</guid>
      <description>单调栈解法 1func trap(height []int) int { 2 if len(height)&amp;lt;=2{ 3 return 0 4 } 5 6 s:=&amp;amp;Stack{ 7 raw: make([]int, 0), 8 } 9 s.Push(0) 10 rst:=0 11 for i:=1; i&amp;lt;len(height); i++{ 12 v:=height[i] 13 for s.Len()&amp;gt;0 &amp;amp;&amp;amp; v&amp;gt;height[s.Top()]{ 14	// 其实要算的是targetIdx位置的雨水 15 targetIdx:=s.Pop() 16 if s.Len()&amp;gt;0{ 17	// 栈顶元素是左边界 18 leftIdx:=s.Top() 19	// i是右边界 20 rightIdx:=i 21	// 存储水量取决于左右边界的最低值，然后减去target的高度，就是存水量的高, 再乘以宽度，就是水量 22	// 宽度是 rightIdx-leftIdx-1， 比如 3， 4， 5， 6， 7 23	// 如果leftIdx=3, rightIdx=7， 那么要取4， 5， 6的宽度3， 7-3=4， 需要再减去1 24 rst+= (getMin(height[leftIdx], height[rightIdx])-height[targetIdx])*(rightIdx-leftIdx-1) 25 } 26 } 27 s.</description>
    </item>
    
    <item>
      <title>0053.maximum-subarray</title>
      <link>https://wncbb.github.io/posts/leetcode/0053.maximum-subarra/</link>
      <pubDate>Thu, 10 Dec 2020 16:33:51 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/0053.maximum-subarra/</guid>
      <description>1func maxSubArray(nums []int) int { 2	if len(nums) == 0 { 3	return 0 4	} 5	// dp[i]表示以i结尾的和 6	dp := make([]int, len(nums), len(nums)) 7	dp[0] = nums[0] 8	rst := nums[0] 9	for i := 1; i &amp;lt; len(nums); i++ { 10	// 对于以i结尾的连续数组，要么就他自己，要么他自己加上以i-1为结尾的最大值 11	dp[i] = max(nums[i], nums[i]+dp[i-1]) 12	if dp[i] &amp;gt; rst { 13	rst = dp[i] 14	} 15	} 16 17	return rst 18} 19 20func max(a, b int) int { 21	if a &amp;gt; b { 22	return a 23	} 24	return b 25} </description>
    </item>
    
    <item>
      <title>0041.first-missing-positive</title>
      <link>https://wncbb.github.io/posts/leetcode/0041.first-missing-positive/</link>
      <pubDate>Thu, 10 Dec 2020 16:17:11 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/0041.first-missing-positive/</guid>
      <description>比如2， 3，-1， 6 遍历一遍，负数变成默认值: 数组长度 原因是需要拿负号做标记，所以先把原来的负数干掉 先变成 2， 3， 5， 6 然后，遇到2，如果2在len里面，且对应位置的数是整数，就改成负数 2, -3, -5, 6 这样，遍历一遍，第一个正数对应的位置，就是第一个缺失的正整数  1func firstMissingPositive(nums []int) int { 2	for i, _ := range nums { 3	if nums[i] &amp;lt;= 0 { 4	nums[i] = len(nums) + 1 5	} 6	} 7	8	for i, _ := range nums { 9	// abs(nums[i]) 10	// is for 3, 4, -1, 1 11	// otherwise 12	// after checking negative, would be 3, 4, 5, 1 13	// after this lookp, would be 3, 4, -5, -1 14	// then 1 would be returned 15	// the reason is that the last value 1 is set to negative 16	// so we need to ignore negative, just use abs value 17	cur := abs(nums[i]) 18	// nums[cur-1] &amp;gt; 0 19	// is for 1, 1 20	// otherwise 21	// after checking ne4tative, would be 1, 1 22	// after this lookup, would be -1, 1, then 1, 1 23	// the zero index was set two times, and -1*-1=1 24	// so for one index, we only need to set one time 25	if cur &amp;gt; 0 &amp;amp;&amp;amp; cur &amp;lt; len(nums)+1 &amp;amp;&amp;amp; nums[cur-1] &amp;gt; 0 { 26	nums[cur-1] *= -1 27	} 28	} 29 30	for i, _ := range nums { 31	if nums[i] &amp;gt; 0 { 32	return i + 1 33	} 34	} 35 36	return len(nums) + 1 37} 38 39func abs(a int) int { 40	if a &amp;lt; 0 { 41	a *= -1 42	} 43	return a 44} </description>
    </item>
    
    <item>
      <title>0051.n-queens</title>
      <link>https://wncbb.github.io/posts/leetcode/0051.n-queens/</link>
      <pubDate>Thu, 10 Dec 2020 15:34:43 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/0051.n-queens/</guid>
      <description>1func solveNQueens(n int) [][]string { 2	rst := make([][]string, 0) 3	4	// initialize chess 5	chess := make([][]byte, 0, n) 6	for i := 0; i &amp;lt; n; i++ { 7	chess = append(chess, getLine(n)) 8	} 9 10	var bs func(row int) 11	bs = func(row int) { 12	if row == n { 13	rst = append(rst, getRst(chess)) 14	return 15	} 16	for col := 0; col &amp;lt; n; col++ { 17	// if location with row and col can not add a Q 18	// then just continue 19	if !</description>
    </item>
    
    <item>
      <title>Reset</title>
      <link>https://wncbb.github.io/posts/git/reset/</link>
      <pubDate>Thu, 10 Dec 2020 14:05:18 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/git/reset/</guid>
      <description>https://ndpsoftware.com/git-cheatsheet.html
// 取消上一次提交，且代码不要了 git reset --hard HEAD^1 // 取消上一次提交，代码在add状态 git reset --soft HEAD^1 // 取消add状态 git reset git reset &amp;lt;file&amp;gt;  </description>
    </item>
    
    <item>
      <title>0056.merge-intervals</title>
      <link>https://wncbb.github.io/posts/leetcode/0056.merge-intervals/</link>
      <pubDate>Thu, 10 Dec 2020 13:44:21 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/0056.merge-intervals/</guid>
      <description>1func merge(intervals [][]int) [][]int { 2	if len(intervals) == 0 { 3	return [][]int{} 4	} 5	if len(intervals) == 1 { 6	return intervals 7	} 8	// need to sort by the start value 9	sort.Slice(intervals, func(i, j int) bool { 10	return intervals[i][0] &amp;lt; intervals[j][0] 11	}) 12	rst := make([][]int, 0) 13	cur := intervals[0] 14	for i := 1; i &amp;lt; len(intervals); i++ { 15	if intervals[i][0] &amp;lt;= cur[1] { 16	// cur = [1, 3] intervals[i]=[2, 5] 17	// 对于这种，需要合并，合并后开始还是cur[0], cur[1]=两个结束值的最大值 18	cur[1] = getMaxInt(cur[1], intervals[i][1]) 19	} else { 20	// cur = [1, 3] intervals[i]=[4, 5] 21	rst = append(rst, cur) 22	cur = intervals[i] 23	} 24	} 25 26	rst = append(rst, cur) 27	return rst 28 29} 30 31func getMaxInt(a, b int) int { 32	if a &amp;gt; b { 33	return a 34	} 35	return b 36} </description>
    </item>
    
    <item>
      <title>0047.permutations_II</title>
      <link>https://wncbb.github.io/posts/leetcode/0047.permutations-ii/</link>
      <pubDate>Thu, 10 Dec 2020 13:31:12 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/0047.permutations-ii/</guid>
      <description>1func permuteUnique(s []int) [][]int { 2 // need to sort the s first, so it&amp;#39;s easy for us to skip the duplicated value 3	sort.Ints(s) 4	rst := make([][]int, 0) 5	visited := make([]bool, len(s), len(s)) 6 7	var bs func(idx int, cur []int) 8 9	bs = func(idx int, cur []int) { 10	if idx == len(s) { 11	curRst := make([]int, len(cur), len(cur)) 12	copy(curRst, cur) 13	rst = append(rst, curRst) 14	return 15	} 16 17	for i := 0; i &amp;lt; len(s); i++ { 18	if visited[i] { 19	continue 20	} 21	// s[i]==s[i-1] means the value with last idx equals current value 22	// 23	// i-1 is in front of i 24	// so i-1 must have been handled before i 25	// and visited[i-1]==false means the result of this value has been added to rst 26	// then deleting i-1 from current result and hanlde i 27	if i &amp;gt; 0 &amp;amp;&amp;amp; s[i] == s[i-1] &amp;amp;&amp;amp; !</description>
    </item>
    
    <item>
      <title>0046.permutations</title>
      <link>https://wncbb.github.io/posts/leetcode/0046.permutations/</link>
      <pubDate>Thu, 10 Dec 2020 13:21:18 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/0046.permutations/</guid>
      <description>1func permute(s []int) [][]int { 2	rst := make([][]int, 0) 3	// to judge if the value of this index has been visited 4	visited := make([]bool, len(s), len(s)) 5 6	var bs func(idx int, cur []int) 7 8	bs = func(idx int, cur []int) { 9	// satisfied 10	if idx == len(s) { 11	curRst := make([]int, len(cur), len(cur)) 12	copy(curRst, cur) 13	rst = append(rst, curRst) 14	return 15	} 16 17	for i := 0; i &amp;lt; len(s); i++ { 18	if visited[i] { 19	continue 20	} 21 22 // visit the value with index i 23	visited[i] = true 24	cur = append(cur, s[i]) 25	26	bs(idx+1, cur) 27	28	// restore the context 29	visited[i] = false 30	cur = cur[:len(cur)-1] 31	} 32	} 33	34	// initialize the state 35	bs(0, make([]int, 0, len(s))) 36	return rst 37} </description>
    </item>
    
    <item>
      <title>0084.largest-rectangle-in-histogram</title>
      <link>https://wncbb.github.io/posts/leetcode/0084.largest-rectangle-in-histogram/</link>
      <pubDate>Sun, 23 Aug 2020 18:14:56 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/0084.largest-rectangle-in-histogram/</guid>
      <description>https://leetcode-cn.com/problems/largest-rectangle-in-histogram/
单调栈
1func largestRectangleArea(heights []int) int { 2	h:=make([]int, 0, len(heights)+2) 3	h=append(h, 0) 4	h=append(h, heights...) 5	h=append(h, 0) 6	// stack里存储的是单调递增的索引 7	stack:=make([]int, 0) 8	res:=0 9 10 // 遍历的是h，not heights 11	for i, v:=range h{ 12	for len(stack)!=0 &amp;amp;&amp;amp; h[stack[len(stack)-1]]&amp;gt;v{ 13	// 如果当前的值小于栈顶位置的元素，说明可以计算栈顶位置元素的矩形面积 14	t:=stack[len(stack)-1] 15	stack=stack[:len(stack)-1] 16	// 出栈之后，栈顶位置的元素为小于t位置的索引 17	left:=stack[len(stack)-1] 18	right:=i 19	// left是小于t的最左侧，right是小于t的最右侧, 1xxx5, 比如计算xxx的长度,5-1=4,需要再减一个1 20	res=getMaxInt(res, (right-left-1)*h[t]) 21	} 22	stack=append(stack, i) 23	} 24 25	return res 26} 27 28func getMaxInt(a, b int)int{ 29	if a&amp;gt;b{ 30	return a 31	} 32	return b 33} </description>
    </item>
    
    <item>
      <title>Sliding_window</title>
      <link>https://wncbb.github.io/posts/algo/sliding_window/</link>
      <pubDate>Thu, 23 Jul 2020 11:05:24 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/algo/sliding_window/</guid>
      <description>https://lucifer.ren/blog/2020/03/16/slide-window/</description>
    </item>
    
    <item>
      <title>Mem</title>
      <link>https://wncbb.github.io/posts/golang/mem/</link>
      <pubDate>Fri, 19 Jun 2020 17:19:20 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/golang/mem/</guid>
      <description>https://deepu.tech/memory-management-in-golang/#:~:text=Go&amp;rsquo;s%20memory%20management%20involves%20automatic,is%20well%20optimized%20and%20efficient.
https://speakerdeck.com/deepu105/go-memory-allocation
https://blog.learngoprogramming.com/
https://www.bookstack.cn/read/For-learning-Go-Tutorial/
https://draveness.me/golang</description>
    </item>
    
    <item>
      <title>Tool</title>
      <link>https://wncbb.github.io/posts/golang/tool/</link>
      <pubDate>Fri, 19 Jun 2020 14:48:19 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/golang/tool/</guid>
      <description>Copy from: https://rakyll.org/go-tool-flags/ https://studygolang.com/articles/22803
go build -x Lists all the commands go build invokes.
go build -gcflags Used to pass flags to the Go compiler. go tool compile -help lists all the flags that can be passed to the compiler.
For example, to disable compiler optimizations and inlining, you can use the following the gcflags.
# -N disable optimizations # -m print optimization decisions # -l disable inlining # -race enable race detector go build/run -gcflags &amp;quot;&amp;lt;parameters&amp;gt;&amp;quot; main.</description>
    </item>
    
    <item>
      <title>Intro</title>
      <link>https://wncbb.github.io/posts/wrk2/intro/</link>
      <pubDate>Mon, 15 Jun 2020 21:10:28 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/wrk2/intro/</guid>
      <description>https://github.com/giltene/wrk2
wrk -t2 -c100 -d30s -R2000 http://127.0.0.1:8080/index.html # This runs a benchmark for 30 seconds, # using 2 threads, keeping 100 HTTP connections open, # and a constant throughput of 2000 requests per second # (total, across all connections combined).  With script
./wrk -c2 -t2 -L -R6 -d600s -s ./scripts/lookup.lua http://127.0.0.1:8080  </description>
    </item>
    
    <item>
      <title>Reverse_list</title>
      <link>https://wncbb.github.io/posts/algo/reverse_list/</link>
      <pubDate>Sun, 07 Jun 2020 18:34:55 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/algo/reverse_list/</guid>
      <description>1package main 2 3import ( 4	&amp;#34;fmt&amp;#34; 5) 6 7type ListNode struct { 8	Val int 9	Next *ListNode 10} 11 12func main() { 13	l := getList([]int{1, 2, 3, 4, 5, 6}) 14	printList(l) 15	l = reverseList(l) 16	printList(l) 17} 18 19func reverseList(l *ListNode) *ListNode { 20	var head *ListNode 21	var next *ListNode 22	cur := l 23	for cur != nil { 24	/* 25好记忆: 26A=B 27B=C 28C=D 29D=A 30*/ 31	// 保存下一个节点 32	next = cur.</description>
    </item>
    
    <item>
      <title>1</title>
      <link>https://wncbb.github.io/posts/leetcode/1/</link>
      <pubDate>Sun, 03 May 2020 21:07:02 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/1/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Backtrack</title>
      <link>https://wncbb.github.io/posts/algo/backtrack/</link>
      <pubDate>Sun, 03 May 2020 21:04:31 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/algo/backtrack/</guid>
      <description>result = [] def backtrack(路径, 选择列表): if 满足结束条件: result.add(路径) return for 选择 in 选择列表: 做选择 backtrack(路径, 选择列表(抠掉这次选择)) 撤销选择  </description>
    </item>
    
    <item>
      <title>Alien_dictionary</title>
      <link>https://wncbb.github.io/posts/algo/alien_dictionary/</link>
      <pubDate>Sun, 26 Apr 2020 11:56:22 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/algo/alien_dictionary/</guid>
      <description>1# -*- encoding: utf-8 -*- 2 3from heapq import heappush, heappop, heapify 4 5class Solution: 6 &amp;#34;&amp;#34;&amp;#34; 7@param board: A list of lists of character 8@param words: A list of string 9@return: A list of string 10&amp;#34;&amp;#34;&amp;#34; 11 def alienOrder(self, words): 12 # write your code here 13 # TODO: check params 14 graph=self.buildGraph(words) 15 print graph 16 17 # print graph 18 19 inDegree=self.buildInDegree(words, graph) 20 21 # print inDegree 22 23 q=[] 24 for i in inDegree: 25 if inDegree[i]==0: 26 q.</description>
    </item>
    
    <item>
      <title>Reservoir_sampling</title>
      <link>https://wncbb.github.io/posts/algo/reservoir_sampling/</link>
      <pubDate>Sat, 25 Apr 2020 14:59:29 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/algo/reservoir_sampling/</guid>
      <description>array result for i=0; i&amp;lt;n; i++{ if i&amp;lt;k{ result[i]=array[i] }else{ r=random(0, i) if r&amp;gt;=k{ continue } result[r]=array[i] } }  </description>
    </item>
    
    <item>
      <title>Union find</title>
      <link>https://wncbb.github.io/posts/algo/union_find/</link>
      <pubDate>Sat, 25 Apr 2020 14:40:38 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/algo/union_find/</guid>
      <description>1class UnionFindSet: 2 def __init__(self, n): 3 self.parents=[] 4 self.ranks=[] 5 for i in range(n): 6 self.parents.append(i) 7 self.ranks.append(0) 8 def connected(self, a, b): 9 return self.find(a)==self.find(b) 10 11 def find(self, x): 12 if x!=self.parents[x]: 13 self.parents[x]=self.find(self.parents[x]) 14 return self.parents[x] 15 16 def union(self, x, y): 17 px=self.find(x) 18 py=self.find(y) 19 # 谁大谁是爹 20 if self.ranks[px]&amp;gt;self.ranks[py]: 21 self.parents[py]=px 22 if self.ranks[px]&amp;lt;self.ranks[py]: 23 self.parents[px]=py 24 if self.ranks[px]==self.ranks[py]: 25 self.parents[py]=px 26 self.ranks[px]+=1 27 28 29t=UnionFindSet(5) 30print t.</description>
    </item>
    
    <item>
      <title>Heap</title>
      <link>https://wncbb.github.io/posts/algo/heap/</link>
      <pubDate>Fri, 24 Apr 2020 22:56:43 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/algo/heap/</guid>
      <description>1package main 2 3import ( 4	&amp;#34;fmt&amp;#34; 5) 6 7func parent(i int) int { 8	return (i - 1) / 2 9} 10 11func left(i int) int { 12	return i*2 + 1 13} 14 15func right(i int) int { 16	return i*2 + 2 17} 18 19func maxHeapify(a []int, i int) { 20	l := left(i) 21	r := right(i) 22	largestIdx := i 23	if l &amp;lt; len(a) &amp;amp;&amp;amp; a[largestIdx] &amp;lt; a[l] { 24	largestIdx = l 25	} 26	if r &amp;lt; len(a) &amp;amp;&amp;amp; a[largestIdx] &amp;lt; a[r] { 27	largestIdx = r 28	} 29 30	if largestIdx !</description>
    </item>
    
    <item>
      <title>Trie</title>
      <link>https://wncbb.github.io/posts/algo/trie/</link>
      <pubDate>Fri, 24 Apr 2020 22:54:49 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/algo/trie/</guid>
      <description>1import collections 2import json 3 4class TrieNode(object): 5 def __init__(self, value=0): 6 self.value = value 7 self.isWord = False 8 self.children = collections.OrderedDict() 9 10 @classmethod 11 def insert(cls, root, word): 12 p = root 13 for c in word: 14 child = p.children.get(c) 15 if not child: 16 child = TrieNode(c) 17 p.children[c] = child 18 p = child 19 20 p.isWord = True </description>
    </item>
    
    <item>
      <title>Merge Sort</title>
      <link>https://wncbb.github.io/posts/algo/merge_sort/</link>
      <pubDate>Wed, 22 Apr 2020 20:16:37 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/algo/merge_sort/</guid>
      <description>1package main 2 3import( 4	&amp;#34;fmt&amp;#34; 5) 6 7func merge(a, b []int)[]int{ 8	rst:=make([]int, 0, len(a)+len(b)) 9	i:=0 10	j:=0 11	for i&amp;lt;len(a) &amp;amp;&amp;amp; j&amp;lt;len(b){ 12	if a[i]&amp;lt;b[j]{ 13	rst=append(rst, a[i]) 14	i++ 15	}else{ 16	rst=append(rst, b[j]) 17	j++ 18	} 19	} 20	rst=append(rst, a[i:]...) 21	rst=append(rst, b[j:]...) 22	return rst 23} 24 25func mergeSort(s []int)[]int{ 26	if len(s)&amp;lt;=1{ 27	return s 28	} 29 30	middleIdx:=len(s)/2 31	left:=mergeSort(s[:middleIdx]) 32	right:=mergeSort(s[middleIdx:]) 33	return merge(left, right) 34} 35 36func main(){ 37	a:=[]int{3, 1, 0, 2, 9, 7, 6, 8, 5, 4} 38	b:=mergeSort(a) 39	fmt.</description>
    </item>
    
    <item>
      <title>Dlv</title>
      <link>https://wncbb.github.io/posts/golang/dlv/</link>
      <pubDate>Mon, 20 Jan 2020 19:44:06 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/golang/dlv/</guid>
      <description>dlv debug main.go list: list current codes s(step): step in stepout: step out n(next): move to next line(step over) args: break a/b/c.go:213 break pkg.GetName bp(breakpoints): list all break points c(continue): continue to next break point or the end  </description>
    </item>
    
    <item>
      <title>Quick Sort</title>
      <link>https://wncbb.github.io/posts/algo/quick_sort/</link>
      <pubDate>Sun, 19 Jan 2020 18:16:32 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/algo/quick_sort/</guid>
      <description>QuickSort(A, p, r) if p&amp;lt;r mid=Partition(A, p, r) QuickSort(A, p, mid-1) QuickSort(A, mid+1, r) Partition(A, p, r) x=A[r] i=p-1 for j=p to r-1 if A[j]&amp;lt;=x i=i+1 exchange A[i] with A[j] i=i+1 exchange A[i] with A[r] // r==j return i  </description>
    </item>
    
    <item>
      <title>DFS</title>
      <link>https://wncbb.github.io/posts/algo/dfs/</link>
      <pubDate>Sun, 19 Jan 2020 17:53:40 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/algo/dfs/</guid>
      <description>DFS(G) for each u in G.V u.color=WHITE u.parent=nil time=0 for each u in G.V if u.color==WHITE DFS-Visit(G, u) DFS-Visit(G, u) time=time+1 u.displayTime=time u.color=GRAY for each v in G.Adj[u] if v.color==WHITE v.parent=u DFS-Visit(G, v) u.color=BLACK time=time+1 u.finishTime=time  </description>
    </item>
    
    <item>
      <title>BFS</title>
      <link>https://wncbb.github.io/posts/algo/bfs/</link>
      <pubDate>Sun, 19 Jan 2020 17:41:20 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/algo/bfs/</guid>
      <description>WHITE: before join the queue GRAY: in the queue BLACK: pop from queue, and after visit all the children
BFS(G, s) for each u in (G.V-{s}) u.color=WHITE u.d=inf u.parent=nil s.color=GRAY s.d=0 s.parent=nil ENQUEUE(Q, s) while Q is not empty: u=DEQUEUE(Q) for each v in G.Adj(u) if v.color=WHITE v.color=GRAY v.d=u.d+1 v.parent=u ENQUEUE(Q, v) u.color=BLACK  </description>
    </item>
    
    <item>
      <title>Bellman Ford</title>
      <link>https://wncbb.github.io/posts/algo/bellman_ford/</link>
      <pubDate>Sun, 19 Jan 2020 15:45:10 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/algo/bellman_ford/</guid>
      <description>References:
 https://www.geeksforgeeks.org/bellman-ford-algorithm-dp-23/
从A出发是否存在到达各个节点的路径(有计算出值当然就可以到达)； 从A出发到达各个节点最短路径(时间最少、或者路径最少等) 图中是否存在负环路（权重之和为负数）   Example: k-flight
time: O(|V|*|E|)
1package main 2 3import ( 4	&amp;#34;fmt&amp;#34; 5	&amp;#34;math&amp;#34; 6) 7 8// Edge means the edge in graph 9type Edge struct { 10	src string 11	dst string 12	weight int 13} 14 15func bf(edges []Edge, fromV string) map[string]int { 16 // key为点，value为目前位置到达key点的距离，刚开始全是无限大 17	distMap := make(map[string]int, 0) 18	for _, v := range edges { 19	distMap[v.src] = math.</description>
    </item>
    
    <item>
      <title>Floyd</title>
      <link>https://wncbb.github.io/posts/algo/floyd/</link>
      <pubDate>Sun, 19 Jan 2020 15:42:53 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/algo/floyd/</guid>
      <description>1package main 2 3import ( 4	&amp;#34;fmt&amp;#34; 5	&amp;#34;math&amp;#34; 6) 7 8func f(m [][]int) [][]int { 9	v := len(m) 10	dist := make([][]int, v, v) 11	for i := 0; i &amp;lt; v; i++ { 12	dist[i] = make([]int, v, v) 13	} 14	for i := 0; i &amp;lt; v; i++ { 15	for j := 0; j &amp;lt; v; j++ { 16	dist[i][j] = m[i][j] 17	} 18	} 19 20	for k := 0; k &amp;lt; v; k++ { 21	for i := 0; i &amp;lt; v; i++ { 22	for j := 0; j &amp;lt; v; j++ { 23	newMinForIJ := dist[i][k] + dist[k][j] 24	if newMinForIJ &amp;lt; dist[i][j] { 25	dist[i][j] = newMinForIJ 26	} 27	} 28	} 29	} 30	return dist 31} 32 33func main() { 34	// a b c d 35	// 0 1 2 3 36	// a 0 0 1 6 10 37	// b 1 na 0 2 na 38	// c 2 na na 0 5 39	// d 3 na na na 0 40	m := [][]int{ 41	{0, 1, 6, 10}, 42	{math.</description>
    </item>
    
    <item>
      <title>dijkstra</title>
      <link>https://wncbb.github.io/posts/algo/dijkstra/</link>
      <pubDate>Sun, 19 Jan 2020 15:05:01 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/algo/dijkstra/</guid>
      <description>可以处理有环 无法处理包含有负数权值的边的图 (dijkastra是中间可以确定一部分点的最短距离，后面如果可以加上一个负数，那前面的确定的就不对了)  1from collections import defaultdict 2from heapq import * 3 4def dijkstra(edges, fromV, toV): 5 g=defaultdict(list) 6 for src, dst, cost in edges: 7 g[src].append((cost, dst)) 8 9 q, seen, mins=[(0, fromV, [])], set(), {fromV: 0} 10 while q: 11 (cost, src, path)=heappop(q) 12 if src not in seen: 13 seen.add(src) 14 path.append(src) 15 if src==toV: 16 return (cost, path) 17 for w, dst in g.get(src, []): 18 if dst in seen: 19 continue 20 oldCostForDst=mins.</description>
    </item>
    
    <item>
      <title>Common</title>
      <link>https://wncbb.github.io/posts/docker/common/</link>
      <pubDate>Fri, 15 Nov 2019 15:48:28 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/docker/common/</guid>
      <description>docker ps docker ps -a docker container ls docker container ls -a docker container prune docker run -p 8501:8501 \ --mount type=bind,\ source=/tmp/tfserving/serving/tensorflow_serving/servables/tensorflow/testdata/saved_model_half_plus_two_cpu,\ target=/models/half_plus_two \ -e MODEL_NAME=half_plus_two -t tensorflow/serving &amp;amp;  </description>
    </item>
    
    <item>
      <title>Volume</title>
      <link>https://wncbb.github.io/posts/docker/volume/</link>
      <pubDate>Fri, 15 Nov 2019 15:41:03 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/docker/volume/</guid>
      <description>docker volume create &amp;lt;volume name&amp;gt; docker volume ls docker volume inspect &amp;lt;volume name&amp;gt;  </description>
    </item>
    
    <item>
      <title>Serving_1</title>
      <link>https://wncbb.github.io/posts/tensorflow/serving_1/</link>
      <pubDate>Fri, 15 Nov 2019 14:34:39 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/tensorflow/serving_1/</guid>
      <description> Install tensorflow https://docs.python.org/3/library/venv.html
python3 -m venv &amp;lt;path&amp;gt; source &amp;lt;path&amp;gt;/bin/activate pip install tensorflow==&amp;lt;version&amp;gt;  Use tensorflow/serving git: https://github.com/tensorflow/serving
doc: https://www.tensorflow.org/tfx/serving/docker
Multi Version(hot reload), Multi Model(cold reload) docker run -t --rm -p 8501:8501 \ -v &amp;quot;$TESTDATA:/models&amp;quot; -d \ -t tensorflow/serving --model_config_file=/models/models.config  models.config
model_config_list:{ config:{ name:&amp;quot;hello-world&amp;quot;, base_path:&amp;quot;/models/hello-world&amp;quot;, model_platform:&amp;quot;tensorflow&amp;quot;, model_version_policy:{ all:{} } }, config:{ name:&amp;quot;modelA&amp;quot;, base_path:&amp;quot;/models/modelA&amp;quot;, model_platform:&amp;quot;tensorflow&amp;quot;, model_version_policy:{ all:{} } } }  </description>
    </item>
    
    <item>
      <title>Slice_1</title>
      <link>https://wncbb.github.io/posts/golang/slice_1/</link>
      <pubDate>Thu, 07 Nov 2019 22:06:32 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/golang/slice_1/</guid>
      <description>The struct of slice in go: 1type slice struct { 2	array unsafe.Pointer 3	len int 4	cap int 5}
1package main 2 3import &amp;#34;fmt&amp;#34; 4 5func main() { 6	a := make([]int, 10, 20) 7	for i := 0; i &amp;lt; 10; i = i + 1 { 8	a[i] = i 9	} 10 11	// means the length of b is 6-3=3, the capicity is 9-3=6 12	b := a[3:6:9] 13	// len(b)=3 14	fmt.</description>
    </item>
    
    <item>
      <title>How to create hugo site</title>
      <link>https://wncbb.github.io/posts/how_to_create/</link>
      <pubDate>Sat, 06 Oct 2018 18:52:24 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/how_to_create/</guid>
      <description>0x00 basic commands 1go get -u -v github.com/spf13/hugo 2hugo new site &amp;lt;directory&amp;gt; 3git init 4git submodule add https://github.com/spf13/hyde.git themes/hyde 5hugo new posts/how-to-create.md 0x01 config.toml 1baseURL = &amp;#34;http://wncbb.github.io/&amp;#34; 2languageCode = &amp;#34;en-us&amp;#34; 3title = &amp;#34;WNCBB&amp;#39;s blog&amp;#34; 4theme = &amp;#34;hyde&amp;#34; 5 6[Menus] 7 main = [ 8 {Name = &amp;#34;Github&amp;#34;, URL = &amp;#34;https://github.com/wncbb/&amp;#34;}, 9 ] 10[params] 11 description = &amp;#34;A man is only as good as what he loves&amp;#34; 12 themeColor = &amp;#34;theme-base-0c&amp;#34; 13 layoutReverse = true 0x02 codes highlight https://gohugo.</description>
    </item>
    
  </channel>
</rss>