<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>WNCBB&#39;s blog</title>
    <link>https://wncbb.github.io/</link>
    <description>Recent content on WNCBB&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 14 Dec 2020 16:47:32 +0800</lastBuildDate>
    
	<atom:link href="https://wncbb.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>0076.minimum-window-substring</title>
      <link>https://wncbb.github.io/posts/leetcode/0076.minimum-window-substring/</link>
      <pubDate>Mon, 14 Dec 2020 16:47:32 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/0076.minimum-window-substring/</guid>
      <description>滑动窗口逻辑： 声明俩变量left right初始化为0 1. 右边界往右遍历，符合条件后， 2. 左边界往右遍历，直到不符合条件，再跳到1 期间符合条件时，更新下当前的最优解  1func minWindow(s string, t string) string { 2	retLeft := 0 3	retRight := len(s) + 100 4	left := 0 5	right := 0 6	// 记录t中，byte到个数的map 7	visited := make(map[byte]int) 8	// 实时记录，当前left到right之间的t中字符，byte到个数的映射 9	curVisited := make(map[byte]int) 10	curFitNum := 0 11	tBytes := []byte(t) 12	for _, v := range tBytes { 13	visited[v] += 1 14	} 15	for _, v := range tBytes { 16	curVisited[v] = 0 17	} 18	// t中unique的字符个数 19	fitNum := len(visited) 20	for right &amp;lt; len(s) { 21	// 遍历右边，并处理curVisited, curFitNum等中间记录当前状态的变量 22	curRightByte := s[right] 23	if _, ok := curVisited[curRightByte]; ok { 24	curVisited[curRightByte]++ 25	if curVisited[curRightByte] == visited[curRightByte] { 26	curFitNum++ 27	} 28	} 29	right++ 30 31	for left &amp;lt;= right &amp;amp;&amp;amp; curFitNum == fitNum { 32	// 当left在合法范围内，且当前符合条件时 33	// 检查下是否更新返回值 34	if right-left &amp;lt; retRight-retLeft { 35	retRight = right 36	retLeft = left 37	} 38 39 // 去掉left的字符后，处理curVisited, curFitNum等中间记录当前状态的变量 40	curLeftByte := s[left] 41	if v, ok := curVisited[curLeftByte]; ok { 42	if v == visited[curLeftByte] { 43	curFitNum-- 44	} 45	curVisited[curLeftByte]-- 46 47	} 48	left++ 49	} 50	} 51	if retRight &amp;gt; len(s) { 52	return &amp;#34;&amp;#34; 53	} 54	return s[retLeft:retRight] 55} </description>
    </item>
    
    <item>
      <title>0042.rapping-rain-water</title>
      <link>https://wncbb.github.io/posts/leetcode/0042.trapping-rain-water/</link>
      <pubDate>Thu, 10 Dec 2020 19:03:01 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/0042.trapping-rain-water/</guid>
      <description>1func trap(height []int) int { 2	rst := 0 3	stack := make([]int, 0) 4	for i := 0; i &amp;lt; len(height); i++ { 5	for !stackIsEmpty(stack) &amp;amp;&amp;amp; height[stackPeek(stack)] &amp;lt; height[i] { 6	// height = [3, 2, 1, 0] 7	// stack= index(value) 0(3) 1(2) 2(1) 3(0) height[i]=4 8	// 这个时候，处理对象是stack里的3(0)，3(0)的左边比他高的最近的是2，3(0)的右边比他高的最近的是i(4) 9	var curIdx int 10	stack, curIdx = stackPop(stack) 11	if !stackIsEmpty(stack) { 12	rst = rst + (i-stackPeek(stack)-1)*(getMin(height[stackPeek(stack)], height[i])-height[curIdx]) 13	} 14	} 15	// 当前元素无论如何会入栈 16	stack = stackPush(stack, i) 17	} 18	return rst 19} 20func stackPush(stack []int, v int) []int { 21	stack = append(stack, v) 22	return stack 23} 24 25func stackIsEmpty(stack []int) bool { 26	return len(stack) == 0 27} 28 29func stackPeek(stack []int) int { 30	if stackIsEmpty(stack) { 31	return 0 32	} 33	return stack[len(stack)-1] 34} 35 36func stackPop(stack []int) ([]int, int) { 37	if stackIsEmpty(stack) { 38	return stack, 0 39	} 40	rst := stack[len(stack)-1] 41	stack = stack[:len(stack)-1] 42	return stack, rst 43} 44 45func getMin(a, b int) int { 46	if a &amp;lt; b { 47	return a 48	} 49	return b 50} </description>
    </item>
    
    <item>
      <title>0053.maximum-subarra</title>
      <link>https://wncbb.github.io/posts/leetcode/0053.maximum-subarra/</link>
      <pubDate>Thu, 10 Dec 2020 16:33:51 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/0053.maximum-subarra/</guid>
      <description>1func maxSubArray(nums []int) int { 2	if len(nums) == 0 { 3	return 0 4	} 5	// dp[i]表示以i结尾的和 6	dp := make([]int, len(nums), len(nums)) 7	dp[0] = nums[0] 8	rst := nums[0] 9	for i := 1; i &amp;lt; len(nums); i++ { 10	// 对于以i结尾的连续数组，要么就他自己，要么他自己加上以i-1为结尾的最大值 11	dp[i] = max(nums[i], nums[i]+dp[i-1]) 12	if dp[i] &amp;gt; rst { 13	rst = dp[i] 14	} 15	} 16 17	return rst 18} 19 20func max(a, b int) int { 21	if a &amp;gt; b { 22	return a 23	} 24	return b 25} </description>
    </item>
    
    <item>
      <title>0041.first-missing-positive</title>
      <link>https://wncbb.github.io/posts/leetcode/0041.first-missing-positive/</link>
      <pubDate>Thu, 10 Dec 2020 16:17:11 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/0041.first-missing-positive/</guid>
      <description>1func firstMissingPositive(nums []int) int { 2	for i, _ := range nums { 3	if nums[i] &amp;lt;= 0 { 4	nums[i] = len(nums) + 1 5	} 6	} 7	8	for i, _ := range nums { 9	// abs(nums[i]) 10	// is for 3, 4, -1, 1 11	// otherwise 12	// after checking negative, would be 3, 4, 5, 1 13	// after this lookp, would be 3, 4, -5, -1 14	// then 1 would be returned 15	// the reason is that the last value 1 is set to negative 16	// so we need to ignore negative, just use abs value 17	cur := abs(nums[i]) 18	// nums[cur-1] &amp;gt; 0 19	// is for 1, 1 20	// otherwise 21	// after checking ne4tative, would be 1, 1 22	// after this lookup, would be -1, 1, then 1, 1 23	// the zero index was set two times, and -1*-1=1 24	// so for one index, we only need to set one time 25	if cur &amp;gt; 0 &amp;amp;&amp;amp; cur &amp;lt; len(nums)+1 &amp;amp;&amp;amp; nums[cur-1] &amp;gt; 0 { 26	nums[cur-1] *= -1 27	} 28	} 29 30	for i, _ := range nums { 31	if nums[i] &amp;gt; 0 { 32	return i + 1 33	} 34	} 35 36	return len(nums) + 1 37} 38 39func abs(a int) int { 40	if a &amp;lt; 0 { 41	a *= -1 42	} 43	return a 44} </description>
    </item>
    
    <item>
      <title>0051.n-queens</title>
      <link>https://wncbb.github.io/posts/leetcode/0051.n-queens/</link>
      <pubDate>Thu, 10 Dec 2020 15:34:43 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/0051.n-queens/</guid>
      <description>1func solveNQueens(n int) [][]string { 2	rst := make([][]string, 0) 3	4	// initialize chess 5	chess := make([][]byte, 0, n) 6	for i := 0; i &amp;lt; n; i++ { 7	chess = append(chess, getLine(n)) 8	} 9 10	var bs func(row int) 11	bs = func(row int) { 12	if row == n { 13	rst = append(rst, getRst(chess)) 14	return 15	} 16	for col := 0; col &amp;lt; n; col++ { 17	// if location with row and col can not add a Q 18	// then just continue 19	if !</description>
    </item>
    
    <item>
      <title>Reset</title>
      <link>https://wncbb.github.io/posts/git/reset/</link>
      <pubDate>Thu, 10 Dec 2020 14:05:18 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/git/reset/</guid>
      <description>https://ndpsoftware.com/git-cheatsheet.html
// 取消上一次提交，且代码不要了 git reset --hard HEAD^1 // 取消上一次提交，代码在add状态 git reset --soft HEAD^1 // 取消add状态 git reset git reset &amp;lt;file&amp;gt;  </description>
    </item>
    
    <item>
      <title>0056.merge-intervals</title>
      <link>https://wncbb.github.io/posts/leetcode/0056.merge-intervals/</link>
      <pubDate>Thu, 10 Dec 2020 13:44:21 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/0056.merge-intervals/</guid>
      <description>1func merge(intervals [][]int) [][]int { 2	if len(intervals) == 0 { 3	return [][]int{} 4	} 5	if len(intervals) == 1 { 6	return intervals 7	} 8	// need to sort by the start value 9	sort.Slice(intervals, func(i, j int) bool { 10	return intervals[i][0] &amp;lt; intervals[j][0] 11	}) 12	rst := make([][]int, 0) 13	cur := intervals[0] 14	for i := 1; i &amp;lt; len(intervals); i++ { 15	if intervals[i][0] &amp;lt;= cur[1] { 16	// cur = [1, 3] intervals[i]=[2, 5] 17	// 对于这种，需要合并，合并后开始还是cur[0], cur[1]=两个结束值的最大值 18	cur[1] = getMaxInt(cur[1], intervals[i][1]) 19	} else { 20	// cur = [1, 3] intervals[i]=[4, 5] 21	rst = append(rst, cur) 22	cur = intervals[i] 23	} 24	} 25 26	rst = append(rst, cur) 27	return rst 28 29} 30 31func getMaxInt(a, b int) int { 32	if a &amp;gt; b { 33	return a 34	} 35	return b 36} </description>
    </item>
    
    <item>
      <title>0047.permutations_II</title>
      <link>https://wncbb.github.io/posts/leetcode/0047.permutations-ii/</link>
      <pubDate>Thu, 10 Dec 2020 13:31:12 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/0047.permutations-ii/</guid>
      <description>1func permuteUnique(s []int) [][]int { 2 // need to sort the s first, so it&amp;#39;s easy for us to skip the duplicated value 3	sort.Ints(s) 4	rst := make([][]int, 0) 5	visited := make([]bool, len(s), len(s)) 6 7	var bs func(idx int, cur []int) 8 9	bs = func(idx int, cur []int) { 10	if idx == len(s) { 11	curRst := make([]int, len(cur), len(cur)) 12	copy(curRst, cur) 13	rst = append(rst, curRst) 14	return 15	} 16 17	for i := 0; i &amp;lt; len(s); i++ { 18	if visited[i] { 19	continue 20	} 21	// s[i]==s[i-1] means the value with last idx equals current value 22	// 23	// i-1 is in front of i 24	// so i-1 must have been handled before i 25	// and visited[i-1]==false means the result of this value has been added to rst 26	// then deleting i-1 from current result and hanlde i 27	if i &amp;gt; 0 &amp;amp;&amp;amp; s[i] == s[i-1] &amp;amp;&amp;amp; !</description>
    </item>
    
    <item>
      <title>0046.permutations</title>
      <link>https://wncbb.github.io/posts/leetcode/0046.permutations/</link>
      <pubDate>Thu, 10 Dec 2020 13:21:18 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/0046.permutations/</guid>
      <description>1func permute(s []int) [][]int { 2	rst := make([][]int, 0) 3	// to judge if the value of this index has been visited 4	visited := make([]bool, len(s), len(s)) 5 6	var bs func(idx int, cur []int) 7 8	bs = func(idx int, cur []int) { 9	// satisfied 10	if idx == len(s) { 11	curRst := make([]int, len(cur), len(cur)) 12	copy(curRst, cur) 13	rst = append(rst, curRst) 14	return 15	} 16 17	for i := 0; i &amp;lt; len(s); i++ { 18	if visited[i] { 19	continue 20	} 21 22 // visit the value with index i 23	visited[i] = true 24	cur = append(cur, s[i]) 25	26	bs(idx+1, cur) 27	28	// restore the context 29	visited[i] = false 30	cur = cur[:len(cur)-1] 31	} 32	} 33	34	// initialize the state 35	bs(0, make([]int, 0, len(s))) 36	return rst 37} </description>
    </item>
    
    <item>
      <title>0084.largest-rectangle-in-histogram</title>
      <link>https://wncbb.github.io/posts/leetcode/0084.largest-rectangle-in-histogram/</link>
      <pubDate>Sun, 23 Aug 2020 18:14:56 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/0084.largest-rectangle-in-histogram/</guid>
      <description>https://leetcode-cn.com/problems/largest-rectangle-in-histogram/
单调栈
1func largestRectangleArea(heights []int) int { 2	h:=make([]int, 0, len(heights)+2) 3	h=append(h, 0) 4	h=append(h, heights...) 5	h=append(h, 0) 6	// stack里存储的是单调递增的索引 7	stack:=make([]int, 0) 8	res:=0 9 10 // 遍历的是h，not heights 11	for i, v:=range h{ 12	for len(stack)!=0 &amp;amp;&amp;amp; h[stack[len(stack)-1]]&amp;gt;v{ 13	// 如果当前的值小于栈顶位置的元素，说明可以计算栈顶位置元素的矩形面积 14	t:=stack[len(stack)-1] 15	stack=stack[:len(stack)-1] 16	// 出栈之后，栈顶位置的元素为小于t位置的索引 17	left:=stack[len(stack)-1] 18	right:=i 19	// left是小于t的最左侧，right是小于t的最右侧, 1xxx5, 比如计算xxx的长度,5-1=4,需要再减一个1 20	res=getMaxInt(res, (right-left-1)*h[t]) 21	} 22	stack=append(stack, i) 23	} 24 25	return res 26} 27 28func getMaxInt(a, b int)int{ 29	if a&amp;gt;b{ 30	return a 31	} 32	return b 33} </description>
    </item>
    
    <item>
      <title>Sliding_window</title>
      <link>https://wncbb.github.io/posts/algo/sliding_window/</link>
      <pubDate>Thu, 23 Jul 2020 11:05:24 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/algo/sliding_window/</guid>
      <description>https://lucifer.ren/blog/2020/03/16/slide-window/</description>
    </item>
    
    <item>
      <title>Mem</title>
      <link>https://wncbb.github.io/posts/golang/mem/</link>
      <pubDate>Fri, 19 Jun 2020 17:19:20 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/golang/mem/</guid>
      <description>https://deepu.tech/memory-management-in-golang/#:~:text=Go&amp;rsquo;s%20memory%20management%20involves%20automatic,is%20well%20optimized%20and%20efficient.
https://speakerdeck.com/deepu105/go-memory-allocation
https://blog.learngoprogramming.com/
https://www.bookstack.cn/read/For-learning-Go-Tutorial/
https://draveness.me/golang</description>
    </item>
    
    <item>
      <title>Tool</title>
      <link>https://wncbb.github.io/posts/golang/tool/</link>
      <pubDate>Fri, 19 Jun 2020 14:48:19 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/golang/tool/</guid>
      <description>Copy from: https://rakyll.org/go-tool-flags/ https://studygolang.com/articles/22803
go build -x Lists all the commands go build invokes.
go build -gcflags Used to pass flags to the Go compiler. go tool compile -help lists all the flags that can be passed to the compiler.
For example, to disable compiler optimizations and inlining, you can use the following the gcflags.
# -N disable optimizations # -m print optimization decisions # -l disable inlining # -race enable race detector go build/run -gcflags &amp;quot;&amp;lt;parameters&amp;gt;&amp;quot; main.</description>
    </item>
    
    <item>
      <title>Intro</title>
      <link>https://wncbb.github.io/posts/wrk2/intro/</link>
      <pubDate>Mon, 15 Jun 2020 21:10:28 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/wrk2/intro/</guid>
      <description>https://github.com/giltene/wrk2
wrk -t2 -c100 -d30s -R2000 http://127.0.0.1:8080/index.html # This runs a benchmark for 30 seconds, # using 2 threads, keeping 100 HTTP connections open, # and a constant throughput of 2000 requests per second # (total, across all connections combined).  With script
./wrk -c2 -t2 -L -R6 -d600s -s ./scripts/lookup.lua http://127.0.0.1:8080  </description>
    </item>
    
    <item>
      <title>Reverse_list</title>
      <link>https://wncbb.github.io/posts/algo/reverse_list/</link>
      <pubDate>Sun, 07 Jun 2020 18:34:55 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/algo/reverse_list/</guid>
      <description>1package main 2 3import ( 4	&amp;#34;fmt&amp;#34; 5) 6 7type ListNode struct { 8	Val int 9	Next *ListNode 10} 11 12func main() { 13	l := getList([]int{1, 2, 3, 4, 5, 6}) 14	printList(l) 15	l = reverseList(l) 16	printList(l) 17} 18 19func reverseList(l *ListNode) *ListNode { 20	var head *ListNode 21	var next *ListNode 22	cur := l 23	for cur != nil { 24	// 保存下一个节点 25	next = cur.</description>
    </item>
    
    <item>
      <title>1</title>
      <link>https://wncbb.github.io/posts/leetcode/1/</link>
      <pubDate>Sun, 03 May 2020 21:07:02 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/leetcode/1/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Backtrack</title>
      <link>https://wncbb.github.io/posts/algo/backtrack/</link>
      <pubDate>Sun, 03 May 2020 21:04:31 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/algo/backtrack/</guid>
      <description>result = [] def backtrack(路径, 选择列表): if 满足结束条件: result.add(路径) return for 选择 in 选择列表: 做选择 backtrack(路径, 选择列表(抠掉这次选择)) 撤销选择  </description>
    </item>
    
    <item>
      <title>Alien_dictionary</title>
      <link>https://wncbb.github.io/posts/algo/alien_dictionary/</link>
      <pubDate>Sun, 26 Apr 2020 11:56:22 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/algo/alien_dictionary/</guid>
      <description>1# -*- encoding: utf-8 -*- 2 3from heapq import heappush, heappop, heapify 4 5class Solution: 6 &amp;#34;&amp;#34;&amp;#34; 7@param board: A list of lists of character 8@param words: A list of string 9@return: A list of string 10&amp;#34;&amp;#34;&amp;#34; 11 def alienOrder(self, words): 12 # write your code here 13 # TODO: check params 14 graph=self.buildGraph(words) 15 print graph 16 17 # print graph 18 19 inDegree=self.buildInDegree(words, graph) 20 21 # print inDegree 22 23 q=[] 24 for i in inDegree: 25 if inDegree[i]==0: 26 q.</description>
    </item>
    
    <item>
      <title>Reservoir_sampling</title>
      <link>https://wncbb.github.io/posts/algo/reservoir_sampling/</link>
      <pubDate>Sat, 25 Apr 2020 14:59:29 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/algo/reservoir_sampling/</guid>
      <description>array result for i=0; i&amp;lt;n; i++{ if i&amp;lt;k{ result&amp;lt;-array[i] }else{ r=random(0, i) if r&amp;gt;=k{ continue } array[r]=array[i] } }  </description>
    </item>
    
    <item>
      <title>Union find</title>
      <link>https://wncbb.github.io/posts/algo/union_find/</link>
      <pubDate>Sat, 25 Apr 2020 14:40:38 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/algo/union_find/</guid>
      <description>1class UnionFindSet: 2 def __init__(self, n): 3 self.parents=[] 4 self.ranks=[] 5 for i in range(n): 6 self.parents.append(i) 7 self.ranks.append(0) 8 def connected(self, a, b): 9 return self.find(a)==self.find(b) 10 11 def find(self, x): 12 if x!=self.parents[x]: 13 self.parents[x]=self.find(self.parents[x]) 14 return self.parents[x] 15 16 def union(self, x, y): 17 px=self.find(x) 18 py=self.find(y) 19 if self.ranks[px]&amp;gt;self.ranks[py]: 20 self.parents[py]=px 21 if self.ranks[px]&amp;lt;self.ranks[py]: 22 self.parents[px]=py 23 if self.ranks[px]==self.ranks[py]: 24 self.parents[py]=px 25 self.ranks[px]+=1 26 27 28t=UnionFindSet(5) 29print t.</description>
    </item>
    
    <item>
      <title>Heap</title>
      <link>https://wncbb.github.io/posts/algo/heap/</link>
      <pubDate>Fri, 24 Apr 2020 22:56:43 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/algo/heap/</guid>
      <description>1package main 2 3import ( 4	&amp;#34;fmt&amp;#34; 5) 6 7func parent(i int) int { 8	return (i - 1) / 2 9} 10 11func left(i int) int { 12	return i*2 + 1 13} 14 15func right(i int) int { 16	return i*2 + 2 17} 18 19func maxHeapify(a []int, i int) { 20	l := left(i) 21	r := right(i) 22	largestIdx := i 23	if l &amp;lt; len(a) &amp;amp;&amp;amp; a[l] &amp;gt; a[i] { 24	largestIdx = l 25	} 26	if r &amp;lt; len(a) &amp;amp;&amp;amp; a[r] &amp;gt; a[largestIdx] { 27	largestIdx = r 28	} 29 30	if largestIdx !</description>
    </item>
    
    <item>
      <title>Trie</title>
      <link>https://wncbb.github.io/posts/algo/trie/</link>
      <pubDate>Fri, 24 Apr 2020 22:54:49 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/algo/trie/</guid>
      <description>1import collections 2import json 3 4class TrieNode(object): 5 def __init__(self, value=0): 6 self.value = value 7 self.isWord = False 8 self.children = collections.OrderedDict() 9 10 @classmethod 11 def insert(cls, root, word): 12 p = root 13 for c in word: 14 child = p.children.get(c) 15 if not child: 16 child = TrieNode(c) 17 p.children[c] = child 18 p = child 19 20 p.isWord = True </description>
    </item>
    
    <item>
      <title>Merge Sort</title>
      <link>https://wncbb.github.io/posts/algo/merge_sort/</link>
      <pubDate>Wed, 22 Apr 2020 20:16:37 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/algo/merge_sort/</guid>
      <description>1package main 2 3import( 4	&amp;#34;fmt&amp;#34; 5) 6 7func merge(a, b []int)[]int{ 8	rst:=make([]int, 0, len(a)+len(b)) 9	i:=0 10	j:=0 11	for i&amp;lt;len(a) &amp;amp;&amp;amp; j&amp;lt;len(b){ 12	if a[i]&amp;lt;b[j]{ 13	rst=append(rst, a[i]) 14	i++ 15	}else{ 16	rst=append(rst, b[j]) 17	j++ 18	} 19	} 20	rst=append(rst, a[i:]...) 21	rst=append(rst, b[j:]...) 22	return rst 23} 24 25func mergeSort(s []int)[]int{ 26	if len(s)&amp;lt;=1{ 27	return s 28	} 29 30	middleIdx:=len(s)/2 31	left:=mergeSort(s[:middleIdx]) 32	right:=mergeSort(s[middleIdx:]) 33	return merge(left, right) 34} 35 36func main(){ 37	a:=[]int{3, 1, 0, 2, 9, 7, 6, 8, 5, 4} 38	b:=mergeSort(a) 39	fmt.</description>
    </item>
    
    <item>
      <title>Dlv</title>
      <link>https://wncbb.github.io/posts/golang/dlv/</link>
      <pubDate>Mon, 20 Jan 2020 19:44:06 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/golang/dlv/</guid>
      <description>dlv debug main.go list: list current codes s(step): step in stepout: step out n(next): move to next line(step over) args: break a/b/c.go:213 break pkg.GetName bp(breakpoints): list all break points c(continue): continue to next break point or the end  </description>
    </item>
    
    <item>
      <title>Quick Sort</title>
      <link>https://wncbb.github.io/posts/algo/quick_sort/</link>
      <pubDate>Sun, 19 Jan 2020 18:16:32 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/algo/quick_sort/</guid>
      <description>QuickSort(A, p, r) if p&amp;lt;r mid=Partition(A, p, r) QuickSort(A, p, mid-1) QuickSort(A, mid+1, r) Partition(A, p, r) x=A[r] i=p-1 for j=p to r-1 if A[j]&amp;lt;=x i=i+1 exchange A[i] with A[j] i=i+1 exchange A[i] with A[r] // r==j return i  </description>
    </item>
    
    <item>
      <title>DFS</title>
      <link>https://wncbb.github.io/posts/algo/dfs/</link>
      <pubDate>Sun, 19 Jan 2020 17:53:40 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/algo/dfs/</guid>
      <description>DFS(G) for each u in G.V u.color=WHITE u.parent=nil time=0 for each u in G.V if u.color==WHITE DFS-Visit(G, u) DFS-Visit(G, u) time=time+1 u.displayTime=time u.color=GRAY for each v in G.Adj[u] if v.color==WHITE v.parent=u DFS-Visit(G, v) u.color=BLACK time=time+1 u.finishTime=time  </description>
    </item>
    
    <item>
      <title>BFS</title>
      <link>https://wncbb.github.io/posts/algo/bfs/</link>
      <pubDate>Sun, 19 Jan 2020 17:41:20 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/algo/bfs/</guid>
      <description>WHITE: before join the queue GRAY: in the queue BLACK: pop from queue, and after visit all the children
BFS(G, s) for each u in (G.V-{s}) u.color=WHITE u.d=inf u.parent=nil s.color=GRAY s.d=0 s.parent=nil ENQUEUE(Q, s) while Q is not empty: u=DEQUEUE(Q) for each v in G.Adj(u) if v.color=WHITE v.color=GRAY v.d=u.d+1 v.parent=u ENQUEUE(Q, v) u.color=BLACK  </description>
    </item>
    
    <item>
      <title>Bellman Ford</title>
      <link>https://wncbb.github.io/posts/algo/bellman_ford/</link>
      <pubDate>Sun, 19 Jan 2020 15:45:10 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/algo/bellman_ford/</guid>
      <description>References:
 https://www.geeksforgeeks.org/bellman-ford-algorithm-dp-23/  Example: k-flight
time: O(|V|*|E|)
1package main 2 3import ( 4	&amp;#34;fmt&amp;#34; 5	&amp;#34;math&amp;#34; 6) 7 8// Edge means the edge in graph 9type Edge struct { 10	src string 11	dst string 12	weight int 13} 14 15func bf(edges []Edge, fromV string) map[string]int { 16 // key为点，value为目前位置到达key点的距离，刚开始全是无限大 17	distMap := make(map[string]int, 0) 18	for _, v := range edges { 19	distMap[v.src] = math.MaxInt32 20	distMap[v.dst] = math.</description>
    </item>
    
    <item>
      <title>Floyd</title>
      <link>https://wncbb.github.io/posts/algo/floyd/</link>
      <pubDate>Sun, 19 Jan 2020 15:42:53 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/algo/floyd/</guid>
      <description>1package main 2 3import ( 4	&amp;#34;fmt&amp;#34; 5	&amp;#34;math&amp;#34; 6) 7 8func f(m [][]int) [][]int { 9	v := len(m) 10	dist := make([][]int, v, v) 11	for i := 0; i &amp;lt; v; i++ { 12	dist[i] = make([]int, v, v) 13	} 14	for i := 0; i &amp;lt; v; i++ { 15	for j := 0; j &amp;lt; v; j++ { 16	dist[i][j] = m[i][j] 17	} 18	} 19 20	for k := 0; k &amp;lt; v; k++ { 21	for i := 0; i &amp;lt; v; i++ { 22	for j := 0; j &amp;lt; v; j++ { 23	newMinForIJ := dist[i][k] + dist[k][j] 24	if newMinForIJ &amp;lt; dist[i][j] { 25	dist[i][j] = newMinForIJ 26	} 27	} 28	} 29	} 30	return dist 31} 32 33func main() { 34	// a b c d 35	// 0 1 2 3 36	// a 0 0 1 6 10 37	// b 1 na 0 2 na 38	// c 2 na na 0 5 39	// d 3 na na na 0 40	m := [][]int{ 41	{0, 1, 6, 10}, 42	{math.</description>
    </item>
    
    <item>
      <title>dijkstra</title>
      <link>https://wncbb.github.io/posts/algo/dijkstra/</link>
      <pubDate>Sun, 19 Jan 2020 15:05:01 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/algo/dijkstra/</guid>
      <description>1from collections import defaultdict 2from heapq import * 3 4def dijkstra(edges, fromV, toV): 5 g=defaultdict(list) 6 for src, dst, cost in edges: 7 g[src].append((cost, dst)) 8 9 q, seen, mins=[(0, fromV, [])], set(), {fromV: 0} 10 while q: 11 (cost, src, path)=heappop(q) 12 if src not in seen: 13 seen.add(src) 14 path.append(src) 15 if src==toV: 16 return (cost, path) 17 for w, dst in g.get(src, []): 18 if dst in seen: 19 continue 20 oldCostForDst=mins.</description>
    </item>
    
    <item>
      <title>Common</title>
      <link>https://wncbb.github.io/posts/docker/common/</link>
      <pubDate>Fri, 15 Nov 2019 15:48:28 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/docker/common/</guid>
      <description>docker ps docker ps -a docker container ls docker container ls -a docker container prune docker run -p 8501:8501 \ --mount type=bind,\ source=/tmp/tfserving/serving/tensorflow_serving/servables/tensorflow/testdata/saved_model_half_plus_two_cpu,\ target=/models/half_plus_two \ -e MODEL_NAME=half_plus_two -t tensorflow/serving &amp;amp;  </description>
    </item>
    
    <item>
      <title>Volume</title>
      <link>https://wncbb.github.io/posts/docker/volume/</link>
      <pubDate>Fri, 15 Nov 2019 15:41:03 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/docker/volume/</guid>
      <description>docker volume create &amp;lt;volume name&amp;gt; docker volume ls docker volume inspect &amp;lt;volume name&amp;gt;  </description>
    </item>
    
    <item>
      <title>Serving_1</title>
      <link>https://wncbb.github.io/posts/tensorflow/serving_1/</link>
      <pubDate>Fri, 15 Nov 2019 14:34:39 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/tensorflow/serving_1/</guid>
      <description> Install tensorflow https://docs.python.org/3/library/venv.html
python3 -m venv &amp;lt;path&amp;gt; source &amp;lt;path&amp;gt;/bin/activate pip install tensorflow==&amp;lt;version&amp;gt;  Use tensorflow/serving git: https://github.com/tensorflow/serving
doc: https://www.tensorflow.org/tfx/serving/docker
Multi Version(hot reload), Multi Model(cold reload) docker run -t --rm -p 8501:8501 \ -v &amp;quot;$TESTDATA:/models&amp;quot; -d \ -t tensorflow/serving --model_config_file=/models/models.config  models.config
model_config_list:{ config:{ name:&amp;quot;hello-world&amp;quot;, base_path:&amp;quot;/models/hello-world&amp;quot;, model_platform:&amp;quot;tensorflow&amp;quot;, model_version_policy:{ all:{} } }, config:{ name:&amp;quot;modelA&amp;quot;, base_path:&amp;quot;/models/modelA&amp;quot;, model_platform:&amp;quot;tensorflow&amp;quot;, model_version_policy:{ all:{} } } }  </description>
    </item>
    
    <item>
      <title>Slice_1</title>
      <link>https://wncbb.github.io/posts/golang/slice_1/</link>
      <pubDate>Thu, 07 Nov 2019 22:06:32 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/golang/slice_1/</guid>
      <description>The struct of slice in go: 1type slice struct { 2	array unsafe.Pointer 3	len int 4	cap int 5}
1package main 2 3import &amp;#34;fmt&amp;#34; 4 5func main() { 6	a := make([]int, 10, 20) 7	for i := 0; i &amp;lt; 10; i = i + 1 { 8	a[i] = i 9	} 10 11	// means the length of b is 6-3=3, the capicity is 9-3=6 12	b := a[3:6:9] 13	// len(b)=3 14	fmt.</description>
    </item>
    
    <item>
      <title>How to create hugo site</title>
      <link>https://wncbb.github.io/posts/how_to_create/</link>
      <pubDate>Sat, 06 Oct 2018 18:52:24 +0800</pubDate>
      
      <guid>https://wncbb.github.io/posts/how_to_create/</guid>
      <description>0x00 basic commands 1go get -u -v github.com/spf13/hugo 2hugo new site &amp;lt;directory&amp;gt; 3git init 4git submodule add https://github.com/spf13/hyde.git themes/hyde 5hugo new posts/how-to-create.md 0x01 config.toml 1baseURL = &amp;#34;http://wncbb.github.io/&amp;#34; 2languageCode = &amp;#34;en-us&amp;#34; 3title = &amp;#34;WNCBB&amp;#39;s blog&amp;#34; 4theme = &amp;#34;hyde&amp;#34; 5 6[Menus] 7 main = [ 8 {Name = &amp;#34;Github&amp;#34;, URL = &amp;#34;https://github.com/wncbb/&amp;#34;}, 9 ] 10[params] 11 description = &amp;#34;A man is only as good as what he loves&amp;#34; 12 themeColor = &amp;#34;theme-base-0c&amp;#34; 13 layoutReverse = true 0x02 codes highlight https://gohugo.</description>
    </item>
    
  </channel>
</rss>