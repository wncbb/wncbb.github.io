<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>WNCBB&#39;s blog</title>
    <link>https://wncbb.github.io/</link>
    <description>Recent content on WNCBB&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 12 Jan 2022 11:20:33 +0800</lastBuildDate><atom:link href="https://wncbb.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>300_longest Increasing Subsequence</title>
      <link>https://wncbb.github.io/leetcode/300_longest-increasing-subsequence/</link>
      <pubDate>Wed, 12 Jan 2022 11:20:33 +0800</pubDate>
      
      <guid>https://wncbb.github.io/leetcode/300_longest-increasing-subsequence/</guid>
      <description>300. 最长递增子序列
解法一 动态规划 dp[i]标识，以s[i]结尾的，最长的递增子序列长度 dp[i]=Max(dp[j])+1 // 0&amp;lt;=j&amp;lt;i &amp;amp;&amp;amp; s[j]&amp;lt;s[i] func lengthOfLIS(nums []int) int { dp := make([]int, len(nums)) // 必须初始化为1，以nums[i]结尾的LIS最小长度也是1 	for i := range dp { dp[i] = 1 } for i := 1; i &amp;lt; len(nums); i++ { for j := 0; j &amp;lt; i; j++ { if nums[j] &amp;lt; nums[i] { dp[i] = getMax(dp[i], dp[j]+1) } } } ret := dp[0] for i := 1; i &amp;lt; len(dp); i++ { ret = getMax(ret, dp[i]) } return ret } func getMax(a, b int) int { if a &amp;gt; b { return a } return b } 解法二 二分查找 func lengthOfLIS(nums []int) int { // d[i]标识，长度为len(d[:i+1])的最长递增子序列的最后一个元素 	d := make([]int, 0) for _, v := range nums { // 如果len(d)==0, 那么直接把当前值放入数组  // 如果d[len(d)-1]&amp;lt;v, 比如说d[3]=10, v是11，  // 长度为3的最长递增子序列的最后一个元素是10，那么11正好可以拼接在这个长度为3的LIS后面，构成一个长度为4的LIS 	if len(d) == 0 || d[len(d)-1] &amp;lt; v { d = append(d, v) continue } // 在有序数组d中，找到第一个&amp;gt;=d的索引，因为题目要求LIS严格递增  // 如果d=[4, 10]，而没有等于条件，会返回idx=1，那么d=[4, 4]，那么长度为2的LIS的俩元素都是4，与题目不符合 	idx := firstGreaterOrEqualIndex(v, d) // 下面的逻辑不可能执行到，因为d[len(d)-1]一定大于等于v，否则会走到上面的逻辑  // 因此在d里面找大于等于v的数据，一定是能找到 	// if idx == -1 {  // // 如果找不到，举个例子,d=[4, 10], v=10,  // fmt.</description>
    </item>
    
    <item>
      <title>每日一题 2022_01_12</title>
      <link>https://wncbb.github.io/oneproblemperday/oppd_2022_01_12/</link>
      <pubDate>Wed, 12 Jan 2022 09:25:15 +0800</pubDate>
      
      <guid>https://wncbb.github.io/oneproblemperday/oppd_2022_01_12/</guid>
      <description>github-cn.com 334. 递增的三元子序列
func increasingTriplet(nums []int) bool { if len(nums)&amp;lt;3{ return false } first:=nums[0] second:=int(math.MaxInt64) for i:=1; i&amp;lt;len(nums); i++{ cur:=nums[i] if cur&amp;gt;second{ return true }else if cur&amp;gt;first{ second=cur }else{ // 这里只改first是可以的，下一次遍历过程中，如果cur进入&amp;#34;大于first&amp;#34;分支，那么second就会被修改掉  first=cur } } return false } leetcode.com 701. 二叉搜索树中的插入操作
/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func insertIntoBST(root *TreeNode, val int) *TreeNode { if root == nil { return &amp;amp;TreeNode{Val: val} } // 新的数据，不是插入左子树，就是插入右子树  p := root for p !</description>
    </item>
    
    <item>
      <title>每日一题 2022_01_11</title>
      <link>https://wncbb.github.io/oneproblemperday/oppd_2022_01_11/</link>
      <pubDate>Tue, 11 Jan 2022 09:33:13 +0800</pubDate>
      
      <guid>https://wncbb.github.io/oneproblemperday/oppd_2022_01_11/</guid>
      <description>leetcode-cn.com 1036.逃离大迷宫
最佳题解
type pair struct{ x, y int } var dirs = []pair{{-1, 0}, {1, 0}, {0, -1}, {0, 1}} // 因为表格很大，但是block不大，可以判断source/destination是否被block围起来，如果没有围起来，一定可以联通。 // 当然source destination被围在一起也可以  func isEscapePossible(block [][]int, source, target []int) bool { const ( blocked = -1 // 在包围圈中  valid = 0 // 不在包围圈中  found = 1 // 无论在不在包围圈中，但在 n(n-1)/2 步搜索的过程中经过了 target  boundary int = 1e6 ) n := len(block) if n &amp;lt; 2 { return true } blockSet := map[pair]bool{} for _, b := range block { blockSet[pair{b[0], b[1]}] = true } check := func(start, finish []int) int { sx, sy := start[0], start[1] fx, fy := finish[0], finish[1] // 对于n个block格子，能够围起来的空间最多是n*(n-1)/2  // 比如n=3  // .</description>
    </item>
    
    <item>
      <title>面试题 17.24. 最大子矩阵</title>
      <link>https://wncbb.github.io/leetcode/mst_1724_max_submatrix_lcci/</link>
      <pubDate>Tue, 11 Jan 2022 08:50:22 +0800</pubDate>
      
      <guid>https://wncbb.github.io/leetcode/mst_1724_max_submatrix_lcci/</guid>
      <description>面试题 17.24. 最大子矩阵
/* . . . . . . . . i . . . . j . . . . i，j为两行的索引，然后每一列数据做求和，得到一维数字 那么，就转变成了求一维数组的最大连续子序列和 */ func getMaxMatrix(matrix [][]int) []int { res:=make([]int,4) m:=len(matrix) n:=len(matrix[0]) total:=math.MinInt32 // i标识上边界 	for i:=0;i&amp;lt;m;i++{ // j标识下边界 	for j:=i;j&amp;lt;m;j++{ // 把上下边界内部的数据，按照列求和 	var sumColumn = make([]int,n) for k:=0;k&amp;lt;n;k++{ for u:=i;u&amp;lt;=j;u++{ sumColumn[k]+=matrix[u][k] } } // 求一维数字连续子序列和的最大值 	l,r,max:=searchMaxSubsequence(sumColumn) //fmt.Println(l,r,max)  if max&amp;gt;total{ total=max res=[]int{i,l,j,r} //fmt.Println(&amp;#34;res:&amp;#34;,res) 	} } } return res } func searchMaxSubsequence(sc []int )(left int,right int,max int ){ left,right=0,0 tmpbegin:=left max=sc[0] dpi:=sc[0] for i:=1;i&amp;lt;len(sc);i++{ if dpi&amp;gt;0{ dpi+=sc[i] }else{ dpi=sc[i] tmpbegin=i } if dpi&amp;gt;max{ max=dpi left=tmpbegin right=i } } return } </description>
    </item>
    
    <item>
      <title>ARC: Adaptive Replacement Cache</title>
      <link>https://wncbb.github.io/cache/arc/</link>
      <pubDate>Mon, 10 Jan 2022 19:49:48 +0800</pubDate>
      
      <guid>https://wncbb.github.io/cache/arc/</guid>
      <description>介绍 wiki地址
ARC是一种比LRU表现更好的缓存算法。该算法会综合利用recency与frequency以及两者最近逐出的数据，来做缓存逐出。
ARC会把cache directory分为两部分，T1与T2，分别对应recency与frequency。T1与T2分别对应两个ghost listB1与B2,分别存储T1与T2逐出的entry的key。
Ghost lists可以追踪最近那些被逐出的entry的是从recency还是frquency被逐出的，从而动态调整T1与T2的值。
T1: 存储LRU T2: 存储LFU B1: 存储从T1中逐出的entry B2: 存储从T2中逐出的entry
T1与B1结合起来是L1; T2与B2结合起来是L2.
整个L1与L2可以表示成如下所示的结构
. . . [ B1 &amp;lt;-[ T1 &amp;lt;-!-&amp;gt; T2 ]-&amp;gt; B2 ] . . [ . . . . [ . . . . . . ! . .^. . . . ] . . . . ] [ fixed cache size (c) ] 里面的中括号存储的数据，是实实在在的cache数据。T1与T2的整体的长度是固定长度size。可以在B1与B2之间移动。
L1是从右向左展示，比如!左侧的第一个数据，是LRU的最新的数据。 ^是期望的T1的长度，这个长度可以大于等于小于实际的长度。
进入T1的新的entry，会从!左侧加入，慢慢被push到left，最后会被驱除出T1,放到B1里，最后会被彻底删除。
如果L1里的数据，被再次访问，就会被加入到L2中。也就是!右侧第一个位置。如果L2中的数据被再次访问，会再次放到!右侧第一个位置。
被加入T1 T2的entry,会导致!慢慢向^靠近。如果在cache中已经没有空闲位置了，^会决定从T1里还是T2里驱逐entry。</description>
    </item>
    
    <item>
      <title>每日一题 2022_01_10</title>
      <link>https://wncbb.github.io/oneproblemperday/oppd_2022_01_10/</link>
      <pubDate>Mon, 10 Jan 2022 09:09:50 +0800</pubDate>
      
      <guid>https://wncbb.github.io/oneproblemperday/oppd_2022_01_10/</guid>
      <description>github-cn.com 306. 累加数
func addBinary(a string, b string) string { ans := &amp;#34;&amp;#34; carry := 0 lenA, lenB := len(a), len(b) n := max(lenA, lenB) for i := 0; i &amp;lt; n; i++ { if i &amp;lt; lenA { carry += int(a[lenA-i-1] - &amp;#39;0&amp;#39;) } if i &amp;lt; lenB { carry += int(b[lenB-i-1] - &amp;#39;0&amp;#39;) } // 这里ans放在后面，正好就是结果  ans = strconv.Itoa(carry%2) + ans carry /= 2 } // 最后需要查看下，是否有进位  if carry &amp;gt; 0 { ans = &amp;#34;1&amp;#34; + ans } return ans } func max(x, y int) int { if x &amp;gt; y { return x } return y } github.</description>
    </item>
    
    <item>
      <title>每日一题 2022_01_09</title>
      <link>https://wncbb.github.io/oneproblemperday/oppd_2022_01_09/</link>
      <pubDate>Sun, 09 Jan 2022 15:35:14 +0800</pubDate>
      
      <guid>https://wncbb.github.io/oneproblemperday/oppd_2022_01_09/</guid>
      <description>leetcode-cn.com 1629. 按键持续时间最长的键
keys_pressed: A B C D release_times: a b c d 求a, b-a, c-b, d-c的最大值对应的key(如果相同，采用字典序最大值) impl Solution { pub fn slowest_key(release_times: Vec&amp;lt;i32&amp;gt;, keys_pressed: String) -&amp;gt; char { let keys : Vec&amp;lt;char&amp;gt; = keys_pressed.chars().collect(); let mut max = release_times[0]; let mut key = keys[0]; let l = keys_pressed.len(); for i in 1..l { let t = release_times[i] - release_times[i - 1]; if t &amp;gt; max || (max == t &amp;amp;&amp;amp; key &amp;lt; keys[i]) { max = t; key = keys[i]; } } key } } leetcode.</description>
    </item>
    
    <item>
      <title>400.nth_digit</title>
      <link>https://wncbb.github.io/leetcode/400_nth_digit/</link>
      <pubDate>Sun, 09 Jan 2022 10:32:07 +0800</pubDate>
      
      <guid>https://wncbb.github.io/leetcode/400_nth_digit/</guid>
      <description>400.第 N 位数字
func findNthDigit(n int) int { // 题目计数是从1开始，代码里是从0开始  n=n-1 // 个位数 每个数值转化为字符串长度为1  // 两位数 每个数值转化为字符串长度为2  // len保存当前n位数的长度  curLen:=1 // first表示，从n里不停的减掉 一位数 两位数 。。。 个数，不够减得时候，  // 假设目前是n位数，标识n位数的第一个数  first:=1 count:=9 for n&amp;gt;curLen*count{ n=n-curLen*count curLen++ first*=10 count*=10 } // n-1是因为，计数都是从0开始计数  // 比如说，对于 1 2 3 4 5 6 7 8 9 10 查找第11个数字，是10的个位数0  // n先减去个位数的个数9, 11-9=2  // 然后确定第二个数在第几个二位数里  first+=n/curLen s:=fmt.Sprintf(&amp;#34;%d&amp;#34;, first) return int(s[n%curLen]-&amp;#39;0&amp;#39;) } </description>
    </item>
    
    <item>
      <title>每日一题 2022_01_08</title>
      <link>https://wncbb.github.io/oneproblemperday/oppd_2022_01_08/</link>
      <pubDate>Sat, 08 Jan 2022 22:14:50 +0800</pubDate>
      
      <guid>https://wncbb.github.io/oneproblemperday/oppd_2022_01_08/</guid>
      <description>leetcode-cn.com 89.格雷编码
最棒题解
1func grayCode(n int) []int { 2 // n=0时，就是一个数0 3 ans:=make([]int, 1, 1&amp;lt;&amp;lt;n) 4 // a=上一行的数据 5 // b=上一行的数据翻转，然后每个元素前面加1(比如10， 变成110) 6 // 这一行的数据=a+b(数组连接) 7 // curRow=prevRow+Reverse(prevRow).map(v=&amp;gt;v+head) 8 head:=1 9 for i:=0; i&amp;lt;n; i++{ 10 for j:=len(ans)-1; j&amp;gt;=0; j--{ 11 ans=append(ans, head+ans[j]) 12 } 13 head=head&amp;lt;&amp;lt;1 14 } 15 return ans 16} leetcode.com 1463.Cherry Pickup II
最棒题解
1func cherryPickup(grid [][]int) int { 2	n:=len(grid) 3	m:=len(grid[0]) 4 // dp[i][j][k]表示，机器人1在位置(i, j),机器人2在位置(i, k)时，最大值。 5	dp:=make([][][]int,n) 6	for k,_:=range dp{ 7	dp[k]=make([][]int,m) 8	for i,_:=range dp[k]{ 9	dp[k][i]=make([]int,m) 10	for j,_:=range dp[k][i]{ 11 // -1 表示这个位置还没有计算 12	dp[k][i][j]=-1 13	} 14	} 15	} 16 // 当i=0时，刚开始机器人1在(0, 0)， 机器人2在(0， n-1)，不需要计算。 17	dp[0][0][len(grid[0])-1]=grid[0][0]+grid[0][len(grid[0])-1] 18	for i:=0;i&amp;lt;n-1;i++{ 19	for j:=0;j&amp;lt;m;j++{ 20	for k:=0;k&amp;lt;m;k++{ 21	if dp[i][j][k]!</description>
    </item>
    
    <item>
      <title>Kubernetes学习笔记(一) 网络基础part1</title>
      <link>https://wncbb.github.io/k8s/network_1/</link>
      <pubDate>Sat, 08 Jan 2022 18:12:48 +0800</pubDate>
      
      <guid>https://wncbb.github.io/k8s/network_1/</guid>
      <description>Kubernetes is All about Networking.
 因此，先从网络开始学习。
 基础知识视频： https://www.youtube.com/watch?v=6v_BDHIgOY8 基础知识视频的代码地址：https://github.com/kristenjacobs/container-networking  1 k8s网络要求  All containers can communicate with all other containers without NAT. All nodes can communicate with all containers(and vice-verse) without NAT. The IP that a container sees itself as is the same IP that others see it as.  2 网络 2.1 Single network namespace. 整体示意图：根据本地网络环境，设置IP env.sh
CON=&amp;#34;con&amp;#34; NODE_IP=&amp;#34;10.0.2.15&amp;#34; IP=&amp;#34;172.16.0.1&amp;#34; 下面对setup.sh每条命令，进行解释
2.1.1 设置CON/NODE_IP/IP环境变量 #!/bin/bash -e  .</description>
    </item>
    
    <item>
      <title>Lucene学习笔记(一) 官方demo</title>
      <link>https://wncbb.github.io/lucene/lucene_1/</link>
      <pubDate>Mon, 03 Jan 2022 16:25:55 +0800</pubDate>
      
      <guid>https://wncbb.github.io/lucene/lucene_1/</guid>
      <description>官方demo地址： https://lucene.apache.org/core/9_0_0/demo/index.html#About_the_Demo
1 主要步骤 1.1 下载lucene 下载地址: https://lucene.apache.org/
jar包目录：lucene-9.0.0/modules
1.2 配置java环境 官方下载安装
# 执行如下命令，可以看到安装地址 /usr/libexec/java_home # source以下内容 JAVA_HOME=&amp;quot;&amp;lt;/usr/libexec/java_home的结果&amp;gt;&amp;quot; export JAVA_HOME PATH=$JAVA_HOME/bin:$PATH export PATH CLASSPATH=$JAVA_HOME/lib/tools.jar:$JAVA_HOME/lib/dt.jar:. export CLASSPATH 1.3 运行demo 例子文件 ./docs/alice.txt
watch movie listen music ./docs/todd.txt
watch movie bodybuilding 1.3.1 indexing 运行indexing
java -cp ./lucene-core-9.0.0.jar:./lucene-queryparser-9.0.0.jar:./lucene-analysis-common-9.0.0.jar:./lucene-demo-9.0.0.jar org.apache.lucene.demo.IndexFiles -docs ./docs Indexing to directory &amp;#39;index&amp;#39;... adding ./docs/alice.txt adding ./docs/todd.txt Indexed 2 documents in 524 milliseconds index目录被创建
index ├── _0.cfe ├── _0.cfs ├── _0.si ├── segments_1 └── write.</description>
    </item>
    
    <item>
      <title>Docker学习笔记(一) namespace</title>
      <link>https://wncbb.github.io/docker/namespace/</link>
      <pubDate>Sat, 01 Jan 2022 17:30:14 +0800</pubDate>
      
      <guid>https://wncbb.github.io/docker/namespace/</guid>
      <description>1 概述 不同container运行需要做资源隔离，使用linux namespace功能。
Namespace是linux kernel提供的一种资源隔离方案。
系统可以位进程分配不同的Namespace，并保证不同的Namespace资源独立分配，进程彼此隔离。不同Namespace下的进程，互不干扰。
Linux内核通过进程描述符task_struct结构体来管理进程。
进程数据结构
struct task_struct{ ... /* namespaces */ struct nsproxy *nsproxy; ... } nsproxy具体定义：
/* * A structure to contain pointers to all per-process * namespaces - fs (mount), uts, network, sysvipc, etc. * * The pid namespace is an exception -- it&amp;#39;s accessed using * task_active_pid_ns. The pid namespace here is the * namespace that children will use. * * &amp;#39;count&amp;#39; is the number of tasks holding a reference.</description>
    </item>
    
    <item>
      <title>About me</title>
      <link>https://wncbb.github.io/about/</link>
      <pubDate>Thu, 01 Jan 1970 00:00:00 +0800</pubDate>
      
      <guid>https://wncbb.github.io/about/</guid>
      <description>多看多读多写多总结
 github  </description>
    </item>
    
    <item>
      <title>Comment Policy</title>
      <link>https://wncbb.github.io/comment_policy/</link>
      <pubDate>Thu, 01 Jan 1970 00:00:00 +0800</pubDate>
      
      <guid>https://wncbb.github.io/comment_policy/</guid>
      <description>Obey laws.</description>
    </item>
    
  </channel>
</rss>
