<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Golangs on WNCBB&#39;s blog</title>
    <link>https://wncbb.github.io/golang/</link>
    <description>Recent content in Golangs on WNCBB&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 08 Oct 2021 11:26:13 +0800</lastBuildDate><atom:link href="https://wncbb.github.io/golang/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>3color</title>
      <link>https://wncbb.github.io/golang/3color/</link>
      <pubDate>Fri, 08 Oct 2021 11:26:13 +0800</pubDate>
      
      <guid>https://wncbb.github.io/golang/3color/</guid>
      <description>三色 强三色不变性: 任何黑色对象不能指向白色对象。
弱三色不变性: Any white object pointed to by a black object is reachable from a grey object via a chain of white pointers (it is grey-protected). 任何被黑色对象指向的白色对象，可以从一个灰色对象，沿着白色对象引用到。 举个例子：A(Black)-&amp;gt;B(Grey)-&amp;gt;C(White) =&amp;gt; A(Black)-&amp;gt;C(White) 如果C(White)没有其他引用，那么不会被重新扫描，会被误删(C其实还有用，A还需要C)。 假设有个灰色对象通过白色链路指向C,比如 D(Grey)-&amp;gt;E(White)-&amp;gt;F(White)&amp;hellip;(White)&amp;hellip;-&amp;gt;G(White)-&amp;gt;C(White)， 那么C还可以在扫描D的子孙节点时被重新染色。
Any write barrier has to prohibit a mutator from &amp;ldquo;hiding&amp;rdquo; an object; that is, rearranging the heap graph to violate the weak tricolor invariant so the garbage collector fails to mark a reachable object. For example, in a sense, the Dijkstra barrier allows a mutator to hide a white object by moving the sole pointer to it to a stack that has already been scanned.</description>
    </item>
    
  </channel>
</rss>
