<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-us" lang="en-us">
<head>
  <link href="https://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="generator" content="Hugo 0.56.0-DEV" />

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>WNCBB&#39;s blog</title>
  <meta name="description" content="A man is only as good as what he loves" />

  
  <link type="text/css" rel="stylesheet" href="https://wncbb.github.io/css/print.css" media="print">
  <link type="text/css" rel="stylesheet" href="https://wncbb.github.io/css/poole.css">
  <link type="text/css" rel="stylesheet" href="https://wncbb.github.io/css/syntax.css">
  <link type="text/css" rel="stylesheet" href="https://wncbb.github.io/css/hyde.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Abril+Fatface|PT+Sans:400,400i,700">


  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="/favicon.png">

  
  <link href="https://wncbb.github.io/index.xml" rel="alternate" type="application/rss+xml" title="WNCBB's blog" />
  
</head>

  <body class="theme-base-0c layout-reverse">
  <aside class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <a href="https://wncbb.github.io/"><h1>WNCBB&#39;s blog</h1></a>
      <p class="lead">
       A man is only as good as what he loves 
      </p>
    </div>

    <nav>
      <ul class="sidebar-nav">
        <li><a href="https://wncbb.github.io/">Home</a> </li>
        <li><a href="/categories/"> Categories </a></li><li><a href="/series/"> Series </a></li><li><a href="/tags/"> Tags </a></li>
      </ul>
    </nav>

    <p>&copy; 2021. All rights reserved. </p>
  </div>
</aside>

    <main class="content container">
    <div class="posts">
<article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0120.triangle/">0120.triangle</a>
  </h1>
  <time datetime="2021-03-12T22:02:14&#43;0800" class="post-date">2021-03-12 22:02:14</time>
  func minimumTotal(triangle [][]int) int { n := len(triangle) f := make([][]int, n) for i := 0; i &lt; n; i++ { f[i] = make([]int, n) } f[0][0] = triangle[0][0] for i := 1; i &lt; n; i++ { f[i][0] = f[i - 1][0] + triangle[i][0] for j := 1; j &lt; i; j++ { f[i][j] = min(f[i - 1][j - 1], f[i - 1][j]) + triangle[i][j] } f[i][i] = f[i - 1][i - 1] + triangle[i][i] } ans := math.
  
  <div class="read-more-link">
    <a href="/posts/leetcode/0120.triangle/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0670.maximum-swap/">0607.maximum-swap</a>
  </h1>
  <time datetime="2021-03-12T21:55:13&#43;0800" class="post-date">2021-03-12 21:55:13</time>
  func maximumSwap(num int) int { str := []byte(strconv.Itoa(num)) indexes := make([]int, 10) //记录每个元素的索引值，如果又重复，记录最右边的 for i,b := range str{ indexes[b-'0'] = i } //从左到右遍历str，然后每个元素和9-0对比， //例如：如果9存在，并且9的索引比当前大（在右边），那么换位置，返回结果 for i, b := range str{ for d :=9; d &gt;int( b-'0'); d--{ if indexes[d] &gt; i{ str[i], str[indexes[d]] = str[indexes[d]], str[i] res,_ := strconv.Atoi(string(str)) return res } } } return num }  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0203.remove-linked-list-elements/">0203.remove-linked-list-elements</a>
  </h1>
  <time datetime="2021-03-12T21:31:49&#43;0800" class="post-date">2021-03-12 21:31:49</time>
  /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func removeElements(head *ListNode, val int) *ListNode { dummy:=&amp;ListNode{} dummy.Next=head // tail:=dummy cur:=dummy for cur!=nil{ for cur.Next!=nil &amp;&amp; cur.Next.Val==val{ cur.Next=cur.Next.Next } cur=cur.Next } return dummy.Next }  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/sword_offer/09/">09</a>
  </h1>
  <time datetime="2021-03-12T21:11:13&#43;0800" class="post-date">2021-03-12 21:11:13</time>
  import( &quot;container/list&quot; ) type CQueue struct { stack1, stack2 *list.List } func Constructor() CQueue { return CQueue{ stack1: list.New(), stack2: list.New(), } } func (this *CQueue) AppendTail(value int) { this.stack1.PushBack(value) } func (this *CQueue) DeleteHead() int { // 如果第二个栈为空 if this.stack2.Len() == 0 { for this.stack1.Len() &gt; 0 { this.stack2.PushBack(this.stack1.Remove(this.stack1.Back())) } } if this.stack2.Len() != 0 { e := this.stack2.Back() this.stack2.Remove(e) return e.Value.(int) } return -1 } /* 作者：LeetCode-Solution 链接：https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/solution/mian-shi-ti-09-yong-liang-ge-zhan-shi-xian-dui-l-3/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 */  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0257.binary-tree-paths/">0257.binary-tree-paths</a>
  </h1>
  <time datetime="2021-03-12T21:03:40&#43;0800" class="post-date">2021-03-12 21:03:40</time>
  /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ import( &quot;strconv&quot; ) func binaryTreePaths(root *TreeNode) []string { var ans []string var dfs func(*TreeNode, string) dfs=func(node *TreeNode, curStr string){ if node==nil{ return } if node.Left==nil &amp;&amp; node.Right==nil{ curStr+=strconv.Itoa(node.Val) ans=append(ans, curStr) return } dfs(node.Left, curStr+strconv.Itoa(node.Val)+&quot;-&gt;&quot;) dfs(node.Right, curStr+strconv.Itoa(node.Val)+&quot;-&gt;&quot;) } dfs(root, &quot;&quot;) return ans }  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0017.letter-combinations-of-a-phone-number/">0017.Letter Combinations of a Phone Number</a>
  </h1>
  <time datetime="2021-03-12T20:30:35&#43;0800" class="post-date">2021-03-12 20:30:35</time>
  func letterCombinations(digits string) []string { if len(digits)==0{ return nil } rst:=make([]string, 0) dBytes:=[]byte(digits) ch2List:=make(map[byte][]byte) ch2List['2']=[]byte{'a', 'b', 'c'} ch2List['3']=[]byte{'d', 'e', 'f'} ch2List['4']=[]byte{'g', 'h', 'i'} ch2List['5']=[]byte{'j', 'k', 'l'} ch2List['6']=[]byte{'m', 'n', 'o'} ch2List['7']=[]byte{'p', 'q', 'r', 's'} ch2List['8']=[]byte{'t', 'u', 'v'} ch2List['9']=[]byte{'w', 'x', 'y', 'z'} var dfs func(curRst []byte) dfs=func(curRst []byte){ if len(curRst)==len(digits){ rst=append(rst, string(curRst)) return } idx:=len(curRst) chList:=ch2List[dBytes[idx]] for _, v:=range chList{ curRst=append(curRst, v) dfs(curRst) curRst=curRst[:len(curRst)-1] } } dfs(make([]byte, 0)) return rst }  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/sword_offer/07/">7</a>
  </h1>
  <time datetime="2021-03-12T20:15:15&#43;0800" class="post-date">2021-03-12 20:15:15</time>
  /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func buildTree(preorder []int, inorder []int) *TreeNode { if len(inorder)==0{ return nil } rootNode:=&amp;TreeNode{ Val: preorder[0], } midIdx:=0 for i:=0; i&lt;len(inorder); i++{ if inorder[i]==preorder[0]{ midIdx=i break } } // fmt.Printf(&quot;inoder:%+v preorder:%+v midIdx:%d\n&quot;, inorder, preorder, midIdx) // 注意，preorder也需要跟着变化 preorder跟inorder的个数是一样的 rootNode.Left=buildTree(preorder[1:midIdx+1], inorder[:midIdx]) rootNode.Right=buildTree(preorder[midIdx+1:], inorder[midIdx+1:]) return rootNode }  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/sword_offer/48/">48</a>
  </h1>
  <time datetime="2021-03-12T20:02:29&#43;0800" class="post-date">2021-03-12 20:02:29</time>
  func lengthOfLongestSubstring(s string) int { char2LastIdx:=make(map[byte]int) sBytes:=[]byte(s) curMaxLen:=0 curLeft:=0 for idx, c:=range sBytes{ lastIdx, ok:=char2LastIdx[c] if ok{ curLeft=getMax(curLeft, lastIdx+1) } curMaxLen=getMax(curMaxLen, idx-curLeft+1) char2LastIdx[c]=idx } return curMaxLen } func getMax(a, b int)int{ if a&gt;b{ return a } return b }  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0016.3sum-closest/">0016.3sum-closest</a>
  </h1>
  <time datetime="2021-03-12T19:53:23&#43;0800" class="post-date">2021-03-12 19:53:23</time>
  import( &quot;math&quot; ) func threeSumClosest(nums []int, target int) int { sort.Ints(nums) best:=math.MaxInt32 n:=len(nums) for i:=0; i&lt;n-2;i++{ if i&gt;0 &amp;&amp; nums[i]==nums[i-1]{ continue } left:=i+1 right:=n-1 for left&lt;right{ curSum:=nums[left]+nums[right]+nums[i] if curSum==target{ return target } if curSum&lt;target{ left++ }else{ right-- } if abs(best-target)&gt;abs(curSum-target){ best=curSum } } } return best } func abs(x int) int { if x &lt; 0 { return -1 * x } return x }  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0044.wildcard-matching/">0044.wildcard-matching</a>
  </h1>
  <time datetime="2021-03-12T18:13:12&#43;0800" class="post-date">2021-03-12 18:13:12</time>
  func isMatch(s string, p string) bool { m, n := len(s), len(p) dp := make([][]bool, m + 1) for i := 0; i &lt;= m; i++ { dp[i] = make([]bool, n + 1) } dp[0][0] = true for i := 1; i &lt;= n; i++ { if p[i-1] == '*' { dp[0][i] = true } else { break } } for i := 1; i &lt;= m; i++ { for j := 1; j &lt;= n; j++ { if p[j-1] == '*' { // 要么*当做空字符串，就是dp[i][j-1] // 要么s[i]归入*表示的任意字符里，就是dp[i-1][j] dp[i][j] = dp[i][j-1] || dp[i-1][j] } else if p[j-1] == '?
  
  <div class="read-more-link">
    <a href="/posts/leetcode/0044.wildcard-matching/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0048.rotate-image/">0048.rotate-image</a>
  </h1>
  <time datetime="2021-03-12T17:08:41&#43;0800" class="post-date">2021-03-12 17:08:41</time>
  主对角线对折 for i := 0; i &lt; n; i++ { for j := i+1; j &lt; n; j++ { // fmt.Printf(&quot;i,j: %d,%d\n&quot;, i, j) matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] } }  副对角线对折 for i := 0; i &lt; n; i++ { for j := 0; j &lt; n-i-1; j++ { matrix[i][j], matrix[n-1-j][n-1-i] = matrix[n-1-j][n-1-i], matrix[i][j] } }  func rotate(matrix [][]int) { n := len(matrix) // 水平翻转 for i := 0; i &lt; n/2; i++ { matrix[i], matrix[n-1-i] = matrix[n-1-i], matrix[i] } // 主对角线翻转 // (i, j)跟(j, i)互换 // 但是i，j的循环上限不能都是n，否则(i,j)与(j,i)换了两次，相当于没有换 // (0, 1)跟(1, 0)换， for i := 0; i &lt; n; i++ { for j := 0; j &lt; i; j++ { // fmt.
  
  <div class="read-more-link">
    <a href="/posts/leetcode/0048.rotate-image/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0034.find-first-and-last-position-of-element-in-sorted-array/">0034.find-first-and-last-position-of-element-in-sorted-array</a>
  </h1>
  <time datetime="2021-03-12T16:47:38&#43;0800" class="post-date">2021-03-12 16:47:38</time>
  func searchRange(nums []int, target int) []int { left:=findLeft(nums, target) if left==-1{ return []int{-1, -1} } right:=findRight(nums, target) return []int{left, right} } func findLeft(nums []int, target int) int{ left:=0 right:=len(nums)-1 for left&lt;=right{ fmt.Printf(&quot;LEFT left:%d right:%d\n&quot;, left, right) mid:=left+(right-left)/2 if nums[mid]==target{ right=mid-1 }else if nums[mid]&lt;target{ left=mid+1 }else{ right=mid-1 } } if left&lt;len(nums) &amp;&amp; nums[left]==target{ return left } return -1 } func findRight(nums []int, target int)int{ left:=0 right:=len(nums)-1 for left&lt;=right{ fmt.Printf(&quot;RIGHT left:%d right:%d\n&quot;, left, right) mid:=left+(right-left)/2 if nums[mid]==target{ left=mid+1 }else if nums[mid]&lt;target{ left=mid+1 }else{ right=mid-1 } } if right&gt;=0 &amp;&amp; nums[right]==target{ return right } return -1 }  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0704.binary-search/">0704.binary-search</a>
  </h1>
  <time datetime="2021-03-12T16:44:49&#43;0800" class="post-date">2021-03-12 16:44:49</time>
  func search(nums []int, target int) int { left:=0 right:=len(nums)-1 for left&lt;=right{ mid:=left+(right-left)/2 if nums[mid]==target{ return mid }else if nums[mid]&lt;target{ left=mid+1 }else{ right=mid-1 } } return -1 }  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0402.remove-k-digits/">0402.remove-k-digits</a>
  </h1>
  <time datetime="2021-03-12T16:23:15&#43;0800" class="post-date">2021-03-12 16:23:15</time>
  func removeKdigits(num string, k int) string { stack := []byte{} for i := range num { digit := num[i] // 必读stack=[1, 3, 5], 目前字符是4，显然把栈顶元素5换成4，也就是删除4，更好些 for k &gt; 0 &amp;&amp; len(stack) &gt; 0 &amp;&amp; digit &lt; stack[len(stack)-1] { stack = stack[:len(stack)-1] k-- } stack = append(stack, digit) } // 如果k还大于0，说明剩下的字符已经是单调递增的了，直接删除后面的元素即可 stack = stack[:len(stack)-k] // 删除左侧前导0 ans := strings.TrimLeft(string(stack), &quot;0&quot;) if ans == &quot;&quot; { ans = &quot;0&quot; } return ans }  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0349.intersection-of-two-arrays/">0349.intersection-of-two-arrays</a>
  </h1>
  <time datetime="2021-03-12T16:14:18&#43;0800" class="post-date">2021-03-12 16:14:18</time>
  func intersection(nums1 []int, nums2 []int) (res []int) { sort.Ints(nums1) sort.Ints(nums2) for i, j := 0, 0; i &lt; len(nums1) &amp;&amp; j &lt; len(nums2); { x, y := nums1[i], nums2[j] if x == y { if res == nil || x &gt; res[len(res)-1] { res = append(res, x) } i++ j++ } else if x &lt; y { i++ } else { j++ } } return }  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0110.balanced-binary-tree/">0110.balanced-binary-tree</a>
  </h1>
  <time datetime="2021-03-12T16:08:51&#43;0800" class="post-date">2021-03-12 16:08:51</time>
  /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func isBalanced(root *TreeNode) bool { if root==nil{ return true } return abs(getDepth(root.Left)-getDepth(root.Right))&lt;=1 &amp;&amp; isBalanced(root.Left) &amp;&amp; isBalanced(root.Right) } func abs(a int)int{ if a&lt;0{ return -1*a } return a } func getDepth(root *TreeNode)int{ if root==nil{ return 0 } return getMax(getDepth(root.Left), getDepth(root.Right))+1 } func getMax(a, b int)int{ if a&gt;b{ return a } return b }  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0097.interleaving-string/">0097.interleaving-string</a>
  </h1>
  <time datetime="2021-03-12T13:17:00&#43;0800" class="post-date">2021-03-12 13:17:00</time>
  func isInterleave(s1 string, s2 string, s3 string) bool { s1Len:=len(s1) s2Len:=len(s2) s3Len:=len(s3) if s1Len+s2Len!=s3Len{ return false } dp:=make([][]bool, 0, s1Len+1) for i:=0; i&lt;=s1Len; i++{ dp=append(dp, make([]bool, s2Len+1, s2Len+1)) } // 表示s1[:i], s[:j]是否可以交错形成s3 dp[0][0]=true // 为了处置dp[0][1, 2, 3...]，必须从0开始遍历 for i:=0; i&lt;=s1Len; i++{ for j:=0; j&lt;=s2Len; j++{ if i&gt;0{ // 看看s3的下一个字符是否是s1的下一个字符，因为判断的是s1[i-1]字符，前一个字符是i-2，所以dp里就得是i-1 dp[i][j]=dp[i][j] || (dp[i-1][j] &amp;&amp; s1[i-1]==s3[i+j-1]) } if j&gt;0{ // 看看s3的下一个富足是否是s2的下一个字符 dp[i][j]=dp[i][j] || (dp[i][j-1] &amp;&amp; s2[j-1]==s3[i+j-1]) } } } return dp[s1Len][s2Len] }  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0493.reverse-pairs/">0493.reverse-pairs</a>
  </h1>
  <time datetime="2021-03-12T13:05:11&#43;0800" class="post-date">2021-03-12 13:05:11</time>
  func reversePairs(nums []int) int { n := len(nums) if n &lt;= 1 { return 0 } n1 := append([]int{}, nums[:n/2]...) n2 := append([]int{}, nums[n/2:]...) cnt := reversePairs(n1) + reversePairs(n2) // 递归完毕后，n1 和 n2 均为有序 // 统计重要翻转对 (i,j) 的数量 // 由于 n1 和 n2 均为有序，可以用两个指针同时遍历 // n1: a b c e f // n2: g h i j k // 遍历n1，看a与g,h,i...是否符合条件，如果不符合，就停止，因为n2是递增排序 // 遍历完a后，遍历b时，j不用变，因为b&gt;a，a符合的j，b一定符合 j := 0 for _, v := range n1 { for j &lt; len(n2) &amp;&amp; v &gt; 2*n2[j] { j++ } cnt += j } // n1 和 n2 归并填入 nums p1, p2 := 0, 0 for i:=0; i&lt;len(nums); i++{ if p1&gt;=len(n1){ nums[i]=n2[p2] p2++ continue } if p2&gt;=len(n2){ nums[i]=n1[p1] p1++ continue } if n1[p1]&lt;n2[p2]{ nums[i]=n1[p1] p1++ }else{ nums[i]=n2[p2] p2++ } } return cnt }  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0315.count-of-smaller-numbers-after-self/">0315.count-of-smaller-numbers-after-self</a>
  </h1>
  <time datetime="2021-03-12T12:50:33&#43;0800" class="post-date">2021-03-12 12:50:33</time>
  https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/solution/ji-suan-you-ce-xiao-yu-dang-qian-yuan-su-de-ge-s-7/
// 一个数右侧比他小的数的个数 // 数组reverse一下，就是一个数左侧比他小的数的个数 // 比如: 1, 7, 2, 2, 3 ,4 // 遍历一遍，当看到1时，左侧没有数，所以是0 // 等遍历到3的时候，比他小的数是1的个数跟2的个数 // 我们把数组从小到大排序，然后记录遍历一个数字之后，数字的个数 // 就像下图: 遍历到3的时候，已经看到一个1，2个2，一个7，以及本身的一个三 // 只需要把3前面的个数加起来即可 // 跟binray-index-tree的使用场景一样，同意一个前缀和，且支持随时修改数据 // 1 2 1 0 1 // 1 2 3 4 7 func countSmaller(nums []int) []int { num2Idx:=getSortedUnique(nums) tree:=&amp;BinaryIndexTree{} tree.Build(make([]int, len(num2Idx), len(num2Idx))) rst:=make([]int, 0) for i:=len(nums)-1; i&gt;=0; i--{ // fmt.Printf(&quot;i;&quot;) v:=nums[i] idx:=num2Idx[v] tree.Update(idx, 1) rst=append(rst, tree.PrefixSum(idx-1)) } return reverseInts(rst) } func reverseInts(s []int)[]int{ left:=0 right:=len(s)-1 for left&lt;right{ s[left], s[right]=s[right], s[left] left++ right-- } return s } func getSortedUnique(nums []int)map[int]int{ unique:=make([]int, 0, len(nums)) seen:=make(map[int]struct{}) for _, v:=range nums{ seen[v]=struct{}{} } for k, _:=range seen{ unique=append(unique, k) } sort.
  
  <div class="read-more-link">
    <a href="/posts/leetcode/0315.count-of-smaller-numbers-after-self/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0295.find-median-from-data-stream/">0295.find-median-from-data-stream</a>
  </h1>
  <time datetime="2021-03-12T12:16:09&#43;0800" class="post-date">2021-03-12 12:16:09</time>
  import &quot;container/heap&quot; type MyHeap struct { raw []int cmp func(a, b int)bool } func (m *MyHeap)Len()int{ return len(m.raw) } func (m *MyHeap)Less(i, j int)bool{ return m.cmp(m.raw[i], m.raw[j]) } func (m *MyHeap)Swap(i, j int){ m.raw[i], m.raw[j]=m.raw[j], m.raw[i] } func (m *MyHeap)Push(v interface{}){ m.raw=append(m.raw, v.(int)) } func (m *MyHeap)Pop()interface{}{ ret:=m.raw[len(m.raw)-1] m.raw=m.raw[:len(m.raw)-1] return ret } func(m *MyHeap)Top()int{ return m.raw[0] } // MedianFinder // 用大、小顶堆存储数据。 // 其中前半部分是大顶堆 // 后半部分是小顶堆 // 而且前半部分（大顶堆）最多比后半部分（小顶堆）多存一个元素 // 因此： // 当元素总共有奇数个时，则返回大顶堆的堆顶元素。 // 当元素纵隔有偶数个时，则返回两个堆顶元素之和再除以2.
  
  <div class="read-more-link">
    <a href="/posts/leetcode/0295.find-median-from-data-stream/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0460.lfu-cache/">0460.lfu-cache</a>
  </h1>
  <time datetime="2021-03-12T11:50:24&#43;0800" class="post-date">2021-03-12 11:50:24</time>
  import( &quot;container/list&quot; ) type Data struct{ Key int Value int Count int } type LFUCache struct { key2Elem map[int]*list.Element count2List map[int]*list.List minCount int capacity int } func Constructor(capacity int) LFUCache { return LFUCache{ key2Elem: make(map[int]*list.Element), count2List: make(map[int]*list.List), minCount: 0, capacity: capacity, } } func (this *LFUCache) Get(key int) int { // fmt.Printf(&quot;[GET] ---------- START\n&quot;) // fmt.Printf(&quot;[GET] BEFORE this.count2List: %+v \n&quot;, this.count2List) // fmt.Printf(&quot;[GET] %d\n&quot;, key) elem, ok:=this.key2Elem[key] if !ok{ return -1 } data:=elem.
  
  <div class="read-more-link">
    <a href="/posts/leetcode/0460.lfu-cache/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0144.binary-tree-preorder-traversal/">0144.binary-tree-preorder-traversal</a>
  </h1>
  <time datetime="2021-03-11T23:43:03&#43;0800" class="post-date">2021-03-11 23:43:03</time>
  /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func preorderTraversal(root *TreeNode) []int { ret:=make([]int, 0) var helper func(node *TreeNode) helper=func(node *TreeNode){ if node==nil{ return } ret=append(ret, node.Val) helper(node.Left) helper(node.Right) } helper(root) return ret }  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0114.flatten-binary-tree-to-linked-list/">0114.flatten-binary-tree-to-linked-list</a>
  </h1>
  <time datetime="2021-03-11T23:40:07&#43;0800" class="post-date">2021-03-11 23:40:07</time>
  /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func flatten(root *TreeNode) { if root==nil{ return } myStack:=&amp;Stack{ raw: make([]*TreeNode, 0), } myStack.Push(root) lastNode:=root for !myStack.Empty(){ cur:=myStack.Pop() if cur.Right!=nil{ myStack.Push(cur.Right) } if cur.Left!=nil{ myStack.Push(cur.Left) } if lastNode!=cur{ lastNode.Left=nil lastNode.Right=cur lastNode=cur } } } type Stack struct{ raw []*TreeNode } func(s *Stack)Push(v *TreeNode){ s.raw=append(s.raw, v) } func (s *Stack)Pop()*TreeNode{ ret:=s.
  
  <div class="read-more-link">
    <a href="/posts/leetcode/0114.flatten-binary-tree-to-linked-list/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/sword_offer/57/">57</a>
  </h1>
  <time datetime="2021-03-11T23:29:18&#43;0800" class="post-date">2021-03-11 23:29:18</time>
  func findContinuousSequence(target int) [][]int { ret:=make([][]int, 0) for l, r:=1, 2; l&lt;r; { // 长度=r-l+1 乘以 平均值=(l+r)/2 sum:=(r-l+1)*(l+r)/2 if sum&lt;target{ r++ }else if sum&gt;target{ l++ }else{ ret=append(ret, getList(l, r)) l++ r++ } } return ret } func getList(l, r int)[]int{ ret:=make([]int, 0, r-l+1) for i:=l; i&lt;=r; i++{ ret=append(ret, i) } return ret }  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0153.find-minimum-in-rotated-sorted-array/">0153.find-minimum-in-rotated-sorted-array</a>
  </h1>
  <time datetime="2021-03-11T23:18:37&#43;0800" class="post-date">2021-03-11 23:18:37</time>
  func findMin(nums []int) int { left:=0 right:=len(nums)-1 if nums[left]&lt;nums[right]{ return nums[0] } for left&lt;right{ mid:=left+(right-left)/2 if nums[mid]&gt;nums[right]{ left=mid+1 }else{ right=mid } } // 这种写法不对，因为这个数组是升序排列的，所以得用nums[mid]&gt;nums[right]来做判断 // for left&lt;right{ // fmt.Printf(&quot;BEFORE left:%d right:%d\n&quot;, left, right) // mid:=left+(right-left)/2 // if nums[mid]&gt;nums[left]{ // left=mid+1 // }else{ // right=mid // } // fmt.Printf(&quot;AFTER left:%d right:%d\n&quot;, left, right) // } return nums[left] }  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0108.convert-sorted-array-to-binary-search-tree/">0108.convert-sorted-array-to-binary-search-tree</a>
  </h1>
  <time datetime="2021-03-11T23:02:42&#43;0800" class="post-date">2021-03-11 23:02:42</time>
  /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func sortedArrayToBST(nums []int) *TreeNode { return helper(nums, 0, len(nums)-1) } func helper(nums []int, left, right int)*TreeNode{ if left&gt;right{ return nil } mid:=left+(right-left)/2 ret:=&amp;TreeNode{ Val: nums[mid], } ret.Left=helper(nums, left, mid-1) ret.Right=helper(nums, mid+1, right) return ret }  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0207.course-schedule/">0207.course-schedule</a>
  </h1>
  <time datetime="2021-03-11T22:42:13&#43;0800" class="post-date">2021-03-11 22:42:13</time>
  dfs func canFinish(numCourses int, prerequisites [][]int) bool { src2Dsts:=make(map[int][]int, 0) id2Color:=make(map[int]int) // 有的课程可能不在 prerequisites 里，所以最好用numCourses for i:=0; i&lt;numCourses; i++{ id2Color[i]=0 } for _, v:=range prerequisites{ src2Dsts[v[1]]=append(src2Dsts[v[1]], v[0]) } isValid:=true var dfs func(idx int) dfs=func(idx int){ id2Color[idx]=1 dsts:=src2Dsts[idx] for _, v:=range dsts{ // 如果存在节点颜色为1，表示有环了 if id2Color[v]==1{ isValid=false return }else if id2Color[v]==0{ dfs(v) }else{ // nothing need to do } } id2Color[idx]=2 } for i:=0; i&lt;numCourses; i++{ if !isValid{ break } if id2Color[i]==0{ dfs(i) } } return isValid }  bfs func canFinish(numCourses int, prerequisites [][]int) bool { src2Dsts:=make(map[int][]int, 0) id2Indegrees:=make(map[int]int) // 需要这样写，不然如果点不在prerequisites这里出现，就会导致入度为0的节点id2Indegrees里一个也没有 for i:=0; i&lt;numCourses; i++{ id2Indegrees[i]=0 } for _, v:=range prerequisites{ src2Dsts[v[1]]=append(src2Dsts[v[1]], v[0]) id2Indegrees[v[0]]++ } q:=make([]int, 0) for idx, indegree:=range id2Indegrees{ if indegree==0{ q=append(q, idx) } } finished:=make([]int, 0) for len(q)!
  
  <div class="read-more-link">
    <a href="/posts/leetcode/0207.course-schedule/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0038.count-and-say/">0038.count-and-say</a>
  </h1>
  <time datetime="2021-03-11T22:07:46&#43;0800" class="post-date">2021-03-11 22:07:46</time>
  func countAndSay(n int) string { if n==1{ return &quot;1&quot; } s:=countAndSay(n-1) start:=0 result:=&quot;&quot; i:=1 for i=1; i&lt;len(s); i++{ // 这里加的是start，i会赋值给start，下次再计算 if s[i]!=s[start]{ result+=strconv.FormatInt(int64(i-start), 10) result+=s[start:start+1] start=i } } result+=strconv.FormatInt(int64(i-start), 10) result+=s[start:start+1] return result }  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0155.min-stack/">0155.min-stack</a>
  </h1>
  <time datetime="2021-03-11T21:12:23&#43;0800" class="post-date">2021-03-11 21:12:23</time>
  double stack 拿两个栈，一个正常存数据stack，一个存最小值minStack minStack里放一个math.MaxInt64来初始化 对于push一个数据x x被push到stack后，更新minStack: 判断下x跟minStack.top的大小，把小值再push到minStack  import( &quot;math&quot; ) type MinStack struct { stack []int minStack []int } /** initialize your data structure here. */ func Constructor() MinStack { minStack:=make([]int, 0) minStack=append(minStack, math.MaxInt64) return MinStack{ stack: make([]int, 0), minStack: minStack, } } func (this *MinStack) Push(x int) { this.stack=append(this.stack, x) // minStack里至少要有一个math.MaxInt64 minStackTop:=this.minStack[len(this.minStack)-1] this.minStack=append(this.minStack, getMin(x, minStackTop)) } func getMin(a, b int)int{ if a&lt;b{ return a } return b } func (this *MinStack) Pop() { // this.
  
  <div class="read-more-link">
    <a href="/posts/leetcode/0155.min-stack/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0547.number-of-provinces/">0547.number-of-provinces</a>
  </h1>
  <time datetime="2021-03-11T20:09:16&#43;0800" class="post-date">2021-03-11 20:09:16</time>
  func findCircleNum(isConnected [][]int) int { if len(isConnected)==0{ return 0 } m:=len(isConnected) visited:=make([]bool, m, m) var dfs func(idx int) dfs = func (idx int){ if visited[idx]{ return } visited[idx]=true for i:=0; i&lt;m; i++{ if isConnected[idx][i]!=1{ continue } if visited[i]{ continue } dfs(i) } } ans:=0 for i:=0; i&lt;m; i++{ if visited[i]{ continue } ans++ dfs(i) } return ans }  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode.0547.number-of-provinces/">Leetcode.0547</a>
  </h1>
  <time datetime="2021-03-11T20:08:55&#43;0800" class="post-date">2021-03-11 20:08:55</time>
  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0239.sliding-window-maximum/">0239.sliding-window-maximum</a>
  </h1>
  <time datetime="2021-03-11T19:08:44&#43;0800" class="post-date">2021-03-11 19:08:44</time>
  heap import( &quot;container/heap&quot; ) func maxSlidingWindow(nums []int, k int) []int { myHeap:=&amp;Heap{ raw: make([]*Elem, 0), } for i:=0; i&lt;k; i++{ heap.Push(myHeap, &amp;Elem{ Value: nums[i], Index: i, }) } ans:=make([]int, 0) ans=append(ans, myHeap.raw[0].Value) for i:=k; i&lt;len(nums); i++{ heap.Push(myHeap, &amp;Elem{ Value: nums[i], Index: i, }) for myHeap.raw[0].Index&lt;=i-k{ heap.Pop(myHeap) } ans=append(ans, myHeap.raw[0].Value) } return ans } type Elem struct{ Value int Index int } type Heap struct{ raw [] *Elem } func (h *Heap)Len()int{ return len(h.
  
  <div class="read-more-link">
    <a href="/posts/leetcode/0239.sliding-window-maximum/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0061.rotate-list/">61.rotate-list</a>
  </h1>
  <time datetime="2021-03-11T18:43:34&#43;0800" class="post-date">2021-03-11 18:43:34</time>
  先连接成一个环 然后新的头位置在length-k%length，  /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func rotateRight(head *ListNode, k int) *ListNode { if head==nil || head.Next==nil{ return head } length:=0 cur:=head var oldTail *ListNode for cur!=nil{ oldTail=cur cur=cur.Next length++ } oldTail.Next=head target:=length-k%length cur=head for i:=0; i&lt;target-1; i++{ cur=cur.Next } newHead:=cur.Next cur.Next=nil return newHead }  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0050.powx-n/">0050.powx-n</a>
  </h1>
  <time datetime="2021-03-11T18:24:20&#43;0800" class="post-date">2021-03-11 18:24:20</time>
  每个二进制数位都有一个权值，权值如下图所示，最终结果就等于所有二进制位为1的权值之积，, 例如上述 x^77次方对应的二进制 (1001101) 和每个二进制位的权值如下 1 0 0 1 1 0	1 x^64 x^32 x^16 x^8 x^4	x^2 x^1 最终结果就是所有二进制位为1的权值之积：x^1 * x^4 * x^8 * x^64 = x^77 而且我们不必预先把每一个二进制位的权值计算出来，我们可以一边计算结果，一边计算权值  func myPow(x float64, n int) float64 { if n &gt;= 0 { return quickMul(x, n) } return 1.0 / quickMul(x, -n) } func quickMul(x float64, N int) float64 { ans := 1.0 // 贡献的初始值为 x x_contribute := x // 在对 N 进行二进制拆分的同时计算答案 for N &gt; 0 { fmt.
  
  <div class="read-more-link">
    <a href="/posts/leetcode/0050.powx-n/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/sword_offer/38/">38</a>
  </h1>
  <time datetime="2021-03-11T18:01:44&#43;0800" class="post-date">2021-03-11 18:01:44</time>
  func permutation(s string) []string { rst:=make([]string, 0) sBytes:=[]byte(s) sort.Slice(sBytes, func(i, j int)bool{ return sBytes[i]&lt;sBytes[j] }) seen:=make(map[int]bool) var dfs func(curRst []byte) dfs = func(curRst []byte){ if len(curRst)==len(sBytes){ rst=append(rst, string(curRst)) return } for i:=0; i&lt;len(sBytes); i++{ curByte:=sBytes[i] if seen[i]{ continue } if i&gt;0 &amp;&amp; sBytes[i]==sBytes[i-1] &amp;&amp; !seen[i-1] { continue } seen[i]=true curRst=append(curRst, curByte) dfs(curRst) seen[i]=false curRst=curRst[:len(curRst)-1] } } dfs(make([]byte, 0, len(s))) return rst }  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0169.majority-element/">0169.majority-element</a>
  </h1>
  <time datetime="2021-03-11T17:41:51&#43;0800" class="post-date">2021-03-11 17:41:51</time>
  // Boyer-Moore 投票算法 func majorityElement(nums []int) int { count:=0 candidate:=0 for _, v:=range nums{ fmt.Printf(&quot;BEFORE: v:%d count:%d candidate:%d\n&quot;, v, count, candidate) if count==0{ candidate=v } if v==candidate{ count++ }else{ count-- } fmt.Printf(&quot;AFTER: v:%d count:%d candidate:%d\n&quot;, v, count, candidate) } return candidate }  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0139.word-break/">0139.word-break</a>
  </h1>
  <time datetime="2021-03-11T17:33:15&#43;0800" class="post-date">2021-03-11 17:33:15</time>
  func wordBreak(s string, wordDict []string) bool { wordDictSet := make(map[string]bool) for _, w := range wordDict { wordDictSet[w] = true } // dp[i]表示，索引i之前的字符[0:i]，能否被wordDict表示 dp := make([]bool, len(s) + 1) dp[0] = true for i := 1; i &lt;= len(s); i++ { for j := 0; j &lt; i; j++ { if dp[j] &amp;&amp; wordDictSet[s[j:i]] { dp[i] = true break } } } return dp[len(s)] }  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0234.palindrome-linked-list/">0234.palindrome-linked-list</a>
  </h1>
  <time datetime="2021-03-11T17:27:28&#43;0800" class="post-date">2021-03-11 17:27:28</time>
  /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func isPalindrome(head *ListNode) bool { if head==nil || head.Next==nil{ return true } slow:=head fast:=head for fast!=nil &amp;&amp; fast.Next!=nil { slow=slow.Next fast=fast.Next.Next } var secondPart *ListNode /* 1 2 3 3 2 1 s f 如果f是nil，s就是第二段的开始 */ if fast==nil{ secondPart=reverseList(slow) }else{ /* 1 2 3 4 3 2 1 s f 如果f不是nil，s.
  
  <div class="read-more-link">
    <a href="/posts/leetcode/0234.palindrome-linked-list/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0104.maximum-depth-of-binary-tree/">0104.maximum-depth-of-binary-tree</a>
  </h1>
  <time datetime="2021-03-11T16:59:48&#43;0800" class="post-date">2021-03-11 16:59:48</time>
  /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func maxDepth(root *TreeNode) int { if root==nil{ return 0 } left:=maxDepth(root.Left) right:=maxDepth(root.Right) return getMax(left, right)+1 } func getMax(a, b int)int{ if a&gt;b{ return a } return b }  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0043.multiply-strings/">0043.multiply-strings</a>
  </h1>
  <time datetime="2021-03-11T15:26:28&#43;0800" class="post-date">2021-03-11 15:26:28</time>
  func multiply(a string, b string) string { if a == &quot;0&quot; || b == &quot;0&quot; { return &quot;0&quot; } // string转换成[]byte，容易取得相应位上的具体值 bsi := []byte(a) bsj := []byte(b) temp := make([]int, len(bsi)+len(bsj)) //两数相乘，结果位数不会超过两乘数位数和，即temp的长度只可能为 len(num1)+len(num2) 或 len(num1)+len(num2)-1 // 选最大的，免得位数不够 for i := 0; i &lt; len(bsi); i++ { for j := 0; j &lt; len(bsj); j++ { // 对应每个位上的乘积，直接累加存入 temp 中相应的位置 temp[i+j+1] += int(bsi[i]-'0') * int(bsj[j]-'0') fmt.Printf(&quot;i:%d j:%d temp:%+v\n&quot;, i, j, temp) } } //统一处理进位 for i := len(temp) - 1; i &gt; 0; i-- { temp[i-1] += temp[i] / 10 //对该结果进位（进到前一位） temp[i] = temp[i] % 10 //对个位数保留 } // a 和 b 较小的时候，temp的首位为0 // 为避免输出结果以0开头，需要去掉temp的0首位 if temp[0] == 0 { temp = temp[1:] } //转换结果：将[]int类型的temp转成[]byte类型, //因为在未处理进位的情况下，temp每位的结果可能超过255(go中，byte类型实为uint8，最大为255),所以temp选用[]int类型 //但在处理完进位后，不再会出现溢出 res := make([]byte, len(temp)) //res 存放最终结果的ASCII码 for i := 0; i &lt; len(temp); i++ { res[i] = byte(temp[i] + '0') } return string(res) }  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0406.queue-reconstruction-by-height/">0406.queue-reconstruction-by-height</a>
  </h1>
  <time datetime="2021-03-11T15:15:46&#43;0800" class="post-date">2021-03-11 15:15:46</time>
  func reconstructQueue(input [][]int) [][]int { sort.Slice(input, func(i, j int) bool { return input[i][0] &gt; input[j][0] || (input[i][0] == input[j][0] &amp;&amp; input[i][1] &lt; input[j][1]) }) for from, p := range input { to := p[1] // ---to---from--- // to跟from整体后移一位，然后把p放到to上 copy(input[to+1:from+1], input[to:from]) input[to] = p } return input }  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0026.remove-duplicates-from-sorted-array/">0026.remove-duplicates-from-sorted-array</a>
  </h1>
  <time datetime="2021-03-11T14:18:24&#43;0800" class="post-date">2021-03-11 14:18:24</time>
  双指针
func removeDuplicates(nums []int) int { if len(nums)==0{ return 0 } i:=0 for j:=1; j&lt;len(nums); j++{ if nums[i]==nums[j]{ continue } i++ nums[i]=nums[j] } return i+1 }  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0062.unique-paths/">0062.unique-paths</a>
  </h1>
  <time datetime="2021-03-11T14:13:37&#43;0800" class="post-date">2021-03-11 14:13:37</time>
  func uniquePaths(m int, n int) int { dp:=make([][]int, 0, m) for i:=0; i&lt;m; i++{ dp=append(dp, make([]int, n, n)) } for i:=0; i&lt;m; i++{ dp[i][0]=1 } for j:=0; j&lt;n; j++{ dp[0][j]=1 } for i:=1; i&lt;m; i++{ for j:=1; j&lt;n; j++{ dp[i][j]=dp[i-1][j]+dp[i][j-1] } } return dp[m-1][n-1] }  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0726.number-of-atoms/">0726.number-of-atoms</a>
  </h1>
  <time datetime="2021-03-11T14:10:36&#43;0800" class="post-date">2021-03-11 14:10:36</time>
  func isDigit(b byte) bool { return '0' &lt;= b &amp;&amp; b &lt;= '9' } func isLower(b byte) bool { return 'a' &lt;= b &amp;&amp; b &lt;= 'z' } func countOfAtoms(s string) (ans string) { stack:=&amp;Stack{ raw: make([]map[string]int, 0), } i, n := 0, len(s) parseNum := func() (v int) { if i == n || !isDigit(s[i]) { return 1 } for ; i &lt; n &amp;&amp; isDigit(s[i]); i++ { v = v*10 + int(s[i]-'0') } return } stack.
  
  <div class="read-more-link">
    <a href="/posts/leetcode/0726.number-of-atoms/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0287.find-the-duplicate-number/">0287.find-the-duplicate-number</a>
  </h1>
  <time datetime="2021-03-11T12:21:41&#43;0800" class="post-date">2021-03-11 12:21:41</time>
  func findDuplicate(nums []int) int { slow:=0 fast:=0 slow=nums[slow] fast=nums[nums[fast]] for slow!=fast{ slow=nums[slow] fast=nums[nums[fast]] } slow=0 for slow!=fast{ slow=nums[slow] fast=nums[fast] } return slow }  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0083.remove-duplicates-from-sorted-list/">0083.remove-duplicates-from-sorted-list</a>
  </h1>
  <time datetime="2021-03-11T12:02:47&#43;0800" class="post-date">2021-03-11 12:02:47</time>
  /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func deleteDuplicates(head *ListNode) *ListNode { dummy:=&amp;ListNode{} dummy.Next=head cur:=dummy for cur.Next!=nil &amp;&amp; cur.Next.Next!=nil{ left:=cur.Next right:=cur.Next for right.Next!=nil &amp;&amp; right.Next.Val==left.Val{ right=right.Next } if left!=right{ cur.Next.Next=right.Next } cur=cur.Next } return dummy.Next }  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/interview02/05/">05</a>
  </h1>
  <time datetime="2021-03-11T11:57:00&#43;0800" class="post-date">2021-03-11 11:57:00</time>
  /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode { dummy:=&amp;ListNode{} tail:=dummy carry:=0 for l1!=nil || l2!=nil || carry&gt;0{ if l1!=nil{ carry+=l1.Val l1=l1.Next } if l2!=nil{ carry+=l2.Val l2=l2.Next } curNode:=&amp;ListNode{ Val: carry%10, } carry=carry/10 tail.Next=curNode tail=tail.Next } return dummy.Next }  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/179.largest-number/">179.largest-number</a>
  </h1>
  <time datetime="2021-03-11T11:51:03&#43;0800" class="post-date">2021-03-11 11:51:03</time>
  import( &quot;strings&quot; &quot;strconv&quot; &quot;sort&quot; ) func largestNumber(nums []int) string { strs := make([]string, len(nums)) for i, num := range nums { strs[i] = strconv.Itoa(num) } sort.Slice(strs, func(i, j int) bool { return strs[i]+strs[j] &gt;= strs[j]+strs[i] }) ret := strings.Join(strs, &quot;&quot;) if ret[0]=='0'{ // 对应 &quot;0&quot; if len(ret)==1{ return ret } i:=0 for ; i&lt;len(ret); i++{ if ret[i]=='0'{ continue } } // 对应 &quot;0000000&quot; if i==len(ret){ return &quot;0&quot; }else{ // 对应 &quot;000123&quot; return ret[i:] } } return ret }  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0297.serialize-and-deserialize-binary-tree/">297.serialize-and-deserialize-binary-tree</a>
  </h1>
  <time datetime="2021-03-11T11:39:00&#43;0800" class="post-date">2021-03-11 11:39:00</time>
  /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ type Codec struct { } func Constructor() Codec { return Codec{} } // Serializes a tree to a single string. func (this *Codec) serialize(root *TreeNode) string { queue:=&amp;Queue{ raw: make([]*TreeNode, 0), } s:=&quot;&quot; queue.Append(root) for !queue.Empty(){ cur:=queue.Pop() if cur!=nil{ s+=strconv.FormatInt(int64(cur.Val), 10) queue.Append(cur.Left) queue.Append(cur.Right) }else{ s+=&quot;n&quot; } s+=&quot;,&quot; } // fmt.
  
  <div class="read-more-link">
    <a href="/posts/leetcode/0297.serialize-and-deserialize-binary-tree/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/sword_offer/22/">22</a>
  </h1>
  <time datetime="2021-03-11T10:43:31&#43;0800" class="post-date">2021-03-11 10:43:31</time>
  /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func getKthFromEnd(head *ListNode, k int) *ListNode { dummy:=&amp;ListNode{} dummy.Next=head slow:=dummy quick:=dummy for i:=0; i&lt;k; i++{ quick=quick.Next } for quick.Next!=nil{ quick=quick.Next slow=slow.Next } return slow.Next }  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0039.combination-sum/">0039.combination-sum</a>
  </h1>
  <time datetime="2021-03-11T10:39:04&#43;0800" class="post-date">2021-03-11 10:39:04</time>
  https://leetcode-cn.com/problems/combination-sum/solution/zu-he-zong-he-by-leetcode-solution/
func combinationSum(candidates []int, target int) (ans [][]int) { comb := []int{} var dfs func(target, idx int) dfs = func(target, idx int) { if idx == len(candidates) { return } if target == 0 { ans = append(ans, append([]int(nil), comb...)) return } // 直接跳过 dfs(target, idx+1) // 选择当前数 if target-candidates[idx] &gt;= 0 { comb = append(comb, candidates[idx]) dfs(target-candidates[idx], idx) comb = comb[:len(comb)-1] } } dfs(target, 0) return }  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0085.maximal-rectangle/">0085.maximal-rectangle</a>
  </h1>
  <time datetime="2021-03-10T23:58:27&#43;0800" class="post-date">2021-03-10 23:58:27</time>
  https://leetcode-cn.com/problems/maximal-rectangle/solution/dong-tai-gui-hua-zhuang-tai-ya-suo-go849-z4ym/
func maximalRectangle(matrix [][]byte) (result int) { if len(matrix) == 0 || len(matrix[0]) == 0 { return 0 } // matrix[i][j].height height := make([]int, len(matrix[0])) for i := 0; i &lt; len(matrix); i++ { for j := range height { height[j] = (height[j] + 1) * int(matrix[i][j]-'0') // update height if height[j] &gt; 0 { minHeight := height[j] for k := j; k &gt;= 0 &amp;&amp; height[k] &gt; 0; k-- { // loop valid width minHeight = min(minHeight, height[k]) s := minHeight * (j - k + 1) if result &lt; s { result = s } } } } } return } func min(a, b int) (result int) { if a &lt; b { result = a } else { result = b } return } /* 作者：mats9693 链接：https://leetcode-cn.
  
  <div class="read-more-link">
    <a href="/posts/leetcode/0085.maximal-rectangle/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/sword_offer/24/">24</a>
  </h1>
  <time datetime="2021-03-10T23:55:31&#43;0800" class="post-date">2021-03-10 23:55:31</time>
  /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func reverseList(head *ListNode) *ListNode { var newHead *ListNode cur:=head var next *ListNode for cur!=nil{ next=cur.Next cur.Next=newHead newHead=cur cur=next } return newHead }  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0013.roman-to-integer/">0013.roman-to-integer</a>
  </h1>
  <time datetime="2021-03-10T23:53:27&#43;0800" class="post-date">2021-03-10 23:53:27</time>
  import java.util.*; class Solution { public int romanToInt(String s) { int sum = 0; int preNum = getValue(s.charAt(0)); for(int i = 1;i &lt; s.length(); i ++) { int num = getValue(s.charAt(i)); if(preNum &lt; num) { sum -= preNum; } else { sum += preNum; } preNum = num; } sum += preNum; return sum; } private int getValue(char ch) { switch(ch) { case 'I': return 1; case 'V': return 5; case 'X': return 10; case 'L': return 50; case 'C': return 100; case 'D': return 500; case 'M': return 1000; default: return 0; } } } /* 作者：donespeak 链接：https://leetcode-cn.
  
  <div class="read-more-link">
    <a href="/posts/leetcode/0013.roman-to-integer/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0141.linked-list-cycle/">0141.linked-list-cycle</a>
  </h1>
  <time datetime="2021-03-10T23:50:40&#43;0800" class="post-date">2021-03-10 23:50:40</time>
  func hasCycle(head *ListNode) bool { if head == nil || head.Next == nil { return false } slow, fast := head, head.Next for fast != slow { if fast == nil || fast.Next == nil { return false } slow = slow.Next fast = fast.Next.Next } return true }  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0309.best-time-to-buy-and-sell-stock-with-cooldown/">0309.best-time-to-buy-and-sell-stock-with-cooldown</a>
  </h1>
  <time datetime="2021-03-10T23:40:55&#43;0800" class="post-date">2021-03-10 23:40:55</time>
  func maxProfit(prices []int) int { if len(prices) == 0 { return 0 } n := len(prices) // f[i][0]: 手上持有股票的最大收益 // f[i][1]: 手上不持有股票，并且处于冷冻期中的累计最大收益 // f[i][2]: 手上不持有股票，并且不在冷冻期中的累计最大收益 f := make([][3]int, n) f[0][0] = -prices[0] for i := 1; i &lt; n; i++ { f[i][0] = max(f[i-1][0], f[i-1][2] - prices[i]) f[i][1] = f[i-1][0] + prices[i] f[i][2] = max(f[i-1][1], f[i-1][2]) } return max(f[n-1][1], f[n-1][2]) } func max(x, y int) int { if x &gt; y { return x } return y } /* 作者：LeetCode-Solution 链接：https://leetcode-cn.
  
  <div class="read-more-link">
    <a href="/posts/leetcode/0309.best-time-to-buy-and-sell-stock-with-cooldown/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0152.maximum-product-subarray/">0152.maximum-product-subarray</a>
  </h1>
  <time datetime="2021-03-10T23:21:48&#43;0800" class="post-date">2021-03-10 23:21:48</time>
  import( &quot;math&quot; ) func maxProduct(nums []int) int { dpMin:=make([]int, len(nums), len(nums)) dpMax:=make([]int, len(nums), len(nums)) rst:=math.MinInt32 for i:=0; i&lt;len(nums); i++{ if i==0{ dpMin[i]=nums[i] dpMax[i]=nums[i] }else{ dpMax[i]=getMax(nums[i], nums[i]*dpMin[i-1], nums[i]*dpMax[i-1]) dpMin[i]=getMin(nums[i], nums[i]*dpMin[i-1], nums[i]*dpMax[i-1]) } rst=getMax(rst, dpMax[i]) } return rst } func getMax(a int, s... int)int{ for _, v:=range s{ if a&lt;v{ a=v } } return a } func getMin(a int, s... int)int{ for _, v:=range s{ if a&gt;v{ a=v } } return a }  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0082.remove-duplicates-from-sorted-list-ii/">0082.remove-duplicates-from-sorted-list-ii</a>
  </h1>
  <time datetime="2021-03-10T23:13:32&#43;0800" class="post-date">2021-03-10 23:13:32</time>
  /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func deleteDuplicates(head *ListNode) *ListNode { dummy:=&amp;ListNode{} dummy.Next=head cur:=dummy for cur.Next!=nil{ left:=cur.Next right:=cur.Next for right.Next!=nil &amp;&amp; right.Next.Val==left.Val{ right=right.Next } if left!=right{ cur.Next=right.Next }else{ cur=cur.Next } } return dummy.Next }  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0394.decode-string/">0394.decode-string</a>
  </h1>
  <time datetime="2021-03-10T22:51:08&#43;0800" class="post-date">2021-03-10 22:51:08</time>
  https://leetcode-cn.com/problems/decode-string/solution/decode-string-fu-zhu-zhan-fa-di-gui-fa-by-jyd/
func decodeString(s string) string { stack:=&amp;Stack{ raw: make([]*Elem, 0), } str:=&quot;&quot; multi:=0 sBytes:=[]byte(s) for _, v:=range sBytes{ switch { case v=='[': stack.Push(&amp;Elem{CurMulti: multi, LastStr: str}) multi=0 str=&quot;&quot; case v==']': curElem:=stack.Pop() str=curElem.LastStr+multiStr(str, curElem.CurMulti) case '0'&lt;=v &amp;&amp; v&lt;='9': multi=multi*10+int(v-'0') default: str+=string([]byte{v}) } } return str } type Elem struct{ CurMulti int LastStr string } func multiStr(s string, num int)string{ ret:=&quot;&quot; for i:=0; i&lt;num; i++{ ret+=s } return ret } type Stack struct{ raw []*Elem } func(s *Stack)Push(v *Elem){ s.
  
  <div class="read-more-link">
    <a href="/posts/leetcode/0394.decode-string/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0134.gas-station/">0134.gas-station</a>
  </h1>
  <time datetime="2021-03-10T22:27:01&#43;0800" class="post-date">2021-03-10 22:27:01</time>
  import( &quot;math&quot; ) // 最小前缀和，选一个油量最小的点，那么下一个点就是出发点 func canCompleteCircuit(gas []int, cost []int) int { n:=len(gas) curMin:=math.MaxInt64 curIdx:=-1 curGas:=0 for i:=0; i&lt;n; i++{ curGas+=gas[i]-cost[i] if curMin&gt;curGas{ curMin=curGas curIdx=i } } if curGas&lt;0{ return -1 } return (curIdx+1)%n }  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0091.decode-ways/">0091.decode-ways</a>
  </h1>
  <time datetime="2021-03-10T22:03:32&#43;0800" class="post-date">2021-03-10 22:03:32</time>
  func numDecodings(s string) int { sBytes:=[]byte(s) if len(sBytes)==0{ return 1 } if sBytes[0]=='0'{ return 0 } // dp[i+1]为第i个位置解码方法的总数 dp:=make([]int, len(sBytes)+1, len(sBytes)+1) dp[0]=1 dp[1]=1 for i:=1; i&lt;len(sBytes); i++{ switch sBytes[i]{ case '0': // 如果当前是 0 // 那么只有上一个是1/2的情况，编码才合法 if sBytes[i-1]=='1' || sBytes[i-1]=='2'{ dp[i+1]=dp[i-1] }else{ return 0 } default: // 两种情况: // 1. 当前字符自己解码 // 2. 当前字符跟前面的字符组合起来解码 // 如果这种情况成立，就是dp[i]+dp[i-1] if sBytes[i-1]=='1' || (sBytes[i-1]=='2' &amp;&amp; sBytes[i]&gt;='1' &amp;&amp; sBytes[i]&lt;='6'){ dp[i+1]=dp[i]+dp[i-1] }else{ dp[i+1]=dp[i] } } } return dp[len(dp)-1] } /* class Solution { public: int numDecodings(string s) { if (s[0] == '0') return 0; vector&lt;int&gt; dp(s.
  
  <div class="read-more-link">
    <a href="/posts/leetcode/0091.decode-ways/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0162.find-peak-element/">0162.find-peak-element</a>
  </h1>
  <time datetime="2021-03-10T21:37:30&#43;0800" class="post-date">2021-03-10 21:37:30</time>
  func findPeakElement(nums []int) int { left:=0 right:=len(nums)-1 for left&lt;right{ mid:=left+(right-left)/2 // 峰值一定存在于大值的一边，比如 nums[mid]&gt;nums[mid+1] // 那么峰值在nums[mid]一边，也既 right=mid； 否则left=mid+1 if nums[mid]&gt;nums[mid+1]{ right=mid }else{ left=mid+1 } } return left }  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0064.minimum-path-sum/">0064.minimum-path-sum</a>
  </h1>
  <time datetime="2021-03-10T21:17:31&#43;0800" class="post-date">2021-03-10 21:17:31</time>
  func minPathSum(grid [][]int) int { m:=len(grid) n:=len(grid[0]) dp:=make([][]int, 0, m) for i:=0; i&lt;m; i++{ dp=append(dp, make([]int, n, n)) } dp[0][0]=grid[0][0] for i:=1; i&lt;m; i++{ dp[i][0]+=dp[i-1][0]+grid[i][0] } for j:=1; j&lt;n; j++{ dp[0][j]+=dp[0][j-1]+grid[0][j] } // printM(dp) for i:=1; i&lt;m; i++{ for j:=1; j&lt;n; j++{ dp[i][j]=getMin(dp[i-1][j], dp[i][j-1])+grid[i][j] } } return dp[m-1][n-1] } // func printM(a [][]int){ // fmt.Println(&quot;-----&quot;) // for _, v:=range a{ // fmt.Printf(&quot;%+v\n&quot;, v) // } // } func getMin(a int, s .
  
  <div class="read-more-link">
    <a href="/posts/leetcode/0064.minimum-path-sum/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0101.symmetric-tree/">0101.symmetric-tree</a>
  </h1>
  <time datetime="2021-03-10T21:07:38&#43;0800" class="post-date">2021-03-10 21:07:38</time>
  /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func isSymmetric(root *TreeNode) bool { if root==nil{ return true } return helper(root.Left, root.Right) } func helper(node1, node2 *TreeNode)bool{ if node1==nil &amp;&amp; node2==nil{ return true } if node1==nil || node2==nil{ return false } return node1.Val==node2.Val &amp;&amp; helper(node1.Left, node2.Right) &amp;&amp; helper(node1.Right, node2.Left) }  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/sword_offer/03/">03</a>
  </h1>
  <time datetime="2021-03-10T21:00:34&#43;0800" class="post-date">2021-03-10 21:00:34</time>
  func findRepeatNumber(nums []int) int { for idx:=0; idx&lt;len(nums); idx++{ // 正常排序后，应该是nums[i]=i, 如果不成立，就交换 i与nums[i]位置的数据，如果这俩数据相等，就可以返回 if idx!=nums[idx]{ i:=idx j:=nums[idx] if nums[i]==nums[j]{ return nums[i] } nums[i], nums[j]=nums[j], nums[i] } } return -1 }  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0113.path-sum-ii/">0113.path-sum-ii</a>
  </h1>
  <time datetime="2021-03-10T20:50:02&#43;0800" class="post-date">2021-03-10 20:50:02</time>
  /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func pathSum(root *TreeNode, targetSum int) [][]int { rst:=make([][]int, 0) curPath:=make([]int, 0) var dfs func(node *TreeNode, curSum int) dfs=func(node *TreeNode, curSum int){ if node==nil{ return } curPath=append(curPath, node.Val) defer func(){ curPath=curPath[:len(curPath)-1] }() curSum-=node.Val if curSum==0 &amp;&amp; node.Left==nil &amp;&amp; node.Right==nil{ tmpRst:=make([]int, len(curPath), len(curPath)) copy(tmpRst, curPath) rst=append(rst, tmpRst) return } dfs(node.
  
  <div class="read-more-link">
    <a href="/posts/leetcode/0113.path-sum-ii/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0424.longest-repeating-character-replacement/">0424.longest-repeating-character-replacement</a>
  </h1>
  <time datetime="2021-03-10T20:11:31&#43;0800" class="post-date">2021-03-10 20:11:31</time>
  func characterReplacement(s string, k int) int { cnt := [26]int{} maxCnt, left := 0, 0 rst:=0 for right, ch := range s { cnt[ch-'A']++ maxCnt = max(maxCnt, cnt[ch-'A']) for left&lt;right &amp;&amp; right-left+1-maxCnt &lt;= k { rst=max(right-left+1, rst) cnt[s[left]-'A']-- maxCnt = max(maxCnt, cnt[s[left]-'A']) left++ } } return rst } func max(a, b int) int { if a &gt; b { return a } return b }  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0240.search-a-2d-matrix-ii/">0240.search-a-2d-matrix-ii</a>
  </h1>
  <time datetime="2021-03-10T19:40:17&#43;0800" class="post-date">2021-03-10 19:40:17</time>
  func searchMatrix(matrix [][]int, target int) bool { if len(matrix)==0{ return false } i:=0 j:=len(matrix[0])-1 for i&lt;len(matrix) &amp;&amp; j&gt;=0{ if matrix[i][j]==target{ return true } if matrix[i][j]&lt;target{ i++ } else { j-- } } return false }  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0695.max-area-of-island/">0695.max-area-of-island</a>
  </h1>
  <time datetime="2021-03-10T19:31:34&#43;0800" class="post-date">2021-03-10 19:31:34</time>
  func maxAreaOfIsland(grid [][]int) int { m:=len(grid) n:=len(grid[0]) rst:=0 var bt func(i, j int)int bt=func(i, j int)int{ if i&lt;0 || i&gt;=m || j&lt;0 || j&gt;=n{ return 0 } if grid[i][j]!=1{ return 0 } ans:=1 // 统计过了就设置为1，下次不会统计了 grid[i][j]=-1 dirs:=[][]int{{0, 1}, {0, -1}, {1, 0}, {-1, 0}} for _, v:=range dirs{ newI:=i+v[0] newJ:=j+v[1] ans+=bt(newI, newJ) } return ans } for i:=0; i&lt;m; i++{ for j:=0; j&lt;n; j++{ if grid[i][j]==0{ continue } curRst:=bt(i, j) if rst&lt;curRst{ rst=curRst } } } return rst }  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0088.merge-sorted-array/">0088.merge-sorted-array</a>
  </h1>
  <time datetime="2021-03-10T18:24:35&#43;0800" class="post-date">2021-03-10 18:24:35</time>
  func merge(nums1 []int, m int, nums2 []int, n int) { for i:=0; i&lt;n; i++{ j:=m-1+i for ; j&gt;=0; j--{ if nums1[j]&gt;nums2[i]{ nums1[j+1]=nums1[j] }else{ break } } nums1[j+1]=nums2[i] } }  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0069.sqrtx/">0069.sqrtx</a>
  </h1>
  <time datetime="2021-03-10T18:05:37&#43;0800" class="post-date">2021-03-10 18:05:37</time>
  func mySqrt(x int) int { l:=0 r:=x ans:=-1 // 这里是小于等于 for l&lt;=r{ mid:=l+(r-l)/2 // 这里是小于等于 if mid*mid&lt;=x{ ans=mid l=mid+1 }else{ r=mid-1 } } return ans }  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0006.zigzag-conversion/">0006.zigzag-conversion</a>
  </h1>
  <time datetime="2021-03-10T17:55:31&#43;0800" class="post-date">2021-03-10 17:55:31</time>
  // 可以看做每 2*numRows-2 个元素，是一轮 func convert(s string, numRows int) string { if numRows==1{ return s } rst:=make([][]byte, 0, numRows) for i:=0; i&lt;numRows; i++{ rst=append(rst, make([]byte, 0)) } sBytes:=[]byte(s) for i:=0; i&lt;len(sBytes); i++{ modValue:=i%(2*numRows-2) if modValue&lt;numRows{ rst[modValue]=append(rst[modValue], sBytes[i]) }else{ targetValue:=(numRows-1) - (modValue-(numRows-1)) rst[targetValue]=append(rst[targetValue], sBytes[i]) } } rstStr:=&quot;&quot; for _, v:=range rst{ rstStr+=string(v) } return rstStr }  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0236.lowest-common-ancestor-of-a-binary-tree/">0236.lowest-common-ancestor-of-a-binary-tree</a>
  </h1>
  <time datetime="2021-03-10T17:46:07&#43;0800" class="post-date">2021-03-10 17:46:07</time>
  /** * Definition for TreeNode. * type TreeNode struct { * Val int * Left *ListNode * Right *ListNode * } */ func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode { if root==nil{ return nil } if root.Val==p.Val || root.Val==q.Val{ return root } left:=lowestCommonAncestor(root.Left, p, q) right:=lowestCommonAncestor(root.Right, p, q) if left!=nil &amp;&amp; right!=nil{ return root } if left!=nil{ return left } return right }  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0009.palindrome-number/">0009.palindrome-number</a>
  </h1>
  <time datetime="2021-03-10T17:30:05&#43;0800" class="post-date">2021-03-10 17:30:05</time>
  func isPalindrome(x int) bool { return x==reverse(x) } func reverse(x int)int{ ret:=0 for x&gt;0{ ret=ret*10+x%10 x=x/10 } return ret }  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0008.string-to-integer-atoi/">0008.string-to-integer-atoi</a>
  </h1>
  <time datetime="2021-03-10T17:27:19&#43;0800" class="post-date">2021-03-10 17:27:19</time>
  func myAtoi(str string) int { return convert(clean(str)) } func clean(s string) (sign int, abs string) { // 先去除首尾空格 s = strings.TrimSpace(s) if s == &quot;&quot; { return } // 判断第一个字符 switch s[0] { // 有效的 case '0', '1', '2', '3', '4', '5', '6', '7', '8', '9': sign, abs = 1, s // 有效的，正号 case '+': sign, abs = 1, s[1:] // 有效的，负号 case '-': sign, abs = -1, s[1:] // 无效的，当空字符处理，并且直接返回 default: abs = &quot;&quot; return } for i, b := range abs { // 遍历第一波处理过的字符，如果直到第i个位置有效，那就取s[:i]，从头到这个有效的字符，剩下的就不管了，也就是break掉 // 比如 s=123abc，那么就取123，也就是s[:3] if b &lt; '0' || '9' &lt; b { abs = abs[:i] // 一定要break，因为后面的就没用了 break } } return } // 接收的输入是已经处理过的纯数字 func convert(sign int, absStr string) int { absNum := 0 for _, b := range absStr { // b - '0' ==&gt; 得到这个字符类型的数字的真实数值的绝对值 absNum = absNum*10 + int(b-'0') // 检查溢出 switch { case sign == 1 &amp;&amp; absNum &gt; math.
  
  <div class="read-more-link">
    <a href="/posts/leetcode/0008.string-to-integer-atoi/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0198.house-robber/">0198.house-robber</a>
  </h1>
  <time datetime="2021-03-10T17:15:05&#43;0800" class="post-date">2021-03-10 17:15:05</time>
  func rob(nums []int) int { if len(nums)==0{ return 0 } dp:=make([]int, len(nums)+1, len(nums)+1) dp[1]=nums[0] for i:=1; i&lt;len(nums); i++{ dp[i+1]=getMax(dp[i], nums[i]+dp[i-1]) } return dp[len(dp)-1] } func getMax(a, b int)int{ if a&gt;b{ return a } return b }  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0347.top-k-frequent-elements/">0347.top-k-frequent-elements</a>
  </h1>
  <time datetime="2021-03-10T17:06:38&#43;0800" class="post-date">2021-03-10 17:06:38</time>
  func topKFrequent(nums []int, k int) []int { value2Num:=make(map[int]int, len(nums)) for _, v:=range nums{ value2Num[v]++ } elems:=make([]*Elem, 0, len(nums)) for value, num:=range value2Num{ elems=append(elems, &amp;Elem{ Value: value, Num: num, }) } qsort(elems, 0, len(elems)-1, k) rst:=make([]int, 0, k) for i:=0; i&lt;k; i++{ rst=append(rst, elems[i].Value) } return rst } type Elem struct{ Value int Num int } func qsort(elems []*Elem, left, right, k int){ //fmt.Printf(&quot;left:%d, right:%d, k:%d\n&quot;, left, right, k) if left&lt;right{ p:=partition(elems, left, right) if p==k-1{ return } // 这里是快排，p已经在位置上了，需要解决[left, p)与(p, right]俩子问题 // 如果k-1&lt;p， 也就是想要的数在左边，就只处理左边的数据 if k-1&lt;p{ qsort(elems, left, p-1, k) }else{ qsort(elems, p+1, right, k) } } } func partition(elems []*Elem, left, right int)int{ pivot:=elems[right] i:=left-1 j:=left for ;j&lt;right; j++{ if elems[j].
  
  <div class="read-more-link">
    <a href="/posts/leetcode/0347.top-k-frequent-elements/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0329.longest-increasing-path-in-a-matrix/">0329.longest-increasing-path-in-a-matrix</a>
  </h1>
  <time datetime="2021-03-10T16:44:54&#43;0800" class="post-date">2021-03-10 16:44:54</time>
  http://zxi.mytechroad.com/blog/dynamic-programming/leetcode-329-longest-increasing-path-in-a-matrix/
func longestIncreasingPath(matrix [][]int) int { m:=len(matrix) n:=len(matrix[0]) dp:=make([][]int, 0, m) for i:=0; i&lt;m; i++{ dp=append(dp, make([]int, n, n)) } for i:=0; i&lt;m; i++{ for j:=0; j&lt;n; j++{ dp[i][j]=-1 } } rst:=0 dirs:=[][]int{{0, 1}, {0, -1}, {1, 0}, {-1, 0}} var dfs func(i, j int)int dfs=func(i, j int)int{ if dp[i][j]!=-1{ return dp[i][j] } dp[i][j]=1 for _, dir:=range dirs{ newI:=i+dir[0] newJ:=j+dir[1] if newI&lt;0 || newI&gt;=m || newJ&lt;0 || newJ&gt;=n{ continue } if matrix[newI][newJ]&lt;=matrix[i][j]{ continue } // 注意，这里是 dfs(newI, newJ)+1, 而不是 dp[newI][newJ] dp[i][j]=getMax(dp[i][j], dfs(newI, newJ)+1) } // fmt.
  
  <div class="read-more-link">
    <a href="/posts/leetcode/0329.longest-increasing-path-in-a-matrix/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0078.subsets/">0078</a>
  </h1>
  <time datetime="2021-03-10T16:05:29&#43;0800" class="post-date">2021-03-10 16:05:29</time>
  func subsets(nums []int) [][]int { rst:=make([][]int, 0) var dfs func(curIdx int) curRst:=make([]int, 0, len(nums)) dfs=func(curIdx int){ if curIdx==len(nums){ // 既然copy的是curRst,那么tmpRst的长度就跟curRst一样 tmpRst:=make([]int, len(curRst), len(curRst)) copy(tmpRst, curRst) rst=append(rst, tmpRst) return } // 要么有这个元素 curRst=append(curRst, nums[curIdx]) dfs(curIdx+1) // 要么没有这个元素 curRst=curRst[:len(curRst)-1] dfs(curIdx+1) } dfs(0) return rst }  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0128.longest-consecutive-sequence/">0128.longest-consecutive-sequence</a>
  </h1>
  <time datetime="2021-03-10T15:49:05&#43;0800" class="post-date">2021-03-10 15:49:05</time>
  /* 举个例子: nums: 100, 4, 200, 1, 3, 2 line22 m:map[100:1] line22 m:map[4:1 100:1] line22 m:map[4:1 100:1 200:1] line22 m:map[1:1 4:1 100:1 200:1] line22 m:map[1:1 3:2 4:2 100:1 200:1] line22 m:map[1:4 2:4 3:2 4:4 100:1 200:1] 最终效果就是: 对于连续的数组: [i, j] (且[i-1, j][i, j+1]都不是) map里的map[i], map[j]一定是最长的连续序列的长度 */ func longestConsecutive(nums []int) int { maxLen := 0 m := make(map[int]int) for _, v := range nums { _, ok := m[v] if ok { continue } leftLen := m[v-1] rightLen := m[v+1] curLen := leftLen + rightLen + 1 m[v] = curLen maxLen = getMax(maxLen, curLen) // 更新左右边界的值，因为下次用到的话，一定是只用到边界 m[v-leftLen] = curLen m[v+rightLen] = curLen // fmt.
  
  <div class="read-more-link">
    <a href="/posts/leetcode/0128.longest-consecutive-sequence/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0543.diameter-of-binary-tree/">0543.diameter-of-binary-tree</a>
  </h1>
  <time datetime="2021-03-10T15:29:09&#43;0800" class="post-date">2021-03-10 15:29:09</time>
  /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func diameterOfBinaryTree(root *TreeNode) int { if root==nil{ return 0 } rst:=0 var getDepth func(root *TreeNode)int getDepth=func(root *TreeNode)int{ if root==nil{ return 0 } left:=getDepth(root.Left) right:=getDepth(root.Right) rst=getMax(rst, left+right) return getMax(left, right)+1 } getDepth(root) return rst } func getMax(a, b int)int{ if a&gt;b{ return a } return b }  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0322.coin-change/">0322.coin-change</a>
  </h1>
  <time datetime="2021-03-10T15:09:43&#43;0800" class="post-date">2021-03-10 15:09:43</time>
  dfs func coinChange(coins []int, amount int) int { if amount == 0 { return 0 } sort.Slice(coins, func(i, j int) bool { return coins[i] &gt; coins[j] }) ans := math.MaxInt32 var dfs func(coins []int, curAmount, curCoinIndex, curCount int) dfs = func(coins []int, curAmount, curCoinIndex, curCount int) { if curAmount == 0 { ans = getMin(ans, curCount) return } if curCoinIndex == len(coins) { return } for k := curAmount / coins[curCoinIndex]; k &gt;= 0 &amp;&amp; (k+curCount) &lt; ans; k-- { dfs(coins, curAmount-k*coins[curCoinIndex], curCoinIndex+1, curCount+k) } } dfs(coins, amount, 0, 0) if ans == math.
  
  <div class="read-more-link">
    <a href="/posts/leetcode/0322.coin-change/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0175.combine-two-tables/">0175.combine-two-tables</a>
  </h1>
  <time datetime="2021-03-10T14:30:50&#43;0800" class="post-date">2021-03-10 14:30:50</time>
  select FirstName, LastName, City, State from Person left join Address on Person.PersonId = Address.PersonId ;  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0300.longest-increasing-subsequence/">0300.longest-increasing-subsequence</a>
  </h1>
  <time datetime="2021-03-10T14:28:58&#43;0800" class="post-date">2021-03-10 14:28:58</time>
  func lengthOfLIS(nums []int) int { numLen := len(nums) if numLen &lt;= 1 { return numLen } // 长度为i+1的递增子序列，的最后一个元素 tail := make([]int, numLen, numLen) tail[0] = nums[0] end := 0 for i := 1; i &lt; numLen; i++ { if nums[i] &gt; tail[end] { end++ tail[end] = nums[i] } else { left := 0 right := end for left &lt; right { mid := left + (right-left)/2 if nums[i] &lt;= tail[mid] { right = mid } else { left = mid + 1 } } // fmt.
  
  <div class="read-more-link">
    <a href="/posts/leetcode/0300.longest-increasing-subsequence/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0112.path-sum/">0112.path-sum</a>
  </h1>
  <time datetime="2021-03-10T13:33:22&#43;0800" class="post-date">2021-03-10 13:33:22</time>
  /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func hasPathSum(root *TreeNode, targetSum int) bool { if root==nil { return false } if root.Left==nil &amp;&amp; root.Right==nil &amp;&amp; root.Val==targetSum{ return true } return hasPathSum(root.Left, targetSum-root.Val) || hasPathSum(root.Right, targetSum-root.Val) }  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0093.restore-ip-addresses/">0093.restore-ip-addresses</a>
  </h1>
  <time datetime="2021-03-10T13:14:56&#43;0800" class="post-date">2021-03-10 13:14:56</time>
  func restoreIpAddresses(s string) []string { rst := make([]string, 0) var dfs func(curRst []string, start int) dfs = func(curRst []string, start int) { if len(curRst) == 4 { if start == len(s) { rst = append(rst, strings.Join(curRst, &quot;.&quot;)) return } else { return } } for length := 1; length &lt;= 3; length++ { // 2+2 2 3 4 if start+length &gt; len(s) { return } curStr := s[start : start+length] if length &gt; 1 &amp;&amp; curStr[0] == '0' { return } curNum, _ := strconv.
  
  <div class="read-more-link">
    <a href="/posts/leetcode/0093.restore-ip-addresses/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0445.add-two-numbers-ii/">0445.add-two-numbers-ii</a>
  </h1>
  <time datetime="2021-03-10T12:52:31&#43;0800" class="post-date">2021-03-10 12:52:31</time>
  /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode { if l1==nil{ return l2 } if l2==nil{ return l1 } l1Stack:=getStackFromList(l1) l2Stack:=getStackFromList(l2) carry:=0 dummy:=&amp;ListNode{} for !l1Stack.Empty() || !l2Stack.Empty() || carry&gt;0{ cur:=carry if !l1Stack.Empty(){ cur+=l1Stack.Pop() } if !l2Stack.Empty(){ cur+=l2Stack.Pop() } newNode:=&amp;ListNode{ Val: cur%10, } carry=cur/10 newNode.Next=dummy.Next dummy.Next=newNode } return dummy.Next } func getStackFromList(l *ListNode)*Stack{ stack:=&amp;Stack{ raw: make([]int, 0), } for l!
  
  <div class="read-more-link">
    <a href="/posts/leetcode/0445.add-two-numbers-ii/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0415.add-strings/">0415.add-strings</a>
  </h1>
  <time datetime="2021-03-10T12:38:19&#43;0800" class="post-date">2021-03-10 12:38:19</time>
  func addStrings(num1 string, num2 string) string { num1Bytes:=[]byte(num1) num2Bytes:=[]byte(num2) carry:=0 // 需要从后面往前计算，因为最后一位都是个位 i:=len(num1)-1 j:=len(num2)-1 rst:=make([]byte, 0) for i&gt;=0 || j&gt;=0 || carry&gt;0{ cur:=carry if i&gt;=0{ cur+=int(num1Bytes[i]-'0') i-- } if j&gt;=0{ cur+=int(num2Bytes[j]-'0') j-- } carry=cur/10 cur=cur%10 rst=append(rst, byte(cur+'0')) } return string(reverseBytes(rst)) } func reverseBytes(s [] byte)[]byte{ if len(s)&lt;=1{ return s } left:=0 right:=len(s)-1 for left&lt;right{ s[left], s[right]=s[right], s[left] left++ right-- } return s }  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0160.intersection-of-two-linked-lists/">0160.intersection-of-two-linked-lists</a>
  </h1>
  <time datetime="2021-03-10T12:26:32&#43;0800" class="post-date">2021-03-10 12:26:32</time>
  遍历A+B跟遍历B+A A=1, 3, 5, 7, 8 B=2, 6, 7, 8 A与B的最后一部分肯定相同，所以第一个相同的就是交叉点 A+B: 1 3 5 7 8 2 6 7 8 B+A: 2 6 7 8 1 3 5 7 8  /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func getIntersectionNode(headA, headB *ListNode) *ListNode { pA:=headA pB:=headB for pA!=pB{ if pA!=nil{ pA=pA.Next }else{ pA=headB } if pB!=nil{ pB=pB.
  
  <div class="read-more-link">
    <a href="/posts/leetcode/0160.intersection-of-two-linked-lists/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0023.merge-k-sorted-lists/">0023.merge-k-sorted-lists</a>
  </h1>
  <time datetime="2021-03-10T12:15:16&#43;0800" class="post-date">2021-03-10 12:15:16</time>
  /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func mergeKLists(lists []*ListNode) *ListNode { if len(lists)==0{ return nil } if len(lists)==1{ return lists[0] } // 看做left=0, right=len(lists)-1 mid:=(len(lists)-1+0)/2 // mid放在第一段里， [left, mid] (mid, right] left:=mergeKLists(lists[:mid+1]) right:=mergeKLists(lists[mid+1:]) return merge2List(left, right) } func merge2List(l1, l2 *ListNode)*ListNode{ // 一定要判断下l1,l2是否有nil的情况 if l1==nil{ return l2 } if l2==nil{ return l1 } dummy:=&amp;ListNode{} tail:=dummy for l1!
  
  <div class="read-more-link">
    <a href="/posts/leetcode/0023.merge-k-sorted-lists/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0143.reorder-list/">0143.reorder-list</a>
  </h1>
  <time datetime="2021-03-10T11:56:29&#43;0800" class="post-date">2021-03-10 11:56:29</time>
  /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func reorderList(head *ListNode) { if head==nil || head.Next==nil{ return } firstPart, secondPart:=cutMid(head) secondPart=reverseList(secondPart) dummy:=&amp;ListNode{} tail:=dummy for firstPart!=nil &amp;&amp; secondPart!=nil{ tail.Next=firstPart firstPart=firstPart.Next tail=tail.Next tail.Next=secondPart secondPart=secondPart.Next tail=tail.Next } if firstPart!=nil{ tail.Next=firstPart } } // 1 2 3 4 5 // s // f func cutMid(head *ListNode)(*ListNode, *ListNode){ fast:=head slow:=head for fast!=nil &amp;&amp; fast.
  
  <div class="read-more-link">
    <a href="/posts/leetcode/0143.reorder-list/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0054.spiral-matrix/">0054.spiral-matrix</a>
  </h1>
  <time datetime="2021-03-10T11:46:17&#43;0800" class="post-date">2021-03-10 11:46:17</time>
  func spiralOrder(matrix [][]int) []int { allNums:=len(matrix)*len(matrix[0]) left:=0 right:=len(matrix[0])-1 top:=0 bottom:=len(matrix)-1 rst:=make([]int, 0, allNums) for allNums&gt;0{ for i:=left; i&lt;=right &amp;&amp;allNums&gt;0; i++{ rst=append(rst, matrix[top][i]) allNums-- } top++ for i:=top; i&lt;=bottom &amp;&amp;allNums&gt;0; i++{ rst=append(rst, matrix[i][right]) allNums-- } right-- // i的左边界是left，不是0 for i:=right; i&gt;=left &amp;&amp;allNums&gt;0; i--{ rst=append(rst, matrix[bottom][i]) allNums-- } bottom-- for i:=bottom; i&gt;=top &amp;&amp;allNums&gt;0; i--{ rst=append(rst, matrix[i][left]) allNums-- } left++ } return rst }  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0200.number-of-islands/">0200</a>
  </h1>
  <time datetime="2021-03-10T11:31:02&#43;0800" class="post-date">2021-03-10 11:31:02</time>
  func numIslands(grid [][]byte) int { rst:=0 for i:=0; i&lt;len(grid); i++{ for j:=0; j&lt;len(grid[0]); j++{ if grid[i][j]=='0'{ continue } rst++ delIsland(grid, i, j) } } return rst } func delIsland(grid [][]byte, i, j int){ // 千万别忘记这一个，如果是0, 直接返回，不然直接死循环 if grid[i][j]=='0'{ return } grid[i][j]='0' dirs:=[][]int{{0, 1},{0, -1},{1, 0},{-1, 0}} for _, dir:=range dirs{ newI:=i+dir[0] newJ:=j+dir[1] if newI&gt;=0 &amp;&amp; newI&lt;len(grid) &amp;&amp; newJ&gt;=0 &amp;&amp; newJ&lt;len(grid[0]){ delIsland(grid, newI, newJ) } } }  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0007.reverse-integer/">0007.reverse-integer</a>
  </h1>
  <time datetime="2021-03-10T11:17:01&#43;0800" class="post-date">2021-03-10 11:17:01</time>
  func reverse(x int) int { ret := 0 for x != 0 { ret = ret*10 + x % 10 x /= 10 if ret &lt; math.MinInt32 || ret &gt; math.MaxInt32 { return 0 } } return ret }  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0176.second-highest-salary/">0176</a>
  </h1>
  <time datetime="2021-03-10T11:07:10&#43;0800" class="post-date">2021-03-10 11:07:10</time>
  SELECT (SELECT DISTINCT Salary FROM Employee ORDER BY Salary DESC LIMIT 1 OFFSET 1) AS SecondHighestSalary  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0020.valid-parentheses/">0020.valid-parentheses</a>
  </h1>
  <time datetime="2021-03-10T11:02:58&#43;0800" class="post-date">2021-03-10 11:02:58</time>
  func isValid(s string) bool { sBytes:=[]byte(s) stack:=&amp;Stack{ raw: make([]byte, 0, len(sBytes)), } for _, v:=range sBytes{ switch(v){ case '(': stack.Push(v) case ')': if stack.Empty(){ return false } if stack.Top()=='('{ stack.Pop() }else{ stack.Push(v) } case '[': stack.Push(v) case ']': if stack.Empty(){ return false } if stack.Top()=='['{ stack.Pop() }else{ stack.Push(v) } case '{': stack.Push(v) case '}': if stack.Empty(){ return false } if stack.Top()=='{'{ stack.Pop() }else{ stack.Push(v) } } } return stack.Empty() } type Stack struct{ raw []byte } func (s *Stack)Push(v byte){ s.
  
  <div class="read-more-link">
    <a href="/posts/leetcode/0020.valid-parentheses/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0221.maximal-square/">0221.maximal-square</a>
  </h1>
  <time datetime="2021-03-10T10:52:31&#43;0800" class="post-date">2021-03-10 10:52:31</time>
  func maximalSquare(matrix [][]byte) int { dp:=make([][]int, 0, len(matrix)) for i:=0; i&lt;len(matrix); i++{ dp=append(dp, make([]int, len(matrix[0]), len(matrix[0]))) } rst:=0 for i:=0; i&lt;len(matrix); i++{ for j:=0; j&lt;len(matrix[0]); j++{ if matrix[i][j]=='0'{ continue } if i==0 || j==0{ dp[i][j]=1 }else{ dp[i][j]=getMin(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])+1 } if rst&lt;dp[i][j]{ rst=dp[i][j] } } } return rst*rst } func getMin(a int, s ... int)int{ ret:=a for _, v:=range s{ if ret&gt;v{ ret=v } } return ret }  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/algo/cut_woods_k_n/">Cut_woods_k_n</a>
  </h1>
  <time datetime="2021-03-10T10:24:24&#43;0800" class="post-date">2021-03-10 10:24:24</time>
  https://blog.csdn.net/weixin_39590058/article/details/108397552
给定数组，每个元素代表一个木头的长度，木头可以任意截断， 从这堆木头中截出至少k个相同长度为m的木块，已知k，求max(m)  二分查找 数组排序后，mid=最小值+(最大值-最小值)/2 试一试mid能不能可以，如果不可以，说明mid太大，右边界=mid-1 如果可以，说明mid还可以继续扩大试试，左边界=mid+1  package main import ( &quot;fmt&quot; &quot;sort&quot; ) func main() { nums := []int{4, 7, 2, 10, 5} k := 5 rst := maxM(nums, k) fmt.Printf(&quot;rst: %d\n&quot;, rst) } func maxM(nums []int, k int) int { if len(nums) == 0 { return 0 } sort.Slice(nums, func(i, j int) bool { return nums[i] &gt; nums[j] }) max := nums[0] min := nums[len(nums)-1] lo := min hi := max ans := -1 for lo &lt;= hi { mid := lo + (hi-lo)/2 if isFit(nums, k, mid) { ans = mid lo = mid + 1 } else { hi = mid - 1 } } return ans } func isFit(nums []int, k int, v int) bool { count := 0 for i := 0; i &lt; len(nums); i++ { count += nums[i] / v if count &gt;= k { return true } } return false } func getMin(a, b int) int { if a &lt; b { return a } return b } func getMax(a, b int) int { if a &gt; b { return a } return b }  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/algo/36_multiplication/">36_multiplication</a>
  </h1>
  <time datetime="2021-03-10T10:23:10&#43;0800" class="post-date">2021-03-10 10:23:10</time>
  https://leetcode-cn.com/circle/discuss/I8NZUx/
import ( &quot;fmt&quot; ) func main() { num1 := &quot;11&quot; num2 := &quot;12&quot; rst := addStrings(num1, num2) fmt.Printf(&quot;rst: %s\n&quot;, rst) } func addStrings(num1, num2 string) string { lookup := make([]byte, 0, 36) for i := byte('0'); i &lt;= '9'; i++ { lookup = append(lookup, i) } for i := byte('a'); i &lt;= 'z'; i++ { lookup = append(lookup, i) } carry := 0 num1Bytes := []byte(num1) num2Bytes := []byte(num2) i := len(num1Bytes) - 1 j := len(num2Bytes) - 1 reversedRst := make([]byte, 0) for i &gt;= 0 || j &gt;= 0 || carry &gt; 0 { cur := carry if i &gt;= 0 { cur += byte2Number(num1Bytes[i]) i-- } if j &gt;= 0 { cur += byte2Number(num2Bytes[j]) j-- } carry = cur / 36 cur = cur % 36 if cur &gt;= 0 &amp;&amp; cur &lt; len(lookup) { reversedRst = append(reversedRst, lookup[cur]) } } return string(reverseBytes(reversedRst)) } func reverseBytes(s []byte) []byte { if len(s) &lt;= 1 { return s } i := 0 j := len(s) - 1 for i &lt; j { s[i], s[j] = s[j], s[i] i++ j-- } return s } func byte2Number(b byte) int { if '0' &lt;= b &amp;&amp; b &lt;= '9' { return int(b - '0') } if 'a' &lt;= b &amp;&amp; b &lt;= 'z' { return int(b-'a') + 10 } return 0 }  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0102.binary-tree-level-order-traversal/">0012</a>
  </h1>
  <time datetime="2021-03-10T00:05:49&#43;0800" class="post-date">2021-03-10 00:05:49</time>
  /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func levelOrder(root *TreeNode) [][]int { rst:=make([][]int, 0) q:=make([]*TreeNode, 0) q=append(q, root) for len(q)&gt;0{ nextQ:=make([]*TreeNode, 0) curRst:=make([]int, 0) for i:=0; i&lt;len(q); i++{ curRst=append(curRst, q[i].Val) if q[i].Left!=nil{ nextQ=append(nextQ, q[i].Left) } if q[i].Right!=nil{ nextQ=append(nextQ, q[i].Right) } } rst=append(rst, curRst) q=nextQ } return rst }  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0022.generate-parentheses/">0022</a>
  </h1>
  <time datetime="2021-03-09T23:47:50&#43;0800" class="post-date">2021-03-09 23:47:50</time>
  var rst []string func generateParenthesis(n int) []string { rst=make([]string, 0) cur:=make([]byte, 0, n*2) bt(cur, n, n) return rst } func bt(s []byte, openNum, closeNum int){ fmt.Printf(&quot;s:%+v, openNum:%d closeNum:%d\n&quot;, s, openNum, closeNum) if openNum==0 &amp;&amp; closeNum==0{ rst=append(rst, string(s)) return } if openNum&gt;0 { openNum-- s=append(s, '(') bt(s, openNum, closeNum) s=s[:len(s)-1] openNum++ } // 剩下的close的个数要大于open if closeNum&gt;0 &amp;&amp; openNum&lt;closeNum{ closeNum-- s=append(s, ')') bt(s, openNum, closeNum) s=s[:len(s)-1] closeNum++ } }  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0079.word-search/">0079</a>
  </h1>
  <time datetime="2021-03-09T23:22:34&#43;0800" class="post-date">2021-03-09 23:22:34</time>
  func exist(board [][]byte, word string) bool { for i:=0; i&lt;len(board); i++{ for j:=0; j&lt;len(board[0]); j++{ if findWord(board, i, j, word){ return true } } } return false } func findWord(board [][]byte, i, j int, word string)bool{ visited:=make([][]bool, 0, len(board)) for i:=0; i&lt;len(board); i++{ visited=append(visited, make([]bool, len(board[0]), len(board[0]))) } dirs:=[][]int{ {0, 1}, {0, -1}, {1, 0}, {-1, 0}, } wordBytes:=[]byte(word) var inner func(i, j, k int)bool inner = func(i, j, k int)bool{ if wordBytes[k]!
  
  <div class="read-more-link">
    <a href="/posts/leetcode/0079.word-search/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0739-daily-temperatures/">0739 Daily Temperatures</a>
  </h1>
  <time datetime="2021-03-09T23:19:44&#43;0800" class="post-date">2021-03-09 23:19:44</time>
  func dailyTemperatures(T []int) []int { if len(T)==0{ return []int{} } ret:=make([]int, len(T)) s:=&amp;Stack{ raw: make([]int, 0), } s.Push(0) for i:=1; i&lt;len(T); i++{ for !s.Empty() &amp;&amp; T[s.Top()]&lt;T[i]{ targetIdx:=s.Pop() ret[targetIdx]=i-targetIdx } s.Push(i) } return ret } type Stack struct{ raw []int } func (s *Stack)Empty()bool{ return len(s.raw)==0 } func (s *Stack)Push(v int){ s.raw=append(s.raw, v) } func (s *Stack)Pop()int{ ret:=s.raw[len(s.raw)-1] s.raw=s.raw[:len(s.raw)-1] return ret } func (s *Stack)Top()int{ return s.raw[len(s.raw)-1] }  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0019.remove-nth-node-from-end-of-list/">0019</a>
  </h1>
  <time datetime="2021-03-09T23:17:58&#43;0800" class="post-date">2021-03-09 23:17:58</time>
  /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func removeNthFromEnd(head *ListNode, n int) *ListNode { if head==nil{ return nil } dummy:=&amp;ListNode{} dummy.Next=head fastNode:=dummy slowNode:=dummy for i:=0; i&lt;n; i++{ fastNode=fastNode.Next } for fastNode.Next!=nil{ fastNode=fastNode.Next slowNode=slowNode.Next } slowNode.Next=slowNode.Next.Next return dummy.Next }  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0033.search-in-rotated-sorted-array/">0033</a>
  </h1>
  <time datetime="2021-03-07T14:15:20&#43;0800" class="post-date">2021-03-07 14:15:20</time>
  func search(nums []int, target int) int { left:=0 right:=len(nums)-1 for left&lt;=right{ mid:=(left+right)/2 if nums[mid]==target{ return mid } // 分为两种情况，要么左边是有序的(左半边，最左侧数据&lt;=最右侧数据)，要是是右边 if nums[left]&lt;=nums[mid]{ // 在左侧数据里，既然是有序的，如果target在左侧左右边界里，那么right=mid // 否则就不在左侧，那么left=mid+1 if nums[left]&lt;=target &amp;&amp; target&lt;=nums[mid]{ right=mid }else{ left=mid+1 } }else{ if nums[mid+1]&lt;=target &amp;&amp; target&lt;=nums[right]{ left=mid+1 }else{ right=mid } } } return -1 }  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0005.longest-palindromic-substring/">0005</a>
  </h1>
  <time datetime="2021-03-06T22:30:31&#43;0800" class="post-date">2021-03-06 22:30:31</time>
  func longestPalindrome(s string) string { start:=0 end:=0 sBytes:=[]byte(s) dp:=make([][]bool, 0, len(sBytes)) for i:=0; i&lt;len(sBytes); i++{ dp=append(dp, make([]bool, len(sBytes), len(sBytes))) } for l:=0; l&lt;len(sBytes); l++{ for i:=0; i+l&lt;len(sBytes); i++{ j:=i+l if l==0{ dp[i][j]=true }else if l==1{ if sBytes[i]==sBytes[j]{ dp[i][j]=true } }else{ if sBytes[i]==sBytes[j]{ dp[i][j]=dp[i+1][j-1] } } if dp[i][j] &amp;&amp; end-start&lt;j-i{ end=j start=i } } } return string(sBytes[start:end+1]) }  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0015.3sum/">0015.3sum</a>
  </h1>
  <time datetime="2021-03-06T22:28:39&#43;0800" class="post-date">2021-03-06 22:28:39</time>
  import( &quot;sort&quot; ) func threeSum(nums []int) [][]int { sort.Ints(nums) res:=make([][]int, 0) if len(nums)&lt;=2{ return res } for i:=0; i&lt;len(nums)-2; i++{ // 这里不会存在，0， 0， 0， 0，结果没有数据的原因，是 // i&lt;len(nums)-2, i不会从0走到len(nums)-1 if i&gt;0 &amp;&amp; nums[i]==nums[i-1] { continue } left:=i+1 right:=len(nums)-1 target:=-1*nums[i] for left&lt;right{ if nums[left]+nums[right]==target{ res=append(res, []int{nums[i], nums[left], nums[right]}) // 有结果之后要去重， 没有结果的时候不能去重，比如0， 0， 0， 0...因为都一样，直接去重就都没了 for left&lt;right &amp;&amp; nums[left]==nums[left+1]{ left++ } for left&lt;right &amp;&amp; nums[right]==nums[right-1]{ right-- } left++ right-- }else if nums[left]+nums[right]&lt;target{ left++ }else{ right-- } } } return res }  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0031.next-permutation/">0031</a>
  </h1>
  <time datetime="2021-03-06T21:43:31&#43;0800" class="post-date">2021-03-06 21:43:31</time>
  func nextPermutation(nums []int) { if len(nums)&lt;=1{ return } /* 举个例子： 0 1 2 3 4 1 2 5 8 7 step1: 从后往前，找第一个相邻的升序对(nums[i], nums[i+1]), 这里是5，8, i=2 step2: 在i的右侧，从右往前，找第一个大于nums[i]的数nums[j],这里是7， j=4 step3: 交换i, j 得到 0 1 2 3 4 1 2 7 8 5 step4: reverse(i+1, len(nums)-1) 得到： 1 2 7 5 8 */ i:=len(nums)-2 // 从后面开始，找第一个相邻的升序对 for i&gt;=0 &amp;&amp; nums[i]&gt;=nums[i+1]{ i-- } if i&gt;=0{ j:=len(nums)-1 for j&gt;i &amp;&amp; nums[i]&gt;=nums[j]{ j-- } nums[i], nums[j]=nums[j], nums[i] } reverse(nums, i+1, len(nums)-1) } func reverse(nums []int, left, right int){ for left&lt;right{ nums[left], nums[right]=nums[right], nums[left] left++ right-- } } // 1 2 5 8 7  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0440.k-th-smallest-in-lexicographical-order/">0440.k-th-smallest-lexicographical-order</a>
  </h1>
  <time datetime="2021-03-06T18:47:29&#43;0800" class="post-date">2021-03-06 18:47:29</time>
  1func findKthNumber(n int, k int) int { 2	// 第一个数字一定是1 3	cur:=1 4	k-- 5	for k&gt;0{ 6	nodes:=countNodes(n, cur) 7	if k&lt;nodes{ 8 // ...k...nodes... 9 // 第k个元素在cur的孩子节点中，因此下降到自己的孩子节点，k-1表示刨去cur节点(root节点) 10	k-- 11	cur*=10 12	}else{ 13 // ...nodes...k... 14 // cur的子节点的个数小于k，说明第k个节点不在自己的孩子节点内部，cur++表示转向自己的兄弟节点 15	k-=nodes 16	cur++ 17	} 18	} 19	return cur 20} 21// 以cur为根节点，且最大值为n的十叉树中，有多少个元素 22// 比如下面，以x为root的树(咱们记作tree(x))的所有节点个数, 就等于各个层(从第0层到第N层)的节点的个数的和 23// x+1为root的树是x的右边的第一棵树, 记作tree(x+1) 24// 有意思的是： 对于第i层， 且i&lt;N， tree(x)的第i层的节点的个数等于= tree(x+1)的第i层的第一个节点 - tree(x)的第i层的第一个节点 25// 对于第N层，节点个数= n - tree(x)的第N层的第一个节点 + 1 因为从0开始计数，所以要加1 26// 上面合起来就是： 取 MIN( tree(x+1).
  
  <div class="read-more-link">
    <a href="/posts/leetcode/0440.k-th-smallest-in-lexicographical-order/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0206.reverse-linked-list/">0206</a>
  </h1>
  <time datetime="2021-03-06T18:33:10&#43;0800" class="post-date">2021-03-06 18:33:10</time>
  func reverseList(head *ListNode) *ListNode { var newHead *ListNode cur:=head for cur!=nil{ next:=cur.Next cur.Next=newHead newHead=cur cur=next } return newHead }  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0002.add-two-numbers/">0002</a>
  </h1>
  <time datetime="2021-03-06T16:50:28&#43;0800" class="post-date">2021-03-06 16:50:28</time>
  /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode { dummy:=&amp;ListNode{} tail:=dummy carry:=0 for l1!=nil || l2!=nil{ n1:=0 n2:=0 if l1!=nil{ n1=l1.Val l1=l1.Next } if l2!=nil{ n2=l2.Val l2=l2.Next } curRst:=n1+n2+carry tail.Next=&amp;ListNode{ Val: curRst%10, } tail=tail.Next carry=curRst/10 } // 千万别忘了，最后可能还有进位 if carry!=0{ tail.Next=&amp;ListNode{ Val: carry, } } return dummy.Next }  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0316.remove-duplicate-letters/">0316</a>
  </h1>
  <time datetime="2021-03-06T15:57:34&#43;0800" class="post-date">2021-03-06 15:57:34</time>
  as same as 1081
func removeDuplicateLetters(s string) string { if len(s)&lt;=1{ return s } sBytes:=[]byte(s) // 判断字符是否在栈中 inStack:=make([]bool, 256) // 判断当前剩下的字符中，每个字符还剩多少个 bytesNum:=make([]int, 256) for _, v:=range sBytes{ bytesNum[v]++ } // 变量名不要跟参数重复 stack:=&amp;Stack{ raw: make([]byte, 0), } for _, v:=range sBytes{ // 只要遍历到，剩下的v的个数就要-- bytesNum[v]-- // 已经在栈中了，就不管了 if inStack[v]{ continue } // 如果栈顶元素t比当前v大，且后面还有栈顶元素t，那与其tv, 还不如vt, 后者字典序更小，因此直接pop出t for stack.Len()&gt;0 &amp;&amp; stack.Top()&gt;v &amp;&amp; bytesNum[stack.Top()]&gt;0{ //fmt.Printf(&quot;pop: %c\n&quot;, stack.Top()) inStack[stack.Pop()]=false } stack.Push(v) // fmt.Printf(&quot;stack: %s\n&quot;, string(stack.raw)) inStack[v]=true } return string(stack.
  
  <div class="read-more-link">
    <a href="/posts/leetcode/0316.remove-duplicate-letters/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0407.trapping-rain-water-ii/">0407</a>
  </h1>
  <time datetime="2021-03-06T15:11:56&#43;0800" class="post-date">2021-03-06 15:11:56</time>
  有youtue视频，讲解的很好 https://happygirlzt.com/code/407.html
a b c d e f g h i j k l 对于a, b,  import( &quot;container/heap&quot; ) /* a b c d e f g h i j k l 对于矩阵， a b c d e i h l i j k l 等边界位置，不可能存住水 我们把边界的情况压入优先队列，那么pop出的第一个元素，一定是height最小的，记作curCell 因为一个位置的存水量，取决于四周最矮的高度 因此可以算curCell四个方向的结果，遍历4次，每次的target记作tRow, tCol, tVal target的值为 max(0, curCell.Val-tVal) 然后将target存到优先队列里，因为这个位置的水已经存上去了，高度就变成 max(curVal, tVal) 如果担心某个target位置的存水量会变化，比如 4 4 4 4 4 4 3 3 3 4 4 3 2 3 4 4 3 3 3 4 4 4 4 4 4 担心2第一次存水量算作1，因为周围是3，但是最外层是4，所以应该是2 但是实际上，2不会比3先弹出来， 因为优先队列里存的都是边界，从边界开始向内计算，会先算3的存水量，然后更新成4， 所以2的存水量是正确的 */ */ type Cell struct{ row int col int val int } type PQ struct{ cells []Cell } func(p *PQ)Len()int{ return len(p.
  
  <div class="read-more-link">
    <a href="/posts/leetcode/0407.trapping-rain-water-ii/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0055.jump-game/">0055</a>
  </h1>
  <time datetime="2021-03-06T14:23:40&#43;0800" class="post-date">2021-03-06 14:23:40</time>
  func canJump(nums []int) bool { // 记录当前位置之前能够到达的最远索引 maxPosition:=0 for i:=0; i&lt;len(nums); i++{ // 如果i大于当前能够到达的最远索引，说明没法到达了 // 因为游戏继续进行下去的前提是能够到达i， // i&gt;maxPosition 表示当前的跳远最远距离都到达不了索引i了 if i&gt;maxPosition{ return false } maxPosition=getMax(maxPosition, i+nums[i]) } return true } func getMax(a, b int)int{ if a&gt;b{ return a } return b }  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0045.jump-game-ii/">0045</a>
  </h1>
  <time datetime="2021-03-06T13:43:02&#43;0800" class="post-date">2021-03-06 13:43:02</time>
  func jump(nums []int) int { end:=0 steps:=0 maxPosition:=0 for i:=0; i&lt;len(nums)-1; i++{ maxPosition=getMax(maxPosition, i+nums[i]) if i==end{ end=maxPosition steps++ } } return steps } func getMax(a, b int)int{ if a&gt;b{ return a } return b }  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/403/">403</a>
  </h1>
  <time datetime="2021-03-05T17:13:02&#43;0800" class="post-date">2021-03-05 17:13:02</time>
  package main import &quot;fmt&quot; func canCross(stones []int) bool { // stone2Prevs 表示石头，到上一次跳到这块石头上的步数的集合 stone2Prevs:=make(map[int]map[int]struct{}, len(stones)) for _, v:=range stones{ stone2Prevs[v]=make(map[int]struct{}) } stone2Prevs[stones[0]][0]= struct{}{} for i:=0; i&lt;len(stones); i++{ // 跳到这一块石头的上一次的步数的集合 prevs:=stone2Prevs[stones[i]] for prev, _:=range prevs{ for curStep:=prev-1; curStep&lt;=prev+1; curStep++{ // 向左跳或者不动是非法的 if curStep&lt;=0{ continue } // 下一跳的位置 nextStone:=stones[i]+curStep // 如果这个位置没有石头，就continue if _, ok:=stone2Prevs[nextStone]; !ok{ continue } stone2Prevs[nextStone][curStep]= struct{}{} } } } return len(stone2Prevs[stones[len(stones)-1]])&gt;0 } func main(){ var stones []int stones=[]int{0,1,3,5,6,8,12,17} stones=[]int{0,1,2,3,4,5,6,12} stones=[]int{0,2} fmt.
  
  <div class="read-more-link">
    <a href="/posts/leetcode/403/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0092/">0092</a>
  </h1>
  <time datetime="2021-03-05T15:11:12&#43;0800" class="post-date">2021-03-05 15:11:12</time>
  // reverse m~n
func reverseBetween(head *ListNode, m, n int) *ListNode { dummy := &amp;ListNode{} dummy.Next = head // m-1+1 比如dummy-&gt;1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6 m=2, n=5 // m=2其实是取前m-1个，因为m属于第二部分 // 由于dummy的存在，需要加一个1跳过dummy firstPartTail, secondPartHead := splitN(dummy, m-1+1) // n-m+1 因为n跟m都属于第二部分，所以总共有n-m+1个元素 _, thirdPartHead := splitN(secondPartHead, n-m+1) //printList(&quot;secondPartHead&quot;, secondPartHead) //printList(&quot;thirdPartHead&quot;, thirdPartHead) reversedSecondPartHead := reverseList(secondPartHead) reversedSecondPartTail := secondPartHead firstPartTail.Next = reversedSecondPartHead reversedSecondPartTail.Next = thirdPartHead return dummy.Next } // 比如 dummy-&gt;1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6 k=3 // 就是取前三个，然后断开，分成两部分: // dummy-&gt;1-&gt;2 与 3-&gt;4-&gt;5-&gt;6 // 然后返回第一部分的最后一个: 2 // 跟第二部分第一个：3 func splitN(head *ListNode, k int) (*ListNode, *ListNode) { k-- cur := head for cur !
  
  <div class="read-more-link">
    <a href="/posts/leetcode/0092/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/480/">480.sliding-window-median</a>
  </h1>
  <time datetime="2021-03-04T11:41:45&#43;0800" class="post-date">2021-03-04 11:41:45</time>
  package main import ( &quot;container/heap&quot; &quot;fmt&quot; ) func top(h *MyHeap) int { elem := heap.Pop(h).(int) heap.Push(h, elem) return elem } func getMid(firstHeap, secondHeap *MyHeap, k int) float64 { firstElem := top(firstHeap) if k%2 == 1 { return float64(firstElem) } secondElem := top(secondHeap) return float64(secondElem+firstElem) / 2 } func medianSlidingWindow(nums []int, k int) []float64 { /* if k == 0 { return nil } if k == 1 { numsFloat64 := make([]float64, 0, len(nums)) for _, v := range nums { numsFloat64 = append(numsFloat64, float64(v)) } return numsFloat64 } if len(nums) &lt; k { return nil } */ firstHeap := NewHeap(make([]int, 0), func(a, b int) bool { return a &gt; b }) secondHeap := NewHeap(make([]int, 0), func(a, b int) bool { return a &lt; b }) for i := 0; i &lt; k; i++ { heap.
  
  <div class="read-more-link">
    <a href="/posts/leetcode/480/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/golang/heap/">Heap</a>
  </h1>
  <time datetime="2021-03-04T11:34:19&#43;0800" class="post-date">2021-03-04 11:34:19</time>
  package main import ( &quot;container/heap&quot; &quot;fmt&quot; ) // An IntHeap is a min-heap of ints. type IntHeap []int func (h IntHeap) Len() int { return len(h) } func (h IntHeap) Less(i, j int) bool { return h[i] &lt; h[j] } func (h IntHeap) Swap(i, j int) { h[i], h[j] = h[j], h[i] } func (h *IntHeap) Push(x interface{}) { // Push and Pop use pointer receivers because they modify the slice's length, // not just its contents.
  
  <div class="read-more-link">
    <a href="/posts/golang/heap/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/algo/kmp/">Kmp</a>
  </h1>
  <time datetime="2021-03-04T11:26:13&#43;0800" class="post-date">2021-03-04 11:26:13</time>
  package main import ( &quot;fmt&quot; ) func main() { s := &quot;atoddasdfasdtodd&quot; p := &quot;abab&quot; rst := match(s, p) fmt.Printf(&quot;rst: %+v\n&quot;, rst) } func match(s, p string) []int { nxt := build(p) ret := make([]int, 0) for i, j := 0, 0; i &lt; len(s); i++ { for j &gt; 0 &amp;&amp; s[i] != p[j] { j = nxt[j] } if s[i] == p[j] { j++ } if j == len(p) { ret = append(ret, i-len(p)+1) j = nxt[j] } } return ret } // build would build the next array // a b a b // 0 0 0 1 2 // nxt[i]表示，p[:i]字符串，最长的相同的前缀跟后缀的长度 // 比如nxt[3], p[:3]=&quot;aba&quot;, 前缀a，跟后缀a // 比如nxt[4], p[:4]=&quot;abab&quot;, 前缀ab，跟后缀ab func build(p string) []int { ret := make([]int, 0, len(p)) ret = append(ret, 0) ret = append(ret, 0) for i, j := 1, 0; i &lt; len(p); i++ { for j &gt; 0 &amp;&amp; p[i] !
  
  <div class="read-more-link">
    <a href="/posts/algo/kmp/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/redis/eviction/">Eviction</a>
  </h1>
  <time datetime="2021-03-03T17:42:48&#43;0800" class="post-date">2021-03-03 17:42:48</time>
  volatile: 易变的;无定性的;无常性的;可能急剧波动的;不稳定的;易恶化的;易挥发的;易发散的 lru: Least Recently Used 默认策略是 volatile-lru，即超过最大内存后，在过期键中使用 lru 算法进行 key 的剔除，保证不过期数据不被删除，但是可能会出现 OOM 问题。 allkeys-lru：根据 LRU 算法删除键，不管数据有没有设置超时属性，直到腾出足够空间为止。 allkeys-random：随机删除所有键，直到腾出足够空间为止。 volatile-random:随机删除过期键，直到腾出足够空间为止。 volatile-ttl：根据键值对象的 ttl 属性，删除最近将要过期数据。如果没有，回退到 noeviction 策略。 noeviction：不会剔除任何数据，拒绝所有写入操作并返回客户端错误信息&quot;(error) OOM command not allowed when used memory&quot;，此时 Redis 只响应读操作。  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/redis/command/">Command</a>
  </h1>
  <time datetime="2021-03-03T15:37:35&#43;0800" class="post-date">2021-03-03 15:37:35</time>
  Available since 1.0.0. Time complexity: O(1) Set key to hold the string value. If key already holds a value, it is overwritten, regardless of its type. Any previous time to live associated with the key is discarded on successful SET operation. Options The SET command supports a set of options that modify its behavior: EX seconds -- Set the specified expire time, in seconds. PX milliseconds -- Set the specified expire time, in milliseconds.
  
  <div class="read-more-link">
    <a href="/posts/redis/command/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/mysql/type/">Type</a>
  </h1>
  <time datetime="2021-03-03T14:50:40&#43;0800" class="post-date">2021-03-03 14:50:40</time>
  varchar不定长度 存储: 实际字符串，加上1/2/3字节的字符串长度 &quot; a &quot; 取出来也是&quot; a &quot;, 长度是3 对于未指定varchar字段not null的表，会有1个字节专门表示该字段是否为null char定长 存储: 实际字符串 &quot; a &quot; 取出来也是&quot; a&quot;, 长度是2 因为定长，默认就是空格，a后面的空格，分不清是用户指定输入的，还是默认值 mysql&gt; create table test_string ( -&gt; char_value char(5), -&gt; varchar_value varchar(5), -&gt; text_value text default &quot;&quot;) engine=innodb charset=utf8; ERROR 1101 (42000): BLOB, TEXT, GEOMETRY or JSON column 'text_value' can't have a default value mysql&gt; varchar和text两种数据类型，使用建议是能用varchar就用varchar而不用text（存储效率高），varchar(M)的M有长度限制，之前说过，如果大于限制，可以使用mediumtext（16M）或者longtext（4G）。 至于text和blob，简单过一下就是text存储的是字符串而blob存储的是二进制字符串，简单说blob是用于存储例如图片、音视频这种文件的二进制数据的。  mysql&gt; create table td(a decimal(10,5)); Query OK, 0 rows affected (0.02 sec) mysql&gt; insert into td(a) values(1.
  
  <div class="read-more-link">
    <a href="/posts/mysql/type/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/mysql/base/">Base</a>
  </h1>
  <time datetime="2021-03-03T14:12:14&#43;0800" class="post-date">2021-03-03 14:12:14</time>
    
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/algo/segment-tree/">Segment Tree</a>
  </h1>
  <time datetime="2021-03-02T15:14:44&#43;0800" class="post-date">2021-03-02 15:14:44</time>
  n(i) represents the node number of binary tree having i child/s sum = n(0)+n(1)+n(2) 另一个角度，所有节点分两类： 孩子节点， 非孩子节点(有且只有一个，就是root节点) n(1)*1就是有一个孩子节点的所有节点的孩子总数 n(2)*2就是有两个孩子节点的所有节点的孩子总数 sum = sum(孩子节点) + sum(非孩子节点) =n(1)+2*n(2) + 1 因此n(0)+n(1)+n(2)=n(1)+2*n(2)+1 =&gt; n(0)=n(2)+1 对于线段树，n(1)=0 然后对于输入的原始数组，长度为N，也就是n(0)=N， n(2)=n(0)-1=N-1 最好情况，满二叉树： sum = n(0)+n(2)=N+N-1=2N-1 最坏情况: x / \ a x // 倒数第二层 / \ a a // 倒数第一层 倒数第二层的a类型的节点个数:(N-2) 倒数第二层以及上面的节点个数: sum(倒数第二层以及以上) = 2(N-2)+1=2N-4+1=2N-3 sum(倒数第二层节点个数, 虽有只有两个，但是因为是数组，前面全部填空) = (N-2)*2=2N-4 所以sum=2N-3+2N-4=4N-7 所以4N个肯定够用了  package main import &quot;fmt&quot; var merge func(v1, v2 int) int type Node struct { start int end int value int left *Node right *Node } func buildTree(start, end int, vals []int) *Node { if start == end { return &amp;Node{ start: start, end: end, value: vals[start], } } mid := start + (end-start)/2 leftChild := buildTree(start, mid, vals) rightChild := buildTree(mid+1, end, vals) return &amp;Node{ start: start, end: end, value: merge(leftChild.
  
  <div class="read-more-link">
    <a href="/posts/algo/segment-tree/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/algo/binary-index-tree/">Binary Index Tree</a>
  </h1>
  <time datetime="2021-03-02T13:53:38&#43;0800" class="post-date">2021-03-02 13:53:38</time>
  package main import &quot;fmt&quot; type BinaryIndexTree struct { raw []int } // lowbit的作用： // x的二进制表示： xxxx...10...0 // 返回 10...0 // 换句话说，返回二进制表示形式中，最低位1所组成的数字 func lowbit(x int) int { return x &amp; (-1 * x) } // Build创建 假设原始数组是s, 新的数组是a 为了方便，全部假设下标从1开始计数 // 1 第三层root // 1 5 第二层root // 1 3 5 7 第一层root // 1 2 3 4 5 6 7 8 新数组的下标，为了方便，从1开始计数，浪费下标0 // // 对于给定一个下标， // 对于奇数2i+1，a[2i+1]=s[2i+1] // // 换个角度，算下s[i]会影响数组a的哪些数值 // 答案：a[i]一定会被影响，然后影响右侧的包含s[i]的树 // 如何求i的右侧的第一棵树？ i+lowbit(i) 可以把i的二进制形式看做一颗树 // 1表示树，那么右侧第一棵树，就是i的最低位的1，这一位加1，就是右边第一棵树的索引 // 创建的时候，从左到右依次处理，那么每个元素只需要处理自己右侧最近的一棵树tree1即可(后面的树tree2,再计算tree1的时候，会修改tree2, 依次传递下去) func (b *BinaryIndexTree) Build(s []int) { b.
  
  <div class="read-more-link">
    <a href="/posts/algo/binary-index-tree/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0304.range-sum-query-2d-immutable/">0304.range-sum-query-2d-immutable</a>
  </h1>
  <time datetime="2021-03-02T13:44:15&#43;0800" class="post-date">2021-03-02 13:44:15</time>
  A00 A01 A02 A03 A10 A11 A12 A13 A20 A21 A22 A23 A30 A31 A32 A33 A21表示 i&lt;=2, j&lt;=1的矩形的和 // 需要判断下是否越界 如果要求A21 A21=(A11)+(A20)-(A10)+s[2][1] 如果求(i=1, j=1)跟(j=2, j=2)的和 和=A22-A12-A21+A11 如果求(i1, j1)跟(i2, j2)的和, 当然需要判断下边界 和=A[i2][j2]-A[i1-1][j2]-A[i2][j1-1]+A[i1-][j1-1]  type NumMatrix struct { raw [][]int } func Constructor(matrix [][]int) NumMatrix { if len(matrix)==0{ return NumMatrix{ raw: nil, } } raw := make([][]int, 0, len(matrix[0])) for i:=0; i&lt;len(matrix); i++{ raw=append(raw, make([]int, len(matrix[0]), len(matrix[0]))) } for i:=0; i&lt;len(matrix); i++{ for j:=0; j&lt;len(matrix[0]); j++{ raw[i][j]=matrix[i][j] if i&gt;0{ raw[i][j]+=raw[i-1][j] } if j&gt;0{ raw[i][j]+=raw[i][j-1] } if i&gt;0 &amp;&amp; j&gt;0{ raw[i][j]-=raw[i-1][j-1] } } } return NumMatrix{ raw: raw, } } func (this *NumMatrix) SumRegion(row1 int, col1 int, row2 int, col2 int) int { ret:=this.
  
  <div class="read-more-link">
    <a href="/posts/leetcode/0304.range-sum-query-2d-immutable/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0215.kth-largest-element-in-an-array/">0215</a>
  </h1>
  <time datetime="2021-03-01T20:00:04&#43;0800" class="post-date">2021-03-01 20:00:04</time>
  func findKthLargest(nums []int, k int) int { // kth内部从0开始算，第0大的数 return kth(nums, 0, len(nums)-1, k-1) } func kth(s []int, left, right, k int) int { if left &lt;= right { // 这里的m一定是s里的元素的索引 m := partition(s, left, right) if m == k { return s[m] } if m &lt; k { // 最后一个参数k return kth(s, m+1, right, k) } else { // 最后一个参数k return kth(s, left, m-1, k) } } return -1 } func partition(s []int, left, right int) int { i := left - 1 j := left pivot := s[right] for ; j &lt; right; j++ { if s[j] &gt; pivot { i = i + 1 s[i], s[j] = s[j], s[i] } } i = i + 1 s[i], s[j] = s[j], s[i] return i }  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0121.best-time-to-buy-and-sell-stock/">0121</a>
  </h1>
  <time datetime="2021-02-28T22:11:58&#43;0800" class="post-date">2021-02-28 22:11:58</time>
  func maxProfit(prices []int) int { if len(prices)==0{ return 0 } minPrice:=0 maxProfit:=0 minPrice=prices[0] for _, v:=range prices{ if minPrice&gt;v{ minPrice=v }else if maxProfit&lt; v-minPrice{ maxProfit=v-minPrice } } return maxProfit }  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0122.best-time-to-buy-and-sell-stock-ii/">0122.best-time-to-buy-and-sell-stock-ii</a>
  </h1>
  <time datetime="2021-02-28T21:55:34&#43;0800" class="post-date">2021-02-28 21:55:34</time>
  // dp[i][0]表示第i天结束后，不持有股票的最大收益 // dp[i][1]表示第i天结束后，持有股票的最大收益 func maxProfit(prices []int) int { n := len(prices) dp := make([][2]int, n) dp[0][1] = -prices[0] for i := 1; i &lt; n; i++ { // 第i天结束后不持有股票，有两种可能： // 1. 昨天就不持有股票 // 2. 昨天持有股票，今天卖掉了 dp[i][0] = max(dp[i-1][0], dp[i-1][1]+prices[i]) // 第i天结束后持有股票，有两种可能： // 1. 昨天就持有股票 // 2. 昨天不持有股票，今天又买进了 dp[i][1] = max(dp[i-1][1], dp[i-1][0]-prices[i]) } return dp[n-1][0] } func max(a, b int) int { if a &gt; b { return a } return b }  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0096.unique-binary-search-trees/">0096.unique-binary-search-trees</a>
  </h1>
  <time datetime="2021-02-26T15:57:23&#43;0800" class="post-date">2021-02-26 15:57:23</time>
  /* G(n): 长度为 n 的序列能构成的不同二叉搜索树的个数。 F(i, n): 以 i 为根、序列长度为 n 的不同二叉搜索树个数 G(n)=F(1, n)+F(2, n)+...+F(n, n) 1 2 3 ... i ... n A A A AAA BBB B F(i, n)=G(i-1)*G(n-i) ^^ F(i, n)， i已经是root了，那么i左边的部分A是left tree, i右边的部分B是right tree 从A组成的tree list里选一个，从B组成的tree list里选一种，总共就是两者相乘的可能数 i的范围是从1到n，对应到代码里，是从1到i, 因为求的是G[i], 此时n=i */ func numTrees(n int) int { G := make([]int, n + 1) G[0], G[1] = 1, 1 for i := 2; i &lt;= n; i++ { // for j := 1; j &lt;= i; j++ { G[i] += G[j-1] * G[i-j] } } return G[n] }  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0105.construct-binary-tree-from-preorder-and-inorder-traversal/">0105.construct-binary-tree-from-preorder-and-inorder-traversal</a>
  </h1>
  <time datetime="2021-02-26T15:37:56&#43;0800" class="post-date">2021-02-26 15:37:56</time>
  /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func buildTree(preorder []int, inorder []int) *TreeNode { if len(preorder)==0{ return nil } curNode:=&amp;TreeNode{ Val: preorder[0], } rootValIdxInInorder:=0 for idx, v:=range inorder{ if v==preorder[0]{ rootValIdxInInorder=idx break } } // 难在构建左子树、右子树函数的参数 // preorder: root A B // inorder: A root B // 所以找到A与B在preorder/inorder里的起始位置，再将A/B part作为参数即可 curNode.Left=buildTree(preorder[1:len(inorder[:rootValIdxInInorder])+1], inorder[:rootValIdxInInorder]) curNode.Right=buildTree(preorder[len(inorder[:rootValIdxInInorder])+1:], inorder[rootValIdxInInorder+1:]) return curNode }  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0103.binary-tree-zigzag-level-order-traversal/">0103.binary-tree-zigzag-level-order-traversal</a>
  </h1>
  <time datetime="2021-02-26T15:22:21&#43;0800" class="post-date">2021-02-26 15:22:21</time>
  /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func zigzagLevelOrder(root *TreeNode) [][]int { if root==nil{ return nil } ret:=make([][]int, 0) nextQ:=make([]*TreeNode, 0) nextQ=append(nextQ, root) level:=0 for len(nextQ)!=0{ curQ:=nextQ nextQ=make([]*TreeNode, 0) curVals:=make([]int, 0, len(curQ)) for i:=0; i&lt;len(curQ); i++{ curNode:=curQ[i] if curNode.Left!=nil{ nextQ=append(nextQ, curNode.Left) } if curNode.Right!=nil{ nextQ=append(nextQ, curNode.Right) } curVals=append(curVals, curNode.Val) } // 为了简单，直接根据层数的奇偶来做倒置 if level%2==1{ for i:=0; i&lt;len(curVals)/2; i++{ curVals[i], curVals[len(curVals)-i-1]=curVals[len(curVals)-i-1], curVals[i] } } ret=append(ret, curVals) level++ } return ret }  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0124.binary-tree-maximum-path-sum/">0124.binary-tree-maximum-path-sum</a>
  </h1>
  <time datetime="2021-02-26T14:58:35&#43;0800" class="post-date">2021-02-26 14:58:35</time>
  ```go /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ var ret int var retIsSet bool func maxPathSum(root *TreeNode) int { ret=0 retIsSet=false
helper(root) return ret  }
// 获得一定包含root，且以root为起点，且单边(左子树或右子树路径上单链，当然可以只包含root，比如root的下面的节点都是负数，就可以只包含root)的最大值 func helper(root *TreeNode) int { if root==nil{ return 0 }
// 如果helper(root.Left)为负数，还不如不包含后面的节点，直接设置为0 left:=getMax(0, helper(root.Left)) right:=getMax(0, helper(root.Right)) // 以root为最高层节点，的结果的最优值，只要遍历所有节点的最优值，且取最大值，即得到结果 curVal:=left+right+root.Val if retIsSet{ ret=getMax(ret, curVal) }else{ retIsSet=true ret=curVal } if left&gt;right{ return left+root.
  
  <div class="read-more-link">
    <a href="/posts/leetcode/0124.binary-tree-maximum-path-sum/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0199.binary_tree_right_side_view/">0199.binary-tree-right-side-view</a>
  </h1>
  <time datetime="2021-02-26T14:55:03&#43;0800" class="post-date">2021-02-26 14:55:03</time>
  需要区分二叉树的这一层下一层，准备俩queue，一个当前处理的curQ， 一个q存放从curQ里出来的node的孩子节点 然后curQ=q; q=nil 继续下一次循环
/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func rightSideView(root *TreeNode) []int { if root==nil{ return nil } ret:=make([]int, 0) q:=make([]*TreeNode, 0) q=append(q, root) for len(q)!=0{ curRst:=0 curQ:=q q=nil for i:=0; i&lt;len(curQ); i++{ curNode:=curQ[i] curRst=curNode.Val if curNode.Left!=nil{ q=append(q, curNode.Left) } if curNode.Right!=nil{ q=append(q, curNode.Right) } } ret=append(ret, curRst) } return ret }  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0025.reverse-nodes-in-k-group/">0025.reverse-nodes-in-k-group</a>
  </h1>
  <time datetime="2021-02-25T15:58:28&#43;0800" class="post-date">2021-02-25 15:58:28</time>
  1package main 2 3import &#34;fmt&#34; 4 5// Definition for singly-linked list. 6type ListNode struct { 7	Val int 8	Next *ListNode 9} 10 11func reverseKGroup(head *ListNode, k int) *ListNode { 12	if head==nil || head.Next==nil{ 13	return head 14	} 15	if k&lt;=1{ 16	return head 17	} 18 19	lastNode:=head 20	for i:=0; i &lt; k-1; i++ { 21	lastNode = lastNode.Next 22	if lastNode==nil{ 23	return head 24	} 25	} 26 27	// nextPartHead是下一段的开始节点 28	nextPartHead := lastNode.
  
  <div class="read-more-link">
    <a href="/posts/leetcode/0025.reverse-nodes-in-k-group/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/golang/pointer_struct/">Pointer_struct</a>
  </h1>
  <time datetime="2021-02-20T17:58:58&#43;0800" class="post-date">2021-02-20 17:58:58</time>
  package main import ( &quot;fmt&quot; ) type A struct { PointerValue string StructValue string } func (a *A) PointerSet(v string) { a.PointerValue = v } func (a A) StructSet(v string) { a.StructValue = v } func main() { s := A{PointerValue: &quot;beforeChange&quot;, StructValue: &quot;beforeChange&quot;} p := &amp;A{PointerValue: &quot;beforeChange&quot;, StructValue: &quot;beforeChange&quot;} fmt.Printf(&quot;s: %+v\n&quot;, s) // s: {PointerValue:beforeChange StructValue:beforeChange} // changed s.PointerSet(&quot;afterChange&quot;) // not changed s.StructSet(&quot;afterChange&quot;) fmt.Printf(&quot;s: %+v\n&quot;, s) // s: {PointerValue:afterChange StructValue:beforeChange} fmt.
  
  <div class="read-more-link">
    <a href="/posts/golang/pointer_struct/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/golang/interface_pointer_struct/">Interface_pointer_struct</a>
  </h1>
  <time datetime="2021-02-20T17:56:54&#43;0800" class="post-date">2021-02-20 17:56:54</time>
  package main import &quot;fmt&quot; type Inter interface { SetName(name string) } type A struct { Name string } func (a A) SetName(name string) { a.Name = name } type B struct { Name string } func (b *B) SetName(name string) { b.Name = name } func main() { var a Inter = A{Name: &quot;todd&quot;} a.SetName(&quot;alice&quot;) fmt.Printf(&quot;a: %+v\n&quot;, a) // ?相当于 SetName((复制ap然后解引用(*copy_ap)), &quot;alice&quot;) // ?修改的不是同一个值 // 修改失败 var ap Inter = &amp;A{Name: &quot;todd&quot;} ap.
  
  <div class="read-more-link">
    <a href="/posts/golang/interface_pointer_struct/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/golang/interface/">Interface</a>
  </h1>
  <time datetime="2021-02-19T11:05:14&#43;0800" class="post-date">2021-02-19 11:05:14</time>
  https://cmc.gitbook.io/go-internals/chapter-ii-interfaces
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0560.subarray-sum-equals-k/">0560.subarray-sum-equals-k</a>
  </h1>
  <time datetime="2020-12-31T17:01:26&#43;0800" class="post-date">2020-12-31 17:01:26</time>
  题目简介 给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。
示例 1 :
输入:nums = [1,1,1], k = 2 输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。 说明 :
数组的长度为 [1, 20,000]。 数组中元素的范围是 [-1000, 1000] ，且整数 k 的范围是 [-1e7, 1e7]。
解 golang func subarraySum(nums []int, k int) int { prefixSum2Freq:=make(map[int]int) prefixSum2Freq[0]=1 curPrefixSum:=0 rst:=0 for i:=0; i&lt;len(nums); i++{ curPrefixSum+=nums[i] // // line a 必须在 line b 之前，因为防止自己跟自己拼在了一起 rst+=prefixSum2Freq[curPrefixSum-k] // line b prefixSum2Freq[curPrefixSum]++ } return rst }  解1 1/* 2比如 ABCDEFG.
  
  <div class="read-more-link">
    <a href="/posts/leetcode/0560.subarray-sum-equals-k/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0435.non-overlapping-intervals/">0435.non-overlapping-intervals</a>
  </h1>
  <time datetime="2020-12-31T15:23:58&#43;0800" class="post-date">2020-12-31 15:23:58</time>
  示例 1: 输入: [ [1,2], [2,3], [3,4], [1,3] ] 输出: 1 解释: 移除 [1,3] 后，剩下的区间没有重叠。 示例 2: 输入: [ [1,2], [1,2], [1,2] ] 输出: 2 解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。 贪心策略: 先按照右边界从小到大排序，然后依次遍历，不能放进去的(左边界小于左边区间的右边界)，就删掉  1import ( 2	&#34;sort&#34; 3) 4 5// non-overlapping-intervals 6func eraseOverlapIntervals(intervals [][]int) int { 7	if len(intervals) == 0 { 8	return 0 9	} 10	sort.Slice(intervals, func(i, j int) bool { 11	return intervals[i][1] &lt; intervals[j][1] 12	}) 13 14	curRight := intervals[0][1] 15	ret := 0 16	for i := 1; i &lt; len(intervals); i++ { 17	if curRight &lt;= intervals[i][0] { 18	curRight = intervals[i][1] 19	} else { 20	ret++ 21	} 22	} 23	return ret 24} 
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0003.longest-substring-without-repeating-characters/">0003.longest-substring-without-repeating-characters</a>
  </h1>
  <time datetime="2020-12-30T20:48:41&#43;0800" class="post-date">2020-12-30 20:48:41</time>
  1func getMax(a, b int)int{ 2 if a&gt;b{ 3 return a 4 } 5 return b 6} 7func getMin(a, b int)int{ 8 if a&gt;b{ 9 return b 10 } 11 return a 12} 13 14func lengthOfLongestSubstring(s string) int { 15 lookup := make(map[rune]int) 16	curLeft := 0 17	maxLen := 0 18	for k, v := range s { 19	if lastIdx, ok := lookup[v]; ok { 20 curLeft=getMax(lastIdx+1, curLeft) 21	} 22 maxLen=getMax(maxLen, k-curLeft+1) 23 lookup[v]=k 24	} 25	return maxLen 26} 
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0004.median-of-two-sorted-arrays/">0004.median-of-two-sorted-arrays</a>
  </h1>
  <time datetime="2020-12-30T20:04:23&#43;0800" class="post-date">2020-12-30 20:04:23</time>
  示例 1： 输入：nums1 = [1,3], nums2 = [2] 输出：2.00000 解释：合并数组 = [1,2,3] ，中位数 2 示例 2： 输入：nums1 = [1,2], nums2 = [3,4] 输出：2.50000 解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5 示例 3： 输入：nums1 = [0,0], nums2 = [0,0] 输出：0.00000 示例 4： 输入：nums1 = [], nums2 = [1] 输出：1.00000 示例 5： 输入：nums1 = [2], nums2 = [] 输出：2.00000  1import ( 2	&#34;math&#34; 3) 4 5func findMedianSortedArrays(nums1 []int, nums2 []int) float64 { 6	left := (len(nums1) + len(nums2) + 1) / 2 7	right := (len(nums1) + len(nums2) + 2) / 2 8	return (float64(findK(nums1, 0, nums2, 0, left)) + float64(findK(nums1, 0, nums2, 0, right))) / 2.
  
  <div class="read-more-link">
    <a href="/posts/leetcode/0004.median-of-two-sorted-arrays/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0208.mplement-trie-prefix-tree/">0208.mplement-trie-prefix-tree</a>
  </h1>
  <time datetime="2020-12-30T19:12:02&#43;0800" class="post-date">2020-12-30 19:12:02</time>
  1type Node struct { 2	IsEnd bool 3	Val rune 4	Next map[rune]*Node 5} 6 7type Trie struct { 8	root *Node 9} 10 11/** Initialize your data structure here. */ 12func Constructor() Trie { 13	return Trie{ 14	root: &amp;Node{ 15	Next: make(map[rune]*Node), 16	}, 17	} 18} 19 20/** Inserts a word into the trie. */ 21func (this *Trie) Insert(word string) { 22	cur := this.root 23	for _, v := range word { 24	if nextNode, ok := cur.
  
  <div class="read-more-link">
    <a href="/posts/leetcode/0208.mplement-trie-prefix-tree/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/1035.uncrossed-lines/">1035.uncrossed-lines</a>
  </h1>
  <time datetime="2020-12-30T18:40:16&#43;0800" class="post-date">2020-12-30 18:40:16</time>
  给定 1 4 2 1 2 4 上下相同的数连接画一条线，最多只能画两条线 类似： 1143 本质是最长公共子序列  1func maxUncrossedLines(A []int, B []int) int { 2	dp := make([][]int, 0, len(A)+1) 3	for i := 0; i &lt; len(A)+1; i++ { 4	dp = append(dp, make([]int, len(B)+1, len(B)+1)) 5	} 6 7	for i, v1 := range A { 8	for j, v2 := range B { 9	if v1 == v2 { 10	dp[i+1][j+1] = dp[i][j] + 1 11	} else { 12	dp[i+1][j+1] = getMaxInt(dp[i+1][j], dp[i][j+1]) 13	} 14	} 15	} 16 17	return dp[len(A)][len(B)] 18} 19 20func getMaxInt(a, b int) int { 21	if a &gt; b { 22	return a 23	} 24	return b 25} 
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/1143.longest-common-subsequence/">1143.longest-common-subsequence</a>
  </h1>
  <time datetime="2020-12-30T18:32:29&#43;0800" class="post-date">2020-12-30 18:32:29</time>
  两个数组的 最长公共子序列 子序列：不一定连续 1143 子数组：一定连续 718 换汤不换药 1035  1func longestCommonSubsequence(text1 string, text2 string) int { 2	dp := make([][]int, 0, len(text1)+1) 3	for i := 0; i &lt; len(text1)+1; i++ { 4	dp = append(dp, make([]int, len(text2)+1, len(text2)+1)) 5	} 6 7	for i, ch1 := range text1 { 8	for j, ch2 := range text2 { 9	if ch1 == ch2 { 10	dp[i+1][j+1] = dp[i][j] + 1 11	} else { 12	dp[i+1][j+1] = getMaxInt(dp[i+1][j], dp[i][j+1]) 13	} 14	} 15	} 16 17	return dp[len(text1)][len(text2)] 18} 19 20func getMaxInt(a, b int) int { 21	if a &gt; b { 22	return a 23	} 24	return b 25} 
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0718.maximum-length-of-repeated-subarray/">0718.maximum-length-of-repeated-subarray</a>
  </h1>
  <time datetime="2020-12-30T17:26:31&#43;0800" class="post-date">2020-12-30 17:26:31</time>
  两个数组的 最长子数组 子序列：不一定连续 1143 子数组：一定连续 718  1func findLength(A []int, B []int) int { 2	if len(A) == 0 || len(B) == 0 { 3	return 0 4	} 5	6 // dp[i][j]表示以A[i] B[j]结尾的相同子数组的长度 7	dp := make([][]int, 0, len(A)) 8	for i := 0; i &lt; len(A); i++ { 9	dp = append(dp, make([]int, len(B), len(B))) 10	} 11 12 // 为了避免i=0, j=0, 此时0-1=-1，索引非法的问题，先初始化0的情况 13	for i := 0; i &lt; len(A); i++ { 14	if A[i] == B[0] { 15	dp[i][0] = 1 16	} 17	} 18	for j := 0; j &lt; len(B); j++ { 19	if A[0] == B[j] { 20	dp[0][j] = 1 21	} 22	} 23 24	ret := 0 25 26	for i := 1; i &lt; len(A); i++ { 27	for j := 1; j &lt; len(B); j++ { 28	if A[i] == B[j] { 29	dp[i][j] = dp[i-1][j-1] + 1 30	if ret &lt; dp[i][j] { 31	ret = dp[i][j] 32	} 33	} 34	} 35	} 36 37	return ret 38} 或者数组多一位  1func findLength(A []int, B []int) int { 2	if len(A) == 0 || len(B) == 0 { 3	return 0 4	} 5 6	dp := make([][]int, 0, len(A)+1) 7	for i := 0; i &lt; len(A)+1; i++ { 8	dp = append(dp, make([]int, len(B)+1, len(B)+1)) 9	} 10 11	ret := 0 12 13	for i := 1; i &lt;= len(A); i++ { 14	for j := 1; j &lt;= len(B); j++ { 15	if A[i-1] == B[j-1] { 16	dp[i][j] = dp[i-1][j-1] + 1 17	if ret &lt; dp[i][j] { 18	ret = dp[i][j] 19	} 20	} 21	} 22	} 23 24	return ret 25} 26``` 
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/1206.design-skiplist/">1206.design-skiplist</a>
  </h1>
  <time datetime="2020-12-30T16:37:20&#43;0800" class="post-date">2020-12-30 16:37:20</time>
  1import ( 2	&#34;math/rand&#34; 3) 4 5const ( 6	maxLevel = 16 7	skipListPVal = 0.5 8) 9 10// randomLevel 返回一个Next数组的高度, 高度不能超过最大值 11func randomLevel() int { 12	retLevel := 1 13	for retLevel &lt; maxLevel &amp;&amp; rand.Float32() &lt; skipListPVal { 14	retLevel++ 15	} 16	return retLevel 17} 18 19type Node struct { 20	Val int 21	Next [maxLevel]*Node 22} 23 24func NewNode(val int, next [maxLevel]*Node) *Node { 25	return &amp;Node{ 26	Val: val, 27	Next: next, 28	} 29} 30 31type Skiplist struct { 32	head *Node 33	maxLevel int 34} 35 36func Constructor() Skiplist { 37	return Skiplist{ 38	// head 里的值是最小值,这里取-1 39	head: NewNode(-1, [maxLevel]*Node{}), 40	maxLevel: 1, 41	} 42} 43 44func (this *Skiplist) search(target int) [maxLevel]*Node { 45	cur := this.
  
  <div class="read-more-link">
    <a href="/posts/leetcode/1206.design-skiplist/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0032.longest-valid-parentheses/">0032.longest-valid-parentheses</a>
  </h1>
  <time datetime="2020-12-22T16:27:41&#43;0800" class="post-date">2020-12-22 16:27:41</time>
  1func longestValidParentheses(s string) int { 2	rst := 0 3 // dp[i] 表示以s[i]字符结尾的最长的合法的括号长度 4	dp := make([]int, len(s), len(s)) 5	for i := 1; i &lt; len(s); i++ { 6	curByte := s[i] 7 // 如果s[i]是左括号，那么以左括号为结尾的字符串，一定不是合法的，长度就是0 8	if curByte == &#39;(&#39; { 9	continue 10	} 11 // 如果s[i]是右括号，比如这种 ?()) 12 // 就需要看一下，s[i-1]结尾的合法字符串的前一个是不是左括号， 13 // 如果是，需要加2（一个是当前的右括号，一个是dp[i-1]之前的左括号) 14	leftIdx := i - dp[i-1] - 1 15	if leftIdx &gt;= 0 &amp;&amp; s[leftIdx] == &#39;(&#39; { 16	dp[i] = dp[i-1] + 2 17	leftLeftIdx := i - dp[i-1] - 2 18 // 这里还需要加上dp[i-1]之前的合法字符串的长度 19 // 对应这种情况: ()(()) 20 // 这里只需要看一次就行，因为如果前面还有的话，一定包含在dp[i-dp[i-1]-2]里了 21	if leftLeftIdx &gt;= 0 { 22	dp[i] += dp[leftLeftIdx] 23	} 24	} 25	if rst &lt; dp[i] { 26	rst = dp[i] 27	} 28 29	} 30	return rst 31} 
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0030.substring-with-concatenation-of-all-words/">0030.substring-with-concatenation-of-all-words</a>
  </h1>
  <time datetime="2020-12-18T19:56:59&#43;0800" class="post-date">2020-12-18 19:56:59</time>
  有点暴力的解法，就是遍历所有可能的窗口  1func findSubstring(s string, words []string) []int { 2	//声明返回值 3	var result []int 4 5	//判断 6	if len(s) == 0 || len(words) == 0 { 7	return result 8	} 9 10 11	//获取单词长度 12	l := len(words[0]) 13 14	//获取滑动窗口总长度 15	length := l * len(words) 16 17	//判断 18	if length &gt; len(s) { 19	return result 20	} 21 22	//构造map 23	mp := make(map[string]int) 24 25	//统计 26	for _,v := range words { 27	mp[v] += 1 28	} 29 30	//开始遍历 31	for i := 0; i &lt;= (len(s) - length);i++ { 32	//判断i开始length位置 33	tmpMap := map[string]int{} 34 35	//定义标志 36	//默认是true 37	fg := true 38 39	// 这里的逻辑是，如果当前的单词是需要的，且个数还没凑够，那就对应的数减一 40	// 如果遇到不需要的单词，一定就不合法了.
  
  <div class="read-more-link">
    <a href="/posts/leetcode/0030.substring-with-concatenation-of-all-words/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0336.palindrome-pairs/">0336.palindrome-pairs</a>
  </h1>
  <time datetime="2020-12-18T19:36:38&#43;0800" class="post-date">2020-12-18 19:36:38</time>
  1func palindromePairs(words []string) [][]int { 2	m := make(map[string]int, len(words)) 3	for idx, v := range words { 4	m[v] = idx 5	} 6 7	res := make([][]int, 0) 8 9	for idx, v := range words { 10	// 如果非空字符串v是回文串，且字符数组中包含空字符串，那么 v+&#34;&#34; 与 &#34;&#34;+v 都是回文串 11	if emptyStrIdx, ok := m[&#34;&#34;]; ok &amp;&amp; isPalindrome(v) &amp;&amp; v != &#34;&#34; { 12	res = append(res, []int{emptyStrIdx, idx}) 13	res = append(res, []int{idx, emptyStrIdx}) 14	} 15	// v的逆序字符串存在的话，那么这俩一拼也是回文串，注意这里只加一次( 16	// 比如A的逆序是B, 遍历到A的话，加入A,B; 17	// 遍历到B的时候，加入B,A，就不会重复 18	// ) 19 // 其实v !
  
  <div class="read-more-link">
    <a href="/posts/leetcode/0336.palindrome-pairs/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0010.regular-expression-matching/">0010.regular-expression-matching</a>
  </h1>
  <time datetime="2020-12-17T17:22:10&#43;0800" class="post-date">2020-12-17 17:22:10</time>
  1func isMatch(s string, p string) bool { 2 // sBytes := []byte(s) 3 // pBytes := []byte(p) 4 // dp[i][j]表示s[:i+1] p[:j+1]是否匹配 5 dp := make([][]bool, 0, len(s)+1) 6 for i := 0; i &lt; len(s)+1; i++ { 7 dp = append(dp, make([]bool, len(p)+1)) 8 } 9 // s跟p都是空字符，肯定匹配的上 10 dp[0][0] = true 11 for i := 1; i &lt; len(p); i++ { 12 // 如果当前p[i]是*，那么*可以把前面的字符搞没 13 // 比如 &#34;b*a*&#34; 跟 &#34;&#34;比较，a*可以去掉，那么就变成&#34;b*&#34;跟&#34;&#34;比较 14 if p[i] == &#39;*&#39; { 15 dp[0][i+1] = dp[0][i-1] 16 } 17 } 18 19	for i, sByte := range s { 20	for j, pByte := range p { 21	switch { 22	case sByte == pByte: 23 // 最简单的case，俩字符一样，那么前面的如果匹配，这个一定匹配 24	dp[i+1][j+1] = dp[i+1][j+1] || dp[i][j] 25	case pByte == &#39;.
  
  <div class="read-more-link">
    <a href="/posts/leetcode/0010.regular-expression-matching/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0014.longest-common-prefix/">0014.longest-common-prefix</a>
  </h1>
  <time datetime="2020-12-17T17:22:10&#43;0800" class="post-date">2020-12-17 17:22:10</time>
  func longestCommonPrefix(strs []string) string { if len(strs)==0{ return &quot;&quot; } if len(strs)==1{ return strs[0] } for i:=0; i&lt;len(strs[0]); i++{ for j:=1; j&lt;len(strs); j++{ // fmt.Printf(&quot;i:%d strs[j]:%s\n&quot;, i, strs[j]) // 等于号，因为要取strs[j][i], 要是长度是i，最多取到i-1 if len(strs[j])&lt;=i || strs[j][i]!=strs[0][i]{ return strs[0][:i] } } } return strs[0] }  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0076.minimum-window-substring/">0076.minimum-window-substring</a>
  </h1>
  <time datetime="2020-12-14T16:47:32&#43;0800" class="post-date">2020-12-14 16:47:32</time>
  滑动窗口逻辑： 声明俩变量left right初始化为0 1. 右边界往右遍历，符合条件后， 2. 左边界往右遍历，直到不符合条件，再跳到1 期间符合条件时，更新下当前的最优解 for right&lt;number{ handle value[right] right++ if left&lt;=right and satisfy the condition { current left and right are good result, update final result left++ } }  1func minWindow(s string, t string) string { 2	retLeft := 0 3	retRight := len(s) + 100 4	left := 0 5	right := 0 6	// 记录t中，byte到个数的map 7	visited := make(map[byte]int) 8	// 实时记录，当前left到right之间的t中字符，byte到个数的映射 9	curVisited := make(map[byte]int) 10	curFitNum := 0 11	tBytes := []byte(t) 12	for _, v := range tBytes { 13	visited[v] += 1 14	} 15	for _, v := range tBytes { 16	curVisited[v] = 0 17	} 18	// t中unique的字符个数 19	fitNum := len(visited) 20	for right &lt; len(s) { 21	// 遍历右边，并处理curVisited, curFitNum等中间记录当前状态的变量 22	curRightByte := s[right] 23	if _, ok := curVisited[curRightByte]; ok { 24	curVisited[curRightByte]++ 25	if curVisited[curRightByte] == visited[curRightByte] { 26	curFitNum++ 27	} 28	} 29	right++ 30 31	for left &lt;= right &amp;&amp; curFitNum == fitNum { 32	// 当left在合法范围内，且当前符合条件时 33	// 检查下是否更新返回值 34	if right-left &lt; retRight-retLeft { 35	retRight = right 36	retLeft = left 37	} 38 39 // 去掉left的字符后，处理curVisited, curFitNum等中间记录当前状态的变量 40	curLeftByte := s[left] 41	if v, ok := curVisited[curLeftByte]; ok { 42	if v == visited[curLeftByte] { 43	curFitNum-- 44	} 45	curVisited[curLeftByte]-- 46 47	} 48	left++ 49	} 50	} 51	if retRight &gt; len(s) { 52	return &#34;&#34; 53	} 54	return s[retLeft:retRight] 55} 
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0042.trapping-rain-water/">0042.rapping-rain-water</a>
  </h1>
  <time datetime="2020-12-10T19:03:01&#43;0800" class="post-date">2020-12-10 19:03:01</time>
  单调栈解法 1func trap(height []int) int { 2 if len(height)&lt;=2{ 3 return 0 4 } 5 6 s:=&amp;Stack{ 7 raw: make([]int, 0), 8 } 9 s.Push(0) 10 rst:=0 11 for i:=1; i&lt;len(height); i++{ 12 v:=height[i] 13 for s.Len()&gt;0 &amp;&amp; v&gt;height[s.Top()]{ 14	// 其实要算的是targetIdx位置的雨水 15 targetIdx:=s.Pop() 16 if s.Len()&gt;0{ 17	// 栈顶元素是左边界 18 leftIdx:=s.Top() 19	// i是右边界 20 rightIdx:=i 21	// 存储水量取决于左右边界的最低值，然后减去target的高度，就是存水量的高, 再乘以宽度，就是水量 22	// 宽度是 rightIdx-leftIdx-1， 比如 3， 4， 5， 6， 7 23	// 如果leftIdx=3, rightIdx=7， 那么要取4， 5， 6的宽度3， 7-3=4， 需要再减去1 24 rst+= (getMin(height[leftIdx], height[rightIdx])-height[targetIdx])*(rightIdx-leftIdx-1) 25 } 26 } 27 s.
  
  <div class="read-more-link">
    <a href="/posts/leetcode/0042.trapping-rain-water/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0053.maximum-subarra/">0053.maximum-subarray</a>
  </h1>
  <time datetime="2020-12-10T16:33:51&#43;0800" class="post-date">2020-12-10 16:33:51</time>
  1func maxSubArray(nums []int) int { 2	if len(nums) == 0 { 3	return 0 4	} 5	// dp[i]表示以i结尾的和 6	dp := make([]int, len(nums), len(nums)) 7	dp[0] = nums[0] 8	rst := nums[0] 9	for i := 1; i &lt; len(nums); i++ { 10	// 对于以i结尾的连续数组，要么就他自己，要么他自己加上以i-1为结尾的最大值 11	dp[i] = max(nums[i], nums[i]+dp[i-1]) 12	if dp[i] &gt; rst { 13	rst = dp[i] 14	} 15	} 16 17	return rst 18} 19 20func max(a, b int) int { 21	if a &gt; b { 22	return a 23	} 24	return b 25} 
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0041.first-missing-positive/">0041.first-missing-positive</a>
  </h1>
  <time datetime="2020-12-10T16:17:11&#43;0800" class="post-date">2020-12-10 16:17:11</time>
  比如2， 3，-1， 6 遍历一遍，负数变成默认值: 数组长度 原因是需要拿负号做标记，所以先把原来的负数干掉 先变成 2， 3， 5， 6 然后，遇到2，如果2在len里面，且对应位置的数是整数，就改成负数 2, -3, -5, 6 这样，遍历一遍，第一个正数对应的位置，就是第一个缺失的正整数  1func firstMissingPositive(nums []int) int { 2	for i, _ := range nums { 3	if nums[i] &lt;= 0 { 4	nums[i] = len(nums) + 1 5	} 6	} 7	8	for i, _ := range nums { 9	// abs(nums[i]) 10	// is for 3, 4, -1, 1 11	// otherwise 12	// after checking negative, would be 3, 4, 5, 1 13	// after this lookp, would be 3, 4, -5, -1 14	// then 1 would be returned 15	// the reason is that the last value 1 is set to negative 16	// so we need to ignore negative, just use abs value 17	cur := abs(nums[i]) 18	// nums[cur-1] &gt; 0 19	// is for 1, 1 20	// otherwise 21	// after checking ne4tative, would be 1, 1 22	// after this lookup, would be -1, 1, then 1, 1 23	// the zero index was set two times, and -1*-1=1 24	// so for one index, we only need to set one time 25	if cur &gt; 0 &amp;&amp; cur &lt; len(nums)+1 &amp;&amp; nums[cur-1] &gt; 0 { 26	nums[cur-1] *= -1 27	} 28	} 29 30	for i, _ := range nums { 31	if nums[i] &gt; 0 { 32	return i + 1 33	} 34	} 35 36	return len(nums) + 1 37} 38 39func abs(a int) int { 40	if a &lt; 0 { 41	a *= -1 42	} 43	return a 44} 
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0051.n-queens/">0051.n-queens</a>
  </h1>
  <time datetime="2020-12-10T15:34:43&#43;0800" class="post-date">2020-12-10 15:34:43</time>
  1func solveNQueens(n int) [][]string { 2	rst := make([][]string, 0) 3	4	// initialize chess 5	chess := make([][]byte, 0, n) 6	for i := 0; i &lt; n; i++ { 7	chess = append(chess, getLine(n)) 8	} 9 10	var bs func(row int) 11	bs = func(row int) { 12	if row == n { 13	rst = append(rst, getRst(chess)) 14	return 15	} 16	for col := 0; col &lt; n; col++ { 17	// if location with row and col can not add a Q 18	// then just continue 19	if !
  
  <div class="read-more-link">
    <a href="/posts/leetcode/0051.n-queens/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/git/reset/">Reset</a>
  </h1>
  <time datetime="2020-12-10T14:05:18&#43;0800" class="post-date">2020-12-10 14:05:18</time>
  https://ndpsoftware.com/git-cheatsheet.html
// 取消上一次提交，且代码不要了 git reset --hard HEAD^1 // 取消上一次提交，代码在add状态 git reset --soft HEAD^1 // 取消add状态 git reset git reset &lt;file&gt;  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0056.merge-intervals/">0056.merge-intervals</a>
  </h1>
  <time datetime="2020-12-10T13:44:21&#43;0800" class="post-date">2020-12-10 13:44:21</time>
  1func merge(intervals [][]int) [][]int { 2	if len(intervals) == 0 { 3	return [][]int{} 4	} 5	if len(intervals) == 1 { 6	return intervals 7	} 8	// need to sort by the start value 9	sort.Slice(intervals, func(i, j int) bool { 10	return intervals[i][0] &lt; intervals[j][0] 11	}) 12	rst := make([][]int, 0) 13	cur := intervals[0] 14	for i := 1; i &lt; len(intervals); i++ { 15	if intervals[i][0] &lt;= cur[1] { 16	// cur = [1, 3] intervals[i]=[2, 5] 17	// 对于这种，需要合并，合并后开始还是cur[0], cur[1]=两个结束值的最大值 18	cur[1] = getMaxInt(cur[1], intervals[i][1]) 19	} else { 20	// cur = [1, 3] intervals[i]=[4, 5] 21	rst = append(rst, cur) 22	cur = intervals[i] 23	} 24	} 25 26	rst = append(rst, cur) 27	return rst 28 29} 30 31func getMaxInt(a, b int) int { 32	if a &gt; b { 33	return a 34	} 35	return b 36} 
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0047.permutations-ii/">0047.permutations_II</a>
  </h1>
  <time datetime="2020-12-10T13:31:12&#43;0800" class="post-date">2020-12-10 13:31:12</time>
  1func permuteUnique(s []int) [][]int { 2 // need to sort the s first, so it&#39;s easy for us to skip the duplicated value 3	sort.Ints(s) 4	rst := make([][]int, 0) 5	visited := make([]bool, len(s), len(s)) 6 7	var bs func(idx int, cur []int) 8 9	bs = func(idx int, cur []int) { 10	if idx == len(s) { 11	curRst := make([]int, len(cur), len(cur)) 12	copy(curRst, cur) 13	rst = append(rst, curRst) 14	return 15	} 16 17	for i := 0; i &lt; len(s); i++ { 18	if visited[i] { 19	continue 20	} 21	// s[i]==s[i-1] means the value with last idx equals current value 22	// 23	// i-1 is in front of i 24	// so i-1 must have been handled before i 25	// and visited[i-1]==false means the result of this value has been added to rst 26	// then deleting i-1 from current result and hanlde i 27	if i &gt; 0 &amp;&amp; s[i] == s[i-1] &amp;&amp; !
  
  <div class="read-more-link">
    <a href="/posts/leetcode/0047.permutations-ii/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0046.permutations/">0046.permutations</a>
  </h1>
  <time datetime="2020-12-10T13:21:18&#43;0800" class="post-date">2020-12-10 13:21:18</time>
  1func permute(s []int) [][]int { 2	rst := make([][]int, 0) 3	// to judge if the value of this index has been visited 4	visited := make([]bool, len(s), len(s)) 5 6	var bs func(idx int, cur []int) 7 8	bs = func(idx int, cur []int) { 9	// satisfied 10	if idx == len(s) { 11	curRst := make([]int, len(cur), len(cur)) 12	copy(curRst, cur) 13	rst = append(rst, curRst) 14	return 15	} 16 17	for i := 0; i &lt; len(s); i++ { 18	if visited[i] { 19	continue 20	} 21 22 // visit the value with index i 23	visited[i] = true 24	cur = append(cur, s[i]) 25	26	bs(idx+1, cur) 27	28	// restore the context 29	visited[i] = false 30	cur = cur[:len(cur)-1] 31	} 32	} 33	34	// initialize the state 35	bs(0, make([]int, 0, len(s))) 36	return rst 37} 
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0084.largest-rectangle-in-histogram/">0084.largest-rectangle-in-histogram</a>
  </h1>
  <time datetime="2020-08-23T18:14:56&#43;0800" class="post-date">2020-08-23 18:14:56</time>
  https://leetcode-cn.com/problems/largest-rectangle-in-histogram/
单调栈
1func largestRectangleArea(heights []int) int { 2	h:=make([]int, 0, len(heights)+2) 3	h=append(h, 0) 4	h=append(h, heights...) 5	h=append(h, 0) 6	// stack里存储的是单调递增的索引 7	stack:=make([]int, 0) 8	res:=0 9 10 // 遍历的是h，not heights 11	for i, v:=range h{ 12	for len(stack)!=0 &amp;&amp; h[stack[len(stack)-1]]&gt;v{ 13	// 如果当前的值小于栈顶位置的元素，说明可以计算栈顶位置元素的矩形面积 14	t:=stack[len(stack)-1] 15	stack=stack[:len(stack)-1] 16	// 出栈之后，栈顶位置的元素为小于t位置的索引 17	left:=stack[len(stack)-1] 18	right:=i 19	// left是小于t的最左侧，right是小于t的最右侧, 1xxx5, 比如计算xxx的长度,5-1=4,需要再减一个1 20	res=getMaxInt(res, (right-left-1)*h[t]) 21	} 22	stack=append(stack, i) 23	} 24 25	return res 26} 27 28func getMaxInt(a, b int)int{ 29	if a&gt;b{ 30	return a 31	} 32	return b 33} 
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/algo/sliding_window/">Sliding_window</a>
  </h1>
  <time datetime="2020-07-23T11:05:24&#43;0800" class="post-date">2020-07-23 11:05:24</time>
  https://lucifer.ren/blog/2020/03/16/slide-window/
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/golang/mem/">Mem</a>
  </h1>
  <time datetime="2020-06-19T17:19:20&#43;0800" class="post-date">2020-06-19 17:19:20</time>
  https://deepu.tech/memory-management-in-golang/#:~:text=Go&rsquo;s%20memory%20management%20involves%20automatic,is%20well%20optimized%20and%20efficient.
https://speakerdeck.com/deepu105/go-memory-allocation
https://blog.learngoprogramming.com/
https://www.bookstack.cn/read/For-learning-Go-Tutorial/
https://draveness.me/golang
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/golang/tool/">Tool</a>
  </h1>
  <time datetime="2020-06-19T14:48:19&#43;0800" class="post-date">2020-06-19 14:48:19</time>
  Copy from: https://rakyll.org/go-tool-flags/ https://studygolang.com/articles/22803
go build -x Lists all the commands go build invokes.
go build -gcflags Used to pass flags to the Go compiler. go tool compile -help lists all the flags that can be passed to the compiler.
For example, to disable compiler optimizations and inlining, you can use the following the gcflags.
# -N disable optimizations # -m print optimization decisions # -l disable inlining # -race enable race detector go build/run -gcflags &quot;&lt;parameters&gt;&quot; main.
  
  <div class="read-more-link">
    <a href="/posts/golang/tool/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/wrk2/intro/">Intro</a>
  </h1>
  <time datetime="2020-06-15T21:10:28&#43;0800" class="post-date">2020-06-15 21:10:28</time>
  https://github.com/giltene/wrk2
wrk -t2 -c100 -d30s -R2000 http://127.0.0.1:8080/index.html # This runs a benchmark for 30 seconds, # using 2 threads, keeping 100 HTTP connections open, # and a constant throughput of 2000 requests per second # (total, across all connections combined).  With script
./wrk -c2 -t2 -L -R6 -d600s -s ./scripts/lookup.lua http://127.0.0.1:8080  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/algo/reverse_list/">Reverse_list</a>
  </h1>
  <time datetime="2020-06-07T18:34:55&#43;0800" class="post-date">2020-06-07 18:34:55</time>
  1package main 2 3import ( 4	&#34;fmt&#34; 5) 6 7type ListNode struct { 8	Val int 9	Next *ListNode 10} 11 12func main() { 13	l := getList([]int{1, 2, 3, 4, 5, 6}) 14	printList(l) 15	l = reverseList(l) 16	printList(l) 17} 18 19func reverseList(l *ListNode) *ListNode { 20	var head *ListNode 21	var next *ListNode 22	cur := l 23	for cur != nil { 24	/* 25好记忆: 26A=B 27B=C 28C=D 29D=A 30*/ 31	// 保存下一个节点 32	next = cur.
  
  <div class="read-more-link">
    <a href="/posts/algo/reverse_list/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/1/">1</a>
  </h1>
  <time datetime="2020-05-03T21:07:02&#43;0800" class="post-date">2020-05-03 21:07:02</time>
  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/algo/backtrack/">Backtrack</a>
  </h1>
  <time datetime="2020-05-03T21:04:31&#43;0800" class="post-date">2020-05-03 21:04:31</time>
  result = [] def backtrack(路径, 选择列表): if 满足结束条件: result.add(路径) return for 选择 in 选择列表: 做选择 backtrack(路径, 选择列表(抠掉这次选择)) 撤销选择  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/algo/alien_dictionary/">Alien_dictionary</a>
  </h1>
  <time datetime="2020-04-26T11:56:22&#43;0800" class="post-date">2020-04-26 11:56:22</time>
  1# -*- encoding: utf-8 -*- 2 3from heapq import heappush, heappop, heapify 4 5class Solution: 6 &#34;&#34;&#34; 7@param board: A list of lists of character 8@param words: A list of string 9@return: A list of string 10&#34;&#34;&#34; 11 def alienOrder(self, words): 12 # write your code here 13 # TODO: check params 14 graph=self.buildGraph(words) 15 print graph 16 17 # print graph 18 19 inDegree=self.buildInDegree(words, graph) 20 21 # print inDegree 22 23 q=[] 24 for i in inDegree: 25 if inDegree[i]==0: 26 q.
  
  <div class="read-more-link">
    <a href="/posts/algo/alien_dictionary/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/algo/reservoir_sampling/">Reservoir_sampling</a>
  </h1>
  <time datetime="2020-04-25T14:59:29&#43;0800" class="post-date">2020-04-25 14:59:29</time>
  array result for i=0; i&lt;n; i++{ if i&lt;k{ result[i]=array[i] }else{ r=random(0, i) if r&gt;=k{ continue } result[r]=array[i] } }  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/algo/union_find/">Union find</a>
  </h1>
  <time datetime="2020-04-25T14:40:38&#43;0800" class="post-date">2020-04-25 14:40:38</time>
  1class UnionFindSet: 2 def __init__(self, n): 3 self.parents=[] 4 self.ranks=[] 5 for i in range(n): 6 self.parents.append(i) 7 self.ranks.append(0) 8 def connected(self, a, b): 9 return self.find(a)==self.find(b) 10 11 def find(self, x): 12 if x!=self.parents[x]: 13 self.parents[x]=self.find(self.parents[x]) 14 return self.parents[x] 15 16 def union(self, x, y): 17 px=self.find(x) 18 py=self.find(y) 19 # 谁大谁是爹 20 if self.ranks[px]&gt;self.ranks[py]: 21 self.parents[py]=px 22 if self.ranks[px]&lt;self.ranks[py]: 23 self.parents[px]=py 24 if self.ranks[px]==self.ranks[py]: 25 self.parents[py]=px 26 self.ranks[px]+=1 27 28 29t=UnionFindSet(5) 30print t.
  
  <div class="read-more-link">
    <a href="/posts/algo/union_find/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/algo/heap/">Heap</a>
  </h1>
  <time datetime="2020-04-24T22:56:43&#43;0800" class="post-date">2020-04-24 22:56:43</time>
  1package main 2 3import ( 4	&#34;fmt&#34; 5) 6 7func parent(i int) int { 8	return (i - 1) / 2 9} 10 11func left(i int) int { 12	return i*2 + 1 13} 14 15func right(i int) int { 16	return i*2 + 2 17} 18 19func maxHeapify(a []int, i int) { 20	l := left(i) 21	r := right(i) 22	largestIdx := i 23	if l &lt; len(a) &amp;&amp; a[largestIdx] &lt; a[l] { 24	largestIdx = l 25	} 26	if r &lt; len(a) &amp;&amp; a[largestIdx] &lt; a[r] { 27	largestIdx = r 28	} 29 30	if largestIdx !
  
  <div class="read-more-link">
    <a href="/posts/algo/heap/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/algo/trie/">Trie</a>
  </h1>
  <time datetime="2020-04-24T22:54:49&#43;0800" class="post-date">2020-04-24 22:54:49</time>
  1import collections 2import json 3 4class TrieNode(object): 5 def __init__(self, value=0): 6 self.value = value 7 self.isWord = False 8 self.children = collections.OrderedDict() 9 10 @classmethod 11 def insert(cls, root, word): 12 p = root 13 for c in word: 14 child = p.children.get(c) 15 if not child: 16 child = TrieNode(c) 17 p.children[c] = child 18 p = child 19 20 p.isWord = True 
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/algo/merge_sort/">Merge Sort</a>
  </h1>
  <time datetime="2020-04-22T20:16:37&#43;0800" class="post-date">2020-04-22 20:16:37</time>
  1package main 2 3import( 4	&#34;fmt&#34; 5) 6 7func merge(a, b []int)[]int{ 8	rst:=make([]int, 0, len(a)+len(b)) 9	i:=0 10	j:=0 11	for i&lt;len(a) &amp;&amp; j&lt;len(b){ 12	if a[i]&lt;b[j]{ 13	rst=append(rst, a[i]) 14	i++ 15	}else{ 16	rst=append(rst, b[j]) 17	j++ 18	} 19	} 20	rst=append(rst, a[i:]...) 21	rst=append(rst, b[j:]...) 22	return rst 23} 24 25func mergeSort(s []int)[]int{ 26	if len(s)&lt;=1{ 27	return s 28	} 29 30	middleIdx:=len(s)/2 31	left:=mergeSort(s[:middleIdx]) 32	right:=mergeSort(s[middleIdx:]) 33	return merge(left, right) 34} 35 36func main(){ 37	a:=[]int{3, 1, 0, 2, 9, 7, 6, 8, 5, 4} 38	b:=mergeSort(a) 39	fmt.
  
  <div class="read-more-link">
    <a href="/posts/algo/merge_sort/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/golang/dlv/">Dlv</a>
  </h1>
  <time datetime="2020-01-20T19:44:06&#43;0800" class="post-date">2020-01-20 19:44:06</time>
  dlv debug main.go list: list current codes s(step): step in stepout: step out n(next): move to next line(step over) args: break a/b/c.go:213 break pkg.GetName bp(breakpoints): list all break points c(continue): continue to next break point or the end  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/algo/quick_sort/">Quick Sort</a>
  </h1>
  <time datetime="2020-01-19T18:16:32&#43;0800" class="post-date">2020-01-19 18:16:32</time>
  QuickSort(A, p, r) if p&lt;r mid=Partition(A, p, r) QuickSort(A, p, mid-1) QuickSort(A, mid+1, r) Partition(A, p, r) x=A[r] i=p-1 for j=p to r-1 if A[j]&lt;=x i=i+1 exchange A[i] with A[j] i=i+1 exchange A[i] with A[r] // r==j return i  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/algo/dfs/">DFS</a>
  </h1>
  <time datetime="2020-01-19T17:53:40&#43;0800" class="post-date">2020-01-19 17:53:40</time>
  DFS(G) for each u in G.V u.color=WHITE u.parent=nil time=0 for each u in G.V if u.color==WHITE DFS-Visit(G, u) DFS-Visit(G, u) time=time+1 u.displayTime=time u.color=GRAY for each v in G.Adj[u] if v.color==WHITE v.parent=u DFS-Visit(G, v) u.color=BLACK time=time+1 u.finishTime=time  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/algo/bfs/">BFS</a>
  </h1>
  <time datetime="2020-01-19T17:41:20&#43;0800" class="post-date">2020-01-19 17:41:20</time>
  WHITE: before join the queue GRAY: in the queue BLACK: pop from queue, and after visit all the children
BFS(G, s) for each u in (G.V-{s}) u.color=WHITE u.d=inf u.parent=nil s.color=GRAY s.d=0 s.parent=nil ENQUEUE(Q, s) while Q is not empty: u=DEQUEUE(Q) for each v in G.Adj(u) if v.color=WHITE v.color=GRAY v.d=u.d+1 v.parent=u ENQUEUE(Q, v) u.color=BLACK  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/algo/bellman_ford/">Bellman Ford</a>
  </h1>
  <time datetime="2020-01-19T15:45:10&#43;0800" class="post-date">2020-01-19 15:45:10</time>
  References:
 https://www.geeksforgeeks.org/bellman-ford-algorithm-dp-23/
从A出发是否存在到达各个节点的路径(有计算出值当然就可以到达)； 从A出发到达各个节点最短路径(时间最少、或者路径最少等) 图中是否存在负环路（权重之和为负数）   Example: k-flight
time: O(|V|*|E|)
1package main 2 3import ( 4	&#34;fmt&#34; 5	&#34;math&#34; 6) 7 8// Edge means the edge in graph 9type Edge struct { 10	src string 11	dst string 12	weight int 13} 14 15func bf(edges []Edge, fromV string) map[string]int { 16 // key为点，value为目前位置到达key点的距离，刚开始全是无限大 17	distMap := make(map[string]int, 0) 18	for _, v := range edges { 19	distMap[v.src] = math.
  
  <div class="read-more-link">
    <a href="/posts/algo/bellman_ford/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/algo/floyd/">Floyd</a>
  </h1>
  <time datetime="2020-01-19T15:42:53&#43;0800" class="post-date">2020-01-19 15:42:53</time>
  1package main 2 3import ( 4	&#34;fmt&#34; 5	&#34;math&#34; 6) 7 8func f(m [][]int) [][]int { 9	v := len(m) 10	dist := make([][]int, v, v) 11	for i := 0; i &lt; v; i++ { 12	dist[i] = make([]int, v, v) 13	} 14	for i := 0; i &lt; v; i++ { 15	for j := 0; j &lt; v; j++ { 16	dist[i][j] = m[i][j] 17	} 18	} 19 20	for k := 0; k &lt; v; k++ { 21	for i := 0; i &lt; v; i++ { 22	for j := 0; j &lt; v; j++ { 23	newMinForIJ := dist[i][k] + dist[k][j] 24	if newMinForIJ &lt; dist[i][j] { 25	dist[i][j] = newMinForIJ 26	} 27	} 28	} 29	} 30	return dist 31} 32 33func main() { 34	// a b c d 35	// 0 1 2 3 36	// a 0 0 1 6 10 37	// b 1 na 0 2 na 38	// c 2 na na 0 5 39	// d 3 na na na 0 40	m := [][]int{ 41	{0, 1, 6, 10}, 42	{math.
  
  <div class="read-more-link">
    <a href="/posts/algo/floyd/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/algo/dijkstra/">dijkstra</a>
  </h1>
  <time datetime="2020-01-19T15:05:01&#43;0800" class="post-date">2020-01-19 15:05:01</time>
  可以处理有环 无法处理包含有负数权值的边的图 (dijkastra是中间可以确定一部分点的最短距离，后面如果可以加上一个负数，那前面的确定的就不对了)  1from collections import defaultdict 2from heapq import * 3 4def dijkstra(edges, fromV, toV): 5 g=defaultdict(list) 6 for src, dst, cost in edges: 7 g[src].append((cost, dst)) 8 9 q, seen, mins=[(0, fromV, [])], set(), {fromV: 0} 10 while q: 11 (cost, src, path)=heappop(q) 12 if src not in seen: 13 seen.add(src) 14 path.append(src) 15 if src==toV: 16 return (cost, path) 17 for w, dst in g.get(src, []): 18 if dst in seen: 19 continue 20 oldCostForDst=mins.
  
  <div class="read-more-link">
    <a href="/posts/algo/dijkstra/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/docker/common/">Common</a>
  </h1>
  <time datetime="2019-11-15T15:48:28&#43;0800" class="post-date">2019-11-15 15:48:28</time>
  docker ps docker ps -a docker container ls docker container ls -a docker container prune docker run -p 8501:8501 \ --mount type=bind,\ source=/tmp/tfserving/serving/tensorflow_serving/servables/tensorflow/testdata/saved_model_half_plus_two_cpu,\ target=/models/half_plus_two \ -e MODEL_NAME=half_plus_two -t tensorflow/serving &amp;  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/docker/volume/">Volume</a>
  </h1>
  <time datetime="2019-11-15T15:41:03&#43;0800" class="post-date">2019-11-15 15:41:03</time>
  docker volume create &lt;volume name&gt; docker volume ls docker volume inspect &lt;volume name&gt;  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/tensorflow/serving_1/">Serving_1</a>
  </h1>
  <time datetime="2019-11-15T14:34:39&#43;0800" class="post-date">2019-11-15 14:34:39</time>
   Install tensorflow https://docs.python.org/3/library/venv.html
python3 -m venv &lt;path&gt; source &lt;path&gt;/bin/activate pip install tensorflow==&lt;version&gt;  Use tensorflow/serving git: https://github.com/tensorflow/serving
doc: https://www.tensorflow.org/tfx/serving/docker
Multi Version(hot reload), Multi Model(cold reload) docker run -t --rm -p 8501:8501 \ -v &quot;$TESTDATA:/models&quot; -d \ -t tensorflow/serving --model_config_file=/models/models.config  models.config
model_config_list:{ config:{ name:&quot;hello-world&quot;, base_path:&quot;/models/hello-world&quot;, model_platform:&quot;tensorflow&quot;, model_version_policy:{ all:{} } }, config:{ name:&quot;modelA&quot;, base_path:&quot;/models/modelA&quot;, model_platform:&quot;tensorflow&quot;, model_version_policy:{ all:{} } } }  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/golang/slice_1/">Slice_1</a>
  </h1>
  <time datetime="2019-11-07T22:06:32&#43;0800" class="post-date">2019-11-07 22:06:32</time>
  The struct of slice in go: 1type slice struct { 2	array unsafe.Pointer 3	len int 4	cap int 5}
1package main 2 3import &#34;fmt&#34; 4 5func main() { 6	a := make([]int, 10, 20) 7	for i := 0; i &lt; 10; i = i + 1 { 8	a[i] = i 9	} 10 11	// means the length of b is 6-3=3, the capicity is 9-3=6 12	b := a[3:6:9] 13	// len(b)=3 14	fmt.
  
  <div class="read-more-link">
    <a href="/posts/golang/slice_1/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/how_to_create/">How to create hugo site</a>
  </h1>
  <time datetime="2018-10-06T18:52:24&#43;0800" class="post-date">2018-10-06 18:52:24</time>
  0x00 basic commands 1go get -u -v github.com/spf13/hugo 2hugo new site &lt;directory&gt; 3git init 4git submodule add https://github.com/spf13/hyde.git themes/hyde 5hugo new posts/how-to-create.md 0x01 config.toml 1baseURL = &#34;http://wncbb.github.io/&#34; 2languageCode = &#34;en-us&#34; 3title = &#34;WNCBB&#39;s blog&#34; 4theme = &#34;hyde&#34; 5 6[Menus] 7 main = [ 8 {Name = &#34;Github&#34;, URL = &#34;https://github.com/wncbb/&#34;}, 9 ] 10[params] 11 description = &#34;A man is only as good as what he loves&#34; 12 themeColor = &#34;theme-base-0c&#34; 13 layoutReverse = true 0x02 codes highlight https://gohugo.
  
  <div class="read-more-link">
    <a href="/posts/how_to_create/">Read More…</a>
  </div>
  
</article>
</div>
    </main>

    
  </body>
</html>
