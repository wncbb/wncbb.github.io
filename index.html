<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-us" lang="en-us">
<head>
  <link href="https://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="generator" content="Hugo 0.56.0-DEV" />

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>WNCBB&#39;s blog</title>
  <meta name="description" content="A man is only as good as what he loves" />

  
  <link type="text/css" rel="stylesheet" href="https://wncbb.github.io/css/print.css" media="print">
  <link type="text/css" rel="stylesheet" href="https://wncbb.github.io/css/poole.css">
  <link type="text/css" rel="stylesheet" href="https://wncbb.github.io/css/syntax.css">
  <link type="text/css" rel="stylesheet" href="https://wncbb.github.io/css/hyde.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Abril+Fatface|PT+Sans:400,400i,700">


  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="/favicon.png">

  
  <link href="https://wncbb.github.io/index.xml" rel="alternate" type="application/rss+xml" title="WNCBB's blog" />
  
</head>

  <body class="theme-base-0c layout-reverse">
  <aside class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <a href="https://wncbb.github.io/"><h1>WNCBB&#39;s blog</h1></a>
      <p class="lead">
       A man is only as good as what he loves 
      </p>
    </div>

    <nav>
      <ul class="sidebar-nav">
        <li><a href="https://wncbb.github.io/">Home</a> </li>
        <li><a href="/categories/"> Categories </a></li><li><a href="/series/"> Series </a></li><li><a href="/tags/"> Tags </a></li>
      </ul>
    </nav>

    <p>&copy; 2021. All rights reserved. </p>
  </div>
</aside>

    <main class="content container">
    <div class="posts">
<article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0128.longest-consecutive-sequence/">0128.longest-consecutive-sequence</a>
  </h1>
  <time datetime="2021-03-10T15:49:05&#43;0800" class="post-date">2021-03-10 15:49:05</time>
  /* 举个例子: nums: 100, 4, 200, 1, 3, 2 line22 m:map[100:1] line22 m:map[4:1 100:1] line22 m:map[4:1 100:1 200:1] line22 m:map[1:1 4:1 100:1 200:1] line22 m:map[1:1 3:2 4:2 100:1 200:1] line22 m:map[1:4 2:4 3:2 4:4 100:1 200:1] 最终效果就是: 对于连续的数组: [i, j] (且[i-1, j][i, j+1]都不是) map里的map[i], map[j]一定是最长的连续序列的长度 */ func longestConsecutive(nums []int) int { maxLen := 0 m := make(map[int]int) for _, v := range nums { _, ok := m[v] if ok { continue } leftLen := m[v-1] rightLen := m[v+1] curLen := leftLen + rightLen + 1 m[v] = curLen maxLen = getMax(maxLen, curLen) // 更新左右边界的值，因为下次用到的话，一定是只用到边界 m[v-leftLen] = curLen m[v+rightLen] = curLen // fmt.
  
  <div class="read-more-link">
    <a href="/posts/leetcode/0128.longest-consecutive-sequence/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0543.diameter-of-binary-tree/">0543.diameter-of-binary-tree</a>
  </h1>
  <time datetime="2021-03-10T15:29:09&#43;0800" class="post-date">2021-03-10 15:29:09</time>
  /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func diameterOfBinaryTree(root *TreeNode) int { if root==nil{ return 0 } rst:=0 var getDepth func(root *TreeNode)int getDepth=func(root *TreeNode)int{ if root==nil{ return 0 } left:=getDepth(root.Left) right:=getDepth(root.Right) rst=getMax(rst, left+right) return getMax(left, right)+1 } getDepth(root) return rst } func getMax(a, b int)int{ if a&gt;b{ return a } return b }  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0322.coin-change/">0322.coin-change</a>
  </h1>
  <time datetime="2021-03-10T15:09:43&#43;0800" class="post-date">2021-03-10 15:09:43</time>
  dfs func coinChange(coins []int, amount int) int { if amount == 0 { return 0 } sort.Slice(coins, func(i, j int) bool { return coins[i] &gt; coins[j] }) ans := math.MaxInt32 var dfs func(coins []int, curAmount, curCoinIndex, curCount int) dfs = func(coins []int, curAmount, curCoinIndex, curCount int) { if curAmount == 0 { ans = getMin(ans, curCount) return } if curCoinIndex == len(coins) { return } for k := curAmount / coins[curCoinIndex]; k &gt;= 0 &amp;&amp; (k+curCount) &lt; ans; k-- { dfs(coins, curAmount-k*coins[curCoinIndex], curCoinIndex+1, curCount+k) } } dfs(coins, amount, 0, 0) if ans == math.
  
  <div class="read-more-link">
    <a href="/posts/leetcode/0322.coin-change/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0175.combine-two-tables/">0175.combine-two-tables</a>
  </h1>
  <time datetime="2021-03-10T14:30:50&#43;0800" class="post-date">2021-03-10 14:30:50</time>
  select FirstName, LastName, City, State from Person left join Address on Person.PersonId = Address.PersonId ;  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0300.longest-increasing-subsequence/">0300.longest-increasing-subsequence</a>
  </h1>
  <time datetime="2021-03-10T14:28:58&#43;0800" class="post-date">2021-03-10 14:28:58</time>
  func lengthOfLIS(nums []int) int { numLen := len(nums) if numLen &lt;= 1 { return numLen } // 长度为i+1的递增子序列，的最后一个元素 tail := make([]int, numLen, numLen) tail[0] = nums[0] end := 0 for i := 1; i &lt; numLen; i++ { if nums[i] &gt; tail[end] { end++ tail[end] = nums[i] } else { left := 0 right := end for left &lt; right { mid := left + (right-left)/2 if nums[i] &lt;= tail[mid] { right = mid } else { left = mid + 1 } } // fmt.
  
  <div class="read-more-link">
    <a href="/posts/leetcode/0300.longest-increasing-subsequence/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0112.path-sum/">0112.path-sum</a>
  </h1>
  <time datetime="2021-03-10T13:33:22&#43;0800" class="post-date">2021-03-10 13:33:22</time>
  /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func hasPathSum(root *TreeNode, targetSum int) bool { if root==nil { return false } if root.Left==nil &amp;&amp; root.Right==nil &amp;&amp; root.Val==targetSum{ return true } return hasPathSum(root.Left, targetSum-root.Val) || hasPathSum(root.Right, targetSum-root.Val) }  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0093.restore-ip-addresses/">0093.restore-ip-addresses</a>
  </h1>
  <time datetime="2021-03-10T13:14:56&#43;0800" class="post-date">2021-03-10 13:14:56</time>
  func restoreIpAddresses(s string) []string { rst := make([]string, 0) var dfs func(curRst []string, start int) dfs = func(curRst []string, start int) { if len(curRst) == 4 { if start == len(s) { rst = append(rst, strings.Join(curRst, &quot;.&quot;)) return } else { return } } for length := 1; length &lt;= 3; length++ { // 2+2 2 3 4 if start+length &gt; len(s) { return } curStr := s[start : start+length] if length &gt; 1 &amp;&amp; curStr[0] == '0' { return } curNum, _ := strconv.
  
  <div class="read-more-link">
    <a href="/posts/leetcode/0093.restore-ip-addresses/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0445.add-two-numbers-ii/">0445.add-two-numbers-ii</a>
  </h1>
  <time datetime="2021-03-10T12:52:31&#43;0800" class="post-date">2021-03-10 12:52:31</time>
  /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode { if l1==nil{ return l2 } if l2==nil{ return l1 } l1Stack:=getStackFromList(l1) l2Stack:=getStackFromList(l2) carry:=0 dummy:=&amp;ListNode{} for !l1Stack.Empty() || !l2Stack.Empty() || carry&gt;0{ cur:=carry if !l1Stack.Empty(){ cur+=l1Stack.Pop() } if !l2Stack.Empty(){ cur+=l2Stack.Pop() } newNode:=&amp;ListNode{ Val: cur%10, } carry=cur/10 newNode.Next=dummy.Next dummy.Next=newNode } return dummy.Next } func getStackFromList(l *ListNode)*Stack{ stack:=&amp;Stack{ raw: make([]int, 0), } for l!
  
  <div class="read-more-link">
    <a href="/posts/leetcode/0445.add-two-numbers-ii/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0415.add-strings/">0415.add-strings</a>
  </h1>
  <time datetime="2021-03-10T12:38:19&#43;0800" class="post-date">2021-03-10 12:38:19</time>
  func addStrings(num1 string, num2 string) string { num1Bytes:=[]byte(num1) num2Bytes:=[]byte(num2) carry:=0 // 需要从后面往前计算，因为最后一位都是个位 i:=len(num1)-1 j:=len(num2)-1 rst:=make([]byte, 0) for i&gt;=0 || j&gt;=0 || carry&gt;0{ cur:=carry if i&gt;=0{ cur+=int(num1Bytes[i]-'0') i-- } if j&gt;=0{ cur+=int(num2Bytes[j]-'0') j-- } carry=cur/10 cur=cur%10 rst=append(rst, byte(cur+'0')) } return string(reverseBytes(rst)) } func reverseBytes(s [] byte)[]byte{ if len(s)&lt;=1{ return s } left:=0 right:=len(s)-1 for left&lt;right{ s[left], s[right]=s[right], s[left] left++ right-- } return s }  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0160.intersection-of-two-linked-lists/">0160.intersection-of-two-linked-lists</a>
  </h1>
  <time datetime="2021-03-10T12:26:32&#43;0800" class="post-date">2021-03-10 12:26:32</time>
  遍历A+B跟遍历B+A A=1, 3, 5, 7, 8 B=2, 6, 7, 8 A与B的最后一部分肯定相同，所以第一个相同的就是交叉点 A+B: 1 3 5 7 8 2 6 7 8 B+A: 2 6 7 8 1 3 5 7 8  /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func getIntersectionNode(headA, headB *ListNode) *ListNode { pA:=headA pB:=headB for pA!=pB{ if pA!=nil{ pA=pA.Next }else{ pA=headB } if pB!=nil{ pB=pB.
  
  <div class="read-more-link">
    <a href="/posts/leetcode/0160.intersection-of-two-linked-lists/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0023.merge-k-sorted-lists/">0023.merge-k-sorted-lists</a>
  </h1>
  <time datetime="2021-03-10T12:15:16&#43;0800" class="post-date">2021-03-10 12:15:16</time>
  /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func mergeKLists(lists []*ListNode) *ListNode { if len(lists)==0{ return nil } if len(lists)==1{ return lists[0] } // 看做left=0, right=len(lists)-1 mid:=(len(lists)-1+0)/2 // mid放在第一段里， [left, mid] (mid, right] left:=mergeKLists(lists[:mid+1]) right:=mergeKLists(lists[mid+1:]) return merge2List(left, right) } func merge2List(l1, l2 *ListNode)*ListNode{ // 一定要判断下l1,l2是否有nil的情况 if l1==nil{ return l2 } if l2==nil{ return l1 } dummy:=&amp;ListNode{} tail:=dummy for l1!
  
  <div class="read-more-link">
    <a href="/posts/leetcode/0023.merge-k-sorted-lists/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0143.reorder-list/">0143.reorder-list</a>
  </h1>
  <time datetime="2021-03-10T11:56:29&#43;0800" class="post-date">2021-03-10 11:56:29</time>
  /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func reorderList(head *ListNode) { if head==nil || head.Next==nil{ return } firstPart, secondPart:=cutMid(head) secondPart=reverseList(secondPart) dummy:=&amp;ListNode{} tail:=dummy for firstPart!=nil &amp;&amp; secondPart!=nil{ tail.Next=firstPart firstPart=firstPart.Next tail=tail.Next tail.Next=secondPart secondPart=secondPart.Next tail=tail.Next } if firstPart!=nil{ tail.Next=firstPart } } // 1 2 3 4 5 // s // f func cutMid(head *ListNode)(*ListNode, *ListNode){ fast:=head slow:=head for fast!=nil &amp;&amp; fast.
  
  <div class="read-more-link">
    <a href="/posts/leetcode/0143.reorder-list/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0054.spiral-matrix/">0054.spiral-matrix</a>
  </h1>
  <time datetime="2021-03-10T11:46:17&#43;0800" class="post-date">2021-03-10 11:46:17</time>
  func spiralOrder(matrix [][]int) []int { allNums:=len(matrix)*len(matrix[0]) left:=0 right:=len(matrix[0])-1 top:=0 bottom:=len(matrix)-1 rst:=make([]int, 0, allNums) for allNums&gt;0{ for i:=left; i&lt;=right &amp;&amp;allNums&gt;0; i++{ rst=append(rst, matrix[top][i]) allNums-- } top++ for i:=top; i&lt;=bottom &amp;&amp;allNums&gt;0; i++{ rst=append(rst, matrix[i][right]) allNums-- } right-- // i的左边界是left，不是0 for i:=right; i&gt;=left &amp;&amp;allNums&gt;0; i--{ rst=append(rst, matrix[bottom][i]) allNums-- } bottom-- for i:=bottom; i&gt;=top &amp;&amp;allNums&gt;0; i--{ rst=append(rst, matrix[i][left]) allNums-- } left++ } return rst }  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0200.number-of-islands/">0200</a>
  </h1>
  <time datetime="2021-03-10T11:31:02&#43;0800" class="post-date">2021-03-10 11:31:02</time>
  func numIslands(grid [][]byte) int { rst:=0 for i:=0; i&lt;len(grid); i++{ for j:=0; j&lt;len(grid[0]); j++{ if grid[i][j]=='0'{ continue } rst++ delIsland(grid, i, j) } } return rst } func delIsland(grid [][]byte, i, j int){ // 千万别忘记这一个，如果是0, 直接返回，不然直接死循环 if grid[i][j]=='0'{ return } grid[i][j]='0' dirs:=[][]int{{0, 1},{0, -1},{1, 0},{-1, 0}} for _, dir:=range dirs{ newI:=i+dir[0] newJ:=j+dir[1] if newI&gt;=0 &amp;&amp; newI&lt;len(grid) &amp;&amp; newJ&gt;=0 &amp;&amp; newJ&lt;len(grid[0]){ delIsland(grid, newI, newJ) } } }  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0007.reverse-integer/">0007.reverse-integer</a>
  </h1>
  <time datetime="2021-03-10T11:17:01&#43;0800" class="post-date">2021-03-10 11:17:01</time>
  func reverse(x int) int { ret := 0 for x != 0 { ret = ret*10 + x % 10 x /= 10 if ret &lt; math.MinInt32 || ret &gt; math.MaxInt32 { return 0 } } return ret }  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0176.second-highest-salary/">0176</a>
  </h1>
  <time datetime="2021-03-10T11:07:10&#43;0800" class="post-date">2021-03-10 11:07:10</time>
  SELECT (SELECT DISTINCT Salary FROM Employee ORDER BY Salary DESC LIMIT 1 OFFSET 1) AS SecondHighestSalary  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0020.valid-parentheses/">0020.valid-parentheses</a>
  </h1>
  <time datetime="2021-03-10T11:02:58&#43;0800" class="post-date">2021-03-10 11:02:58</time>
  func isValid(s string) bool { sBytes:=[]byte(s) stack:=&amp;Stack{ raw: make([]byte, 0, len(sBytes)), } for _, v:=range sBytes{ switch(v){ case '(': stack.Push(v) case ')': if stack.Empty(){ return false } if stack.Top()=='('{ stack.Pop() }else{ stack.Push(v) } case '[': stack.Push(v) case ']': if stack.Empty(){ return false } if stack.Top()=='['{ stack.Pop() }else{ stack.Push(v) } case '{': stack.Push(v) case '}': if stack.Empty(){ return false } if stack.Top()=='{'{ stack.Pop() }else{ stack.Push(v) } } } return stack.Empty() } type Stack struct{ raw []byte } func (s *Stack)Push(v byte){ s.
  
  <div class="read-more-link">
    <a href="/posts/leetcode/0020.valid-parentheses/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0221.maximal-square/">0221.maximal-square</a>
  </h1>
  <time datetime="2021-03-10T10:52:31&#43;0800" class="post-date">2021-03-10 10:52:31</time>
  func maximalSquare(matrix [][]byte) int { dp:=make([][]int, 0, len(matrix)) for i:=0; i&lt;len(matrix); i++{ dp=append(dp, make([]int, len(matrix[0]), len(matrix[0]))) } rst:=0 for i:=0; i&lt;len(matrix); i++{ for j:=0; j&lt;len(matrix[0]); j++{ if matrix[i][j]=='0'{ continue } if i==0 || j==0{ dp[i][j]=1 }else{ dp[i][j]=getMin(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])+1 } if rst&lt;dp[i][j]{ rst=dp[i][j] } } } return rst*rst } func getMin(a int, s ... int)int{ ret:=a for _, v:=range s{ if ret&gt;v{ ret=v } } return ret }  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/algo/cut_woods_k_n/">Cut_woods_k_n</a>
  </h1>
  <time datetime="2021-03-10T10:24:24&#43;0800" class="post-date">2021-03-10 10:24:24</time>
  https://blog.csdn.net/weixin_39590058/article/details/108397552
给定数组，每个元素代表一个木头的长度，木头可以任意截断， 从这堆木头中截出至少k个相同长度为m的木块，已知k，求max(m)  二分查找 数组排序后，mid=最小值+(最大值-最小值)/2 试一试mid能不能可以，如果不可以，说明mid太大，右边界=mid-1 如果可以，说明mid还可以继续扩大试试，左边界=mid+1  package main import ( &quot;fmt&quot; &quot;sort&quot; ) func main() { nums := []int{4, 7, 2, 10, 5} k := 5 rst := maxM(nums, k) fmt.Printf(&quot;rst: %d\n&quot;, rst) } func maxM(nums []int, k int) int { if len(nums) == 0 { return 0 } sort.Slice(nums, func(i, j int) bool { return nums[i] &gt; nums[j] }) max := nums[0] min := nums[len(nums)-1] lo := min hi := max ans := -1 for lo &lt;= hi { mid := lo + (hi-lo)/2 if isFit(nums, k, mid) { ans = mid lo = mid + 1 } else { hi = mid - 1 } } return ans } func isFit(nums []int, k int, v int) bool { count := 0 for i := 0; i &lt; len(nums); i++ { count += nums[i] / v if count &gt;= k { return true } } return false } func getMin(a, b int) int { if a &lt; b { return a } return b } func getMax(a, b int) int { if a &gt; b { return a } return b }  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/algo/36_multiplication/">36_multiplication</a>
  </h1>
  <time datetime="2021-03-10T10:23:10&#43;0800" class="post-date">2021-03-10 10:23:10</time>
  https://leetcode-cn.com/circle/discuss/I8NZUx/
import ( &quot;fmt&quot; ) func main() { num1 := &quot;11&quot; num2 := &quot;12&quot; rst := addStrings(num1, num2) fmt.Printf(&quot;rst: %s\n&quot;, rst) } func addStrings(num1, num2 string) string { lookup := make([]byte, 0, 36) for i := byte('0'); i &lt;= '9'; i++ { lookup = append(lookup, i) } for i := byte('a'); i &lt;= 'z'; i++ { lookup = append(lookup, i) } carry := 0 num1Bytes := []byte(num1) num2Bytes := []byte(num2) i := len(num1Bytes) - 1 j := len(num2Bytes) - 1 reversedRst := make([]byte, 0) for i &gt;= 0 || j &gt;= 0 || carry &gt; 0 { cur := carry if i &gt;= 0 { cur += byte2Number(num1Bytes[i]) i-- } if j &gt;= 0 { cur += byte2Number(num2Bytes[j]) j-- } carry = cur / 36 cur = cur % 36 if cur &gt;= 0 &amp;&amp; cur &lt; len(lookup) { reversedRst = append(reversedRst, lookup[cur]) } } return string(reverseBytes(reversedRst)) } func reverseBytes(s []byte) []byte { if len(s) &lt;= 1 { return s } i := 0 j := len(s) - 1 for i &lt; j { s[i], s[j] = s[j], s[i] i++ j-- } return s } func byte2Number(b byte) int { if '0' &lt;= b &amp;&amp; b &lt;= '9' { return int(b - '0') } if 'a' &lt;= b &amp;&amp; b &lt;= 'z' { return int(b-'a') + 10 } return 0 }  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0102.binary-tree-level-order-traversal/">0012</a>
  </h1>
  <time datetime="2021-03-10T00:05:49&#43;0800" class="post-date">2021-03-10 00:05:49</time>
  /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func levelOrder(root *TreeNode) [][]int { rst:=make([][]int, 0) q:=make([]*TreeNode, 0) q=append(q, root) for len(q)&gt;0{ nextQ:=make([]*TreeNode, 0) curRst:=make([]int, 0) for i:=0; i&lt;len(q); i++{ curRst=append(curRst, q[i].Val) if q[i].Left!=nil{ nextQ=append(nextQ, q[i].Left) } if q[i].Right!=nil{ nextQ=append(nextQ, q[i].Right) } } rst=append(rst, curRst) q=nextQ } return rst }  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0022.generate-parentheses/">0022</a>
  </h1>
  <time datetime="2021-03-09T23:47:50&#43;0800" class="post-date">2021-03-09 23:47:50</time>
  var rst []string func generateParenthesis(n int) []string { rst=make([]string, 0) cur:=make([]byte, 0, n*2) bt(cur, n, n) return rst } func bt(s []byte, openNum, closeNum int){ fmt.Printf(&quot;s:%+v, openNum:%d closeNum:%d\n&quot;, s, openNum, closeNum) if openNum==0 &amp;&amp; closeNum==0{ rst=append(rst, string(s)) return } if openNum&gt;0 { openNum-- s=append(s, '(') bt(s, openNum, closeNum) s=s[:len(s)-1] openNum++ } // 剩下的close的个数要大于open if closeNum&gt;0 &amp;&amp; openNum&lt;closeNum{ closeNum-- s=append(s, ')') bt(s, openNum, closeNum) s=s[:len(s)-1] closeNum++ } }  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0079.word-search/">0079</a>
  </h1>
  <time datetime="2021-03-09T23:22:34&#43;0800" class="post-date">2021-03-09 23:22:34</time>
  func exist(board [][]byte, word string) bool { for i:=0; i&lt;len(board); i++{ for j:=0; j&lt;len(board[0]); j++{ if findWord(board, i, j, word){ return true } } } return false } func findWord(board [][]byte, i, j int, word string)bool{ visited:=make([][]bool, 0, len(board)) for i:=0; i&lt;len(board); i++{ visited=append(visited, make([]bool, len(board[0]), len(board[0]))) } dirs:=[][]int{ {0, 1}, {0, -1}, {1, 0}, {-1, 0}, } wordBytes:=[]byte(word) var inner func(i, j, k int)bool inner = func(i, j, k int)bool{ if wordBytes[k]!
  
  <div class="read-more-link">
    <a href="/posts/leetcode/0079.word-search/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0739-daily-temperatures/">0739 Daily Temperatures</a>
  </h1>
  <time datetime="2021-03-09T23:19:44&#43;0800" class="post-date">2021-03-09 23:19:44</time>
  func dailyTemperatures(T []int) []int { if len(T)==0{ return []int{} } ret:=make([]int, len(T)) s:=&amp;Stack{ raw: make([]int, 0), } s.Push(0) for i:=1; i&lt;len(T); i++{ for !s.Empty() &amp;&amp; T[s.Top()]&lt;T[i]{ targetIdx:=s.Pop() ret[targetIdx]=i-targetIdx } s.Push(i) } return ret } type Stack struct{ raw []int } func (s *Stack)Empty()bool{ return len(s.raw)==0 } func (s *Stack)Push(v int){ s.raw=append(s.raw, v) } func (s *Stack)Pop()int{ ret:=s.raw[len(s.raw)-1] s.raw=s.raw[:len(s.raw)-1] return ret } func (s *Stack)Top()int{ return s.raw[len(s.raw)-1] }  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0019.remove-nth-node-from-end-of-list/">0019</a>
  </h1>
  <time datetime="2021-03-09T23:17:58&#43;0800" class="post-date">2021-03-09 23:17:58</time>
  /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func removeNthFromEnd(head *ListNode, n int) *ListNode { if head==nil{ return nil } dummy:=&amp;ListNode{} dummy.Next=head fastNode:=dummy slowNode:=dummy for i:=0; i&lt;n; i++{ fastNode=fastNode.Next } for fastNode.Next!=nil{ fastNode=fastNode.Next slowNode=slowNode.Next } slowNode.Next=slowNode.Next.Next return dummy.Next }  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0033.search-in-rotated-sorted-array/">0033</a>
  </h1>
  <time datetime="2021-03-07T14:15:20&#43;0800" class="post-date">2021-03-07 14:15:20</time>
  func search(nums []int, target int) int { left:=0 right:=len(nums)-1 for left&lt;=right{ mid:=(left+right)/2 if nums[mid]==target{ return mid } // 分为两种情况，要么左边是有序的(左半边，最左侧数据&lt;=最右侧数据)，要是是右边 if nums[left]&lt;=nums[mid]{ // 在左侧数据里，既然是有序的，如果target在左侧左右边界里，那么right=mid // 否则就不在左侧，那么left=mid+1 if nums[left]&lt;=target &amp;&amp; target&lt;=nums[mid]{ right=mid }else{ left=mid+1 } }else{ if nums[mid+1]&lt;=target &amp;&amp; target&lt;=nums[right]{ left=mid+1 }else{ right=mid } } } return -1 }  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0005.longest-palindromic-substring/">0005</a>
  </h1>
  <time datetime="2021-03-06T22:30:31&#43;0800" class="post-date">2021-03-06 22:30:31</time>
  func longestPalindrome(s string) string { start:=0 end:=0 sBytes:=[]byte(s) dp:=make([][]bool, 0, len(sBytes)) for i:=0; i&lt;len(sBytes); i++{ dp=append(dp, make([]bool, len(sBytes), len(sBytes))) } for l:=0; l&lt;len(sBytes); l++{ for i:=0; i+l&lt;len(sBytes); i++{ j:=i+l if l==0{ dp[i][j]=true }else if l==1{ if sBytes[i]==sBytes[j]{ dp[i][j]=true } }else{ if sBytes[i]==sBytes[j]{ dp[i][j]=dp[i+1][j-1] } } if dp[i][j] &amp;&amp; end-start&lt;j-i{ end=j start=i } } } return string(sBytes[start:end+1]) }  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0015.3sum/">0015.3sum</a>
  </h1>
  <time datetime="2021-03-06T22:28:39&#43;0800" class="post-date">2021-03-06 22:28:39</time>
  import( &quot;sort&quot; ) func threeSum(nums []int) [][]int { sort.Ints(nums) res:=make([][]int, 0) if len(nums)&lt;=2{ return res } for i:=0; i&lt;len(nums)-2; i++{ // 这里不会存在，0， 0， 0， 0，结果没有数据的原因，是 // i&lt;len(nums)-2, i不会从0走到len(nums)-1 if i&gt;0 &amp;&amp; nums[i]==nums[i-1] { continue } left:=i+1 right:=len(nums)-1 target:=-1*nums[i] for left&lt;right{ if nums[left]+nums[right]==target{ res=append(res, []int{nums[i], nums[left], nums[right]}) // 有结果之后要去重， 没有结果的时候不能去重，比如0， 0， 0， 0...因为都一样，直接去重就都没了 for left&lt;right &amp;&amp; nums[left]==nums[left+1]{ left++ } for left&lt;right &amp;&amp; nums[right]==nums[right-1]{ right-- } left++ right-- }else if nums[left]+nums[right]&lt;target{ left++ }else{ right-- } } } return res }  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0031.next-permutation/">0031</a>
  </h1>
  <time datetime="2021-03-06T21:43:31&#43;0800" class="post-date">2021-03-06 21:43:31</time>
  func nextPermutation(nums []int) { if len(nums)&lt;=1{ return } /* 举个例子： 0 1 2 3 4 1 2 5 8 7 step1: 从后往前，找第一个相邻的升序对(nums[i], nums[i+1]), 这里是5，8, i=2 step2: 在i的右侧，从右往前，找第一个大于nums[i]的数nums[j],这里是7， j=4 step3: 交换i, j 得到 0 1 2 3 4 1 2 7 8 5 step4: reverse(i+1, len(nums)-1) 得到： 1 2 7 5 8 */ i:=len(nums)-2 // 从后面开始，找第一个相邻的升序对 for i&gt;=0 &amp;&amp; nums[i]&gt;=nums[i+1]{ i-- } if i&gt;=0{ j:=len(nums)-1 for j&gt;i &amp;&amp; nums[i]&gt;=nums[j]{ j-- } nums[i], nums[j]=nums[j], nums[i] } reverse(nums, i+1, len(nums)-1) } func reverse(nums []int, left, right int){ for left&lt;right{ nums[left], nums[right]=nums[right], nums[left] left++ right-- } } // 1 2 5 8 7  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0440.k-th-smallest-in-lexicographical-order/">0440.k-th-smallest-lexicographical-order</a>
  </h1>
  <time datetime="2021-03-06T18:47:29&#43;0800" class="post-date">2021-03-06 18:47:29</time>
  1func findKthNumber(n int, k int) int { 2	// 第一个数字一定是1 3	cur:=1 4	k-- 5	for k&gt;0{ 6	nodes:=countNodes(n, cur) 7	if k&lt;nodes{ 8 // ...k...nodes... 9 // 第k个元素在cur的孩子节点中，因此下降到自己的孩子节点，k-1表示刨去cur节点(root节点) 10	k-- 11	cur*=10 12	}else{ 13 // ...nodes...k... 14 // cur的子节点的个数小于k，说明第k个节点不在自己的孩子节点内部，cur++表示转向自己的兄弟节点 15	k-=nodes 16	cur++ 17	} 18	} 19	return cur 20} 21// 以cur为根节点，且最大值为n的十叉树中，有多少个元素 22// 比如下面，以x为root的树(咱们记作tree(x))的所有节点个数, 就等于各个层(从第0层到第N层)的节点的个数的和 23// x+1为root的树是x的右边的第一棵树, 记作tree(x+1) 24// 有意思的是： 对于第i层， 且i&lt;N， tree(x)的第i层的节点的个数等于= tree(x+1)的第i层的第一个节点 - tree(x)的第i层的第一个节点 25// 对于第N层，节点个数= n - tree(x)的第N层的第一个节点 + 1 因为从0开始计数，所以要加1 26// 上面合起来就是： 取 MIN( tree(x+1).
  
  <div class="read-more-link">
    <a href="/posts/leetcode/0440.k-th-smallest-in-lexicographical-order/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0206.reverse-linked-list/">0206</a>
  </h1>
  <time datetime="2021-03-06T18:33:10&#43;0800" class="post-date">2021-03-06 18:33:10</time>
  func reverseList(head *ListNode) *ListNode { var newHead *ListNode cur:=head for cur!=nil{ next:=cur.Next cur.Next=newHead newHead=cur cur=next } return newHead }  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0002.add-two-numbers/">0002</a>
  </h1>
  <time datetime="2021-03-06T16:50:28&#43;0800" class="post-date">2021-03-06 16:50:28</time>
  /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode { dummy:=&amp;ListNode{} tail:=dummy carry:=0 for l1!=nil || l2!=nil{ n1:=0 n2:=0 if l1!=nil{ n1=l1.Val l1=l1.Next } if l2!=nil{ n2=l2.Val l2=l2.Next } curRst:=n1+n2+carry tail.Next=&amp;ListNode{ Val: curRst%10, } tail=tail.Next carry=curRst/10 } // 千万别忘了，最后可能还有进位 if carry!=0{ tail.Next=&amp;ListNode{ Val: carry, } } return dummy.Next }  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0316.remove-duplicate-letters/">0316</a>
  </h1>
  <time datetime="2021-03-06T15:57:34&#43;0800" class="post-date">2021-03-06 15:57:34</time>
  as same as 1081
func removeDuplicateLetters(s string) string { if len(s)&lt;=1{ return s } sBytes:=[]byte(s) // 判断字符是否在栈中 inStack:=make([]bool, 256) // 判断当前剩下的字符中，每个字符还剩多少个 bytesNum:=make([]int, 256) for _, v:=range sBytes{ bytesNum[v]++ } // 变量名不要跟参数重复 stack:=&amp;Stack{ raw: make([]byte, 0), } for _, v:=range sBytes{ // 只要遍历到，剩下的v的个数就要-- bytesNum[v]-- // 已经在栈中了，就不管了 if inStack[v]{ continue } // 如果栈顶元素t比当前v大，且后面还有栈顶元素t，那与其tv, 还不如vt, 后者字典序更小，因此直接pop出t for stack.Len()&gt;0 &amp;&amp; stack.Top()&gt;v &amp;&amp; bytesNum[stack.Top()]&gt;0{ //fmt.Printf(&quot;pop: %c\n&quot;, stack.Top()) inStack[stack.Pop()]=false } stack.Push(v) // fmt.Printf(&quot;stack: %s\n&quot;, string(stack.raw)) inStack[v]=true } return string(stack.
  
  <div class="read-more-link">
    <a href="/posts/leetcode/0316.remove-duplicate-letters/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0407.trapping-rain-water-ii/">0407</a>
  </h1>
  <time datetime="2021-03-06T15:11:56&#43;0800" class="post-date">2021-03-06 15:11:56</time>
  有youtue视频，讲解的很好 https://happygirlzt.com/code/407.html
a b c d e f g h i j k l 对于a, b,  import( &quot;container/heap&quot; ) /* a b c d e f g h i j k l 对于矩阵， a b c d e i h l i j k l 等边界位置，不可能存住水 我们把边界的情况压入优先队列，那么pop出的第一个元素，一定是height最小的，记作curCell 因为一个位置的存水量，取决于四周最矮的高度 因此可以算curCell四个方向的结果，遍历4次，每次的target记作tRow, tCol, tVal target的值为 max(0, curCell.Val-tVal) 然后将target存到优先队列里，因为这个位置的水已经存上去了，高度就变成 max(curVal, tVal) 如果担心某个target位置的存水量会变化，比如 4 4 4 4 4 4 3 3 3 4 4 3 2 3 4 4 3 3 3 4 4 4 4 4 4 担心2第一次存水量算作1，因为周围是3，但是最外层是4，所以应该是2 但是实际上，2不会比3先弹出来， 因为优先队列里存的都是边界，从边界开始向内计算，会先算3的存水量，然后更新成4， 所以2的存水量是正确的 */ */ type Cell struct{ row int col int val int } type PQ struct{ cells []Cell } func(p *PQ)Len()int{ return len(p.
  
  <div class="read-more-link">
    <a href="/posts/leetcode/0407.trapping-rain-water-ii/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0055.jump-game/">0055</a>
  </h1>
  <time datetime="2021-03-06T14:23:40&#43;0800" class="post-date">2021-03-06 14:23:40</time>
  func canJump(nums []int) bool { // 记录当前位置之前能够到达的最远索引 maxPosition:=0 for i:=0; i&lt;len(nums); i++{ // 如果i大于当前能够到达的最远索引，说明没法到达了 // 因为游戏继续进行下去的前提是能够到达i， // i&gt;maxPosition 表示当前的跳远最远距离都到达不了索引i了 if i&gt;maxPosition{ return false } maxPosition=getMax(maxPosition, i+nums[i]) } return true } func getMax(a, b int)int{ if a&gt;b{ return a } return b }  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0045.jump-game-ii/">0045</a>
  </h1>
  <time datetime="2021-03-06T13:43:02&#43;0800" class="post-date">2021-03-06 13:43:02</time>
  func jump(nums []int) int { end:=0 steps:=0 maxPosition:=0 for i:=0; i&lt;len(nums)-1; i++{ maxPosition=getMax(maxPosition, i+nums[i]) if i==end{ end=maxPosition steps++ } } return steps } func getMax(a, b int)int{ if a&gt;b{ return a } return b }  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/403/">403</a>
  </h1>
  <time datetime="2021-03-05T17:13:02&#43;0800" class="post-date">2021-03-05 17:13:02</time>
  package main import &quot;fmt&quot; func canCross(stones []int) bool { // stone2Prevs 表示石头，到上一次跳到这块石头上的步数的集合 stone2Prevs:=make(map[int]map[int]struct{}, len(stones)) for _, v:=range stones{ stone2Prevs[v]=make(map[int]struct{}) } stone2Prevs[stones[0]][0]= struct{}{} for i:=0; i&lt;len(stones); i++{ // 跳到这一块石头的上一次的步数的集合 prevs:=stone2Prevs[stones[i]] for prev, _:=range prevs{ for curStep:=prev-1; curStep&lt;=prev+1; curStep++{ // 向左跳或者不动是非法的 if curStep&lt;=0{ continue } // 下一跳的位置 nextStone:=stones[i]+curStep // 如果这个位置没有石头，就continue if _, ok:=stone2Prevs[nextStone]; !ok{ continue } stone2Prevs[nextStone][curStep]= struct{}{} } } } return len(stone2Prevs[stones[len(stones)-1]])&gt;0 } func main(){ var stones []int stones=[]int{0,1,3,5,6,8,12,17} stones=[]int{0,1,2,3,4,5,6,12} stones=[]int{0,2} fmt.
  
  <div class="read-more-link">
    <a href="/posts/leetcode/403/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0092/">0092</a>
  </h1>
  <time datetime="2021-03-05T15:11:12&#43;0800" class="post-date">2021-03-05 15:11:12</time>
  // reverse m~n
func reverseBetween(head *ListNode, m, n int) *ListNode { dummy := &amp;ListNode{} dummy.Next = head // m-1+1 比如dummy-&gt;1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6 m=2, n=5 // m=2其实是取前m-1个，因为m属于第二部分 // 由于dummy的存在，需要加一个1跳过dummy firstPartTail, secondPartHead := splitN(dummy, m-1+1) // n-m+1 因为n跟m都属于第二部分，所以总共有n-m+1个元素 _, thirdPartHead := splitN(secondPartHead, n-m+1) //printList(&quot;secondPartHead&quot;, secondPartHead) //printList(&quot;thirdPartHead&quot;, thirdPartHead) reversedSecondPartHead := reverseList(secondPartHead) reversedSecondPartTail := secondPartHead firstPartTail.Next = reversedSecondPartHead reversedSecondPartTail.Next = thirdPartHead return dummy.Next } // 比如 dummy-&gt;1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6 k=3 // 就是取前三个，然后断开，分成两部分: // dummy-&gt;1-&gt;2 与 3-&gt;4-&gt;5-&gt;6 // 然后返回第一部分的最后一个: 2 // 跟第二部分第一个：3 func splitN(head *ListNode, k int) (*ListNode, *ListNode) { k-- cur := head for cur !
  
  <div class="read-more-link">
    <a href="/posts/leetcode/0092/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/content/leetcode/0092/">0092</a>
  </h1>
  <time datetime="2021-03-05T15:10:18&#43;0800" class="post-date">2021-03-05 15:10:18</time>
  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/480/">480.sliding-window-median</a>
  </h1>
  <time datetime="2021-03-04T11:41:45&#43;0800" class="post-date">2021-03-04 11:41:45</time>
  package main import ( &quot;container/heap&quot; &quot;fmt&quot; ) func top(h *MyHeap) int { elem := heap.Pop(h).(int) heap.Push(h, elem) return elem } func getMid(firstHeap, secondHeap *MyHeap, k int) float64 { firstElem := top(firstHeap) if k%2 == 1 { return float64(firstElem) } secondElem := top(secondHeap) return float64(secondElem+firstElem) / 2 } func medianSlidingWindow(nums []int, k int) []float64 { /* if k == 0 { return nil } if k == 1 { numsFloat64 := make([]float64, 0, len(nums)) for _, v := range nums { numsFloat64 = append(numsFloat64, float64(v)) } return numsFloat64 } if len(nums) &lt; k { return nil } */ firstHeap := NewHeap(make([]int, 0), func(a, b int) bool { return a &gt; b }) secondHeap := NewHeap(make([]int, 0), func(a, b int) bool { return a &lt; b }) for i := 0; i &lt; k; i++ { heap.
  
  <div class="read-more-link">
    <a href="/posts/leetcode/480/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/golang/heap/">Heap</a>
  </h1>
  <time datetime="2021-03-04T11:34:19&#43;0800" class="post-date">2021-03-04 11:34:19</time>
  package main import ( &quot;container/heap&quot; &quot;fmt&quot; ) // An IntHeap is a min-heap of ints. type IntHeap []int func (h IntHeap) Len() int { return len(h) } func (h IntHeap) Less(i, j int) bool { return h[i] &lt; h[j] } func (h IntHeap) Swap(i, j int) { h[i], h[j] = h[j], h[i] } func (h *IntHeap) Push(x interface{}) { // Push and Pop use pointer receivers because they modify the slice's length, // not just its contents.
  
  <div class="read-more-link">
    <a href="/posts/golang/heap/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/algo/kmp/">Kmp</a>
  </h1>
  <time datetime="2021-03-04T11:26:13&#43;0800" class="post-date">2021-03-04 11:26:13</time>
  package main import ( &quot;fmt&quot; ) func main() { s := &quot;atoddasdfasdtodd&quot; p := &quot;abab&quot; rst := match(s, p) fmt.Printf(&quot;rst: %+v\n&quot;, rst) } func match(s, p string) []int { nxt := build(p) ret := make([]int, 0) for i, j := 0, 0; i &lt; len(s); i++ { for j &gt; 0 &amp;&amp; s[i] != p[j] { j = nxt[j] } if s[i] == p[j] { j++ } if j == len(p) { ret = append(ret, i-len(p)+1) j = nxt[j] } } return ret } // build would build the next array // a b a b // 0 0 0 1 2 // nxt[i]表示，p[:i]字符串，最长的相同的前缀跟后缀的长度 // 比如nxt[3], p[:3]=&quot;aba&quot;, 前缀a，跟后缀a // 比如nxt[4], p[:4]=&quot;abab&quot;, 前缀ab，跟后缀ab func build(p string) []int { ret := make([]int, 0, len(p)) ret = append(ret, 0) ret = append(ret, 0) for i, j := 1, 0; i &lt; len(p); i++ { for j &gt; 0 &amp;&amp; p[i] !
  
  <div class="read-more-link">
    <a href="/posts/algo/kmp/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/redis/eviction/">Eviction</a>
  </h1>
  <time datetime="2021-03-03T17:42:48&#43;0800" class="post-date">2021-03-03 17:42:48</time>
  volatile: 易变的;无定性的;无常性的;可能急剧波动的;不稳定的;易恶化的;易挥发的;易发散的 lru: Least Recently Used 默认策略是 volatile-lru，即超过最大内存后，在过期键中使用 lru 算法进行 key 的剔除，保证不过期数据不被删除，但是可能会出现 OOM 问题。 allkeys-lru：根据 LRU 算法删除键，不管数据有没有设置超时属性，直到腾出足够空间为止。 allkeys-random：随机删除所有键，直到腾出足够空间为止。 volatile-random:随机删除过期键，直到腾出足够空间为止。 volatile-ttl：根据键值对象的 ttl 属性，删除最近将要过期数据。如果没有，回退到 noeviction 策略。 noeviction：不会剔除任何数据，拒绝所有写入操作并返回客户端错误信息&quot;(error) OOM command not allowed when used memory&quot;，此时 Redis 只响应读操作。  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/redis/command/">Command</a>
  </h1>
  <time datetime="2021-03-03T15:37:35&#43;0800" class="post-date">2021-03-03 15:37:35</time>
  Available since 1.0.0. Time complexity: O(1) Set key to hold the string value. If key already holds a value, it is overwritten, regardless of its type. Any previous time to live associated with the key is discarded on successful SET operation. Options The SET command supports a set of options that modify its behavior: EX seconds -- Set the specified expire time, in seconds. PX milliseconds -- Set the specified expire time, in milliseconds.
  
  <div class="read-more-link">
    <a href="/posts/redis/command/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/mysql/type/">Type</a>
  </h1>
  <time datetime="2021-03-03T14:50:40&#43;0800" class="post-date">2021-03-03 14:50:40</time>
  varchar不定长度 存储: 实际字符串，加上1/2/3字节的字符串长度 &quot; a &quot; 取出来也是&quot; a &quot;, 长度是3 对于未指定varchar字段not null的表，会有1个字节专门表示该字段是否为null char定长 存储: 实际字符串 &quot; a &quot; 取出来也是&quot; a&quot;, 长度是2 因为定长，默认就是空格，a后面的空格，分不清是用户指定输入的，还是默认值 mysql&gt; create table test_string ( -&gt; char_value char(5), -&gt; varchar_value varchar(5), -&gt; text_value text default &quot;&quot;) engine=innodb charset=utf8; ERROR 1101 (42000): BLOB, TEXT, GEOMETRY or JSON column 'text_value' can't have a default value mysql&gt; varchar和text两种数据类型，使用建议是能用varchar就用varchar而不用text（存储效率高），varchar(M)的M有长度限制，之前说过，如果大于限制，可以使用mediumtext（16M）或者longtext（4G）。 至于text和blob，简单过一下就是text存储的是字符串而blob存储的是二进制字符串，简单说blob是用于存储例如图片、音视频这种文件的二进制数据的。  mysql&gt; create table td(a decimal(10,5)); Query OK, 0 rows affected (0.02 sec) mysql&gt; insert into td(a) values(1.
  
  <div class="read-more-link">
    <a href="/posts/mysql/type/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/mysql/base/">Base</a>
  </h1>
  <time datetime="2021-03-03T14:12:14&#43;0800" class="post-date">2021-03-03 14:12:14</time>
    
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/algo/segment-tree/">Segment Tree</a>
  </h1>
  <time datetime="2021-03-02T15:14:44&#43;0800" class="post-date">2021-03-02 15:14:44</time>
  n(i) represents the node number of binary tree having i child/s sum = n(0)+n(1)+n(2) 另一个角度，所有节点分两类： 孩子节点， 非孩子节点(有且只有一个，就是root节点) n(1)*1就是有一个孩子节点的所有节点的孩子总数 n(2)*2就是有两个孩子节点的所有节点的孩子总数 sum = sum(孩子节点) + sum(非孩子节点) =n(1)+2*n(2) + 1 因此n(0)+n(1)+n(2)=n(1)+2*n(2)+1 =&gt; n(0)=n(2)+1 对于线段树，n(1)=0 然后对于输入的原始数组，长度为N，也就是n(0)=N， n(2)=n(0)-1=N-1 最好情况，满二叉树： sum = n(0)+n(2)=N+N-1=2N-1 最坏情况: x / \ a x // 倒数第二层 / \ a a // 倒数第一层 倒数第二层的a类型的节点个数:(N-2) 倒数第二层以及上面的节点个数: sum(倒数第二层以及以上) = 2(N-2)+1=2N-4+1=2N-3 sum(倒数第二层节点个数, 虽有只有两个，但是因为是数组，前面全部填空) = (N-2)*2=2N-4 所以sum=2N-3+2N-4=4N-7 所以4N个肯定够用了  package main import &quot;fmt&quot; var merge func(v1, v2 int) int type Node struct { start int end int value int left *Node right *Node } func buildTree(start, end int, vals []int) *Node { if start == end { return &amp;Node{ start: start, end: end, value: vals[start], } } mid := start + (end-start)/2 leftChild := buildTree(start, mid, vals) rightChild := buildTree(mid+1, end, vals) return &amp;Node{ start: start, end: end, value: merge(leftChild.
  
  <div class="read-more-link">
    <a href="/posts/algo/segment-tree/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/algo/binary-index-tree/">Binary Index Tree</a>
  </h1>
  <time datetime="2021-03-02T13:53:38&#43;0800" class="post-date">2021-03-02 13:53:38</time>
  package main import &quot;fmt&quot; type BinaryIndexTree struct { raw []int } // lowbit的作用： // x的二进制表示： xxxx...10...0 // 返回 10...0 // 换句话说，返回二进制表示形式中，最低位1所组成的数字 func lowbit(x int) int { return x &amp; (-1 * x) } // Build创建 假设原始数组是s, 新的数组是a 为了方便，全部假设下标从1开始计数 // 1 第三层root // 1 5 第二层root // 1 3 5 7 第一层root // 1 2 3 4 5 6 7 8 新数组的下标，为了方便，从1开始计数，浪费下标0 // // 对于给定一个下标， // 对于奇数2i+1，a[2i+1]=s[2i+1] // // 换个角度，算下s[i]会影响数组a的哪些数值 // 答案：a[i]一定会被影响，然后影响右侧的包含s[i]的树 // 如何求i的右侧的第一棵树？ i+lowbit(i) 可以把i的二进制形式看做一颗树 // 1表示树，那么右侧第一棵树，就是i的最低位的1，这一位加1，就是右边第一棵树的索引 // 创建的时候，从左到右依次处理，那么每个元素只需要处理自己右侧最近的一棵树tree1即可(后面的树tree2,再计算tree1的时候，会修改tree2, 依次传递下去) func (b *BinaryIndexTree) Build(s []int) { b.
  
  <div class="read-more-link">
    <a href="/posts/algo/binary-index-tree/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0304.range-sum-query-2d-immutable/">0304.range-sum-query-2d-immutable</a>
  </h1>
  <time datetime="2021-03-02T13:44:15&#43;0800" class="post-date">2021-03-02 13:44:15</time>
  A00 A01 A02 A03 A10 A11 A12 A13 A20 A21 A22 A23 A30 A31 A32 A33 A21表示 i&lt;=2, j&lt;=1的矩形的和 // 需要判断下是否越界 如果要求A21 A21=(A11)+(A20)-(A10)+s[2][1] 如果求(i=1, j=1)跟(j=2, j=2)的和 和=A22-A12-A21+A11 如果求(i1, j1)跟(i2, j2)的和, 当然需要判断下边界 和=A[i2][j2]-A[i1-1][j2]-A[i2][j1-1]+A[i1-][j1-1]  type NumMatrix struct { raw [][]int } func Constructor(matrix [][]int) NumMatrix { if len(matrix)==0{ return NumMatrix{ raw: nil, } } raw := make([][]int, 0, len(matrix[0])) for i:=0; i&lt;len(matrix); i++{ raw=append(raw, make([]int, len(matrix[0]), len(matrix[0]))) } for i:=0; i&lt;len(matrix); i++{ for j:=0; j&lt;len(matrix[0]); j++{ raw[i][j]=matrix[i][j] if i&gt;0{ raw[i][j]+=raw[i-1][j] } if j&gt;0{ raw[i][j]+=raw[i][j-1] } if i&gt;0 &amp;&amp; j&gt;0{ raw[i][j]-=raw[i-1][j-1] } } } return NumMatrix{ raw: raw, } } func (this *NumMatrix) SumRegion(row1 int, col1 int, row2 int, col2 int) int { ret:=this.
  
  <div class="read-more-link">
    <a href="/posts/leetcode/0304.range-sum-query-2d-immutable/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0215.kth-largest-element-in-an-array/">0215</a>
  </h1>
  <time datetime="2021-03-01T20:00:04&#43;0800" class="post-date">2021-03-01 20:00:04</time>
  func findKthLargest(nums []int, k int) int { // kth内部从0开始算，第0大的数 return kth(nums, 0, len(nums)-1, k-1) } func kth(s []int, left, right, k int) int { if left &lt;= right { // 这里的m一定是s里的元素的索引 m := partition(s, left, right) if m == k { return s[m] } if m &lt; k { // 最后一个参数k return kth(s, m+1, right, k) } else { // 最后一个参数k return kth(s, left, m-1, k) } } return -1 } func partition(s []int, left, right int) int { i := left - 1 j := left pivot := s[right] for ; j &lt; right; j++ { if s[j] &gt; pivot { i = i + 1 s[i], s[j] = s[j], s[i] } } i = i + 1 s[i], s[j] = s[j], s[i] return i }  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0121.best-time-to-buy-and-sell-stock/">0121</a>
  </h1>
  <time datetime="2021-02-28T22:11:58&#43;0800" class="post-date">2021-02-28 22:11:58</time>
  func maxProfit(prices []int) int { if len(prices)==0{ return 0 } minPrice:=0 maxProfit:=0 minPrice=prices[0] for _, v:=range prices{ if minPrice&gt;v{ minPrice=v }else if maxProfit&lt; v-minPrice{ maxProfit=v-minPrice } } return maxProfit }  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0122.best-time-to-buy-and-sell-stock-ii/">0122.best-time-to-buy-and-sell-stock-ii</a>
  </h1>
  <time datetime="2021-02-28T21:55:34&#43;0800" class="post-date">2021-02-28 21:55:34</time>
  // dp[i][0]表示第i天结束后，不持有股票的最大收益 // dp[i][1]表示第i天结束后，持有股票的最大收益 func maxProfit(prices []int) int { n := len(prices) dp := make([][2]int, n) dp[0][1] = -prices[0] for i := 1; i &lt; n; i++ { // 第i天结束后不持有股票，有两种可能： // 1. 昨天就不持有股票 // 2. 昨天持有股票，今天卖掉了 dp[i][0] = max(dp[i-1][0], dp[i-1][1]+prices[i]) // 第i天结束后持有股票，有两种可能： // 1. 昨天就持有股票 // 2. 昨天不持有股票，今天又买进了 dp[i][1] = max(dp[i-1][1], dp[i-1][0]-prices[i]) } return dp[n-1][0] } func max(a, b int) int { if a &gt; b { return a } return b }  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0096.unique-binary-search-trees/">0096.unique-binary-search-trees</a>
  </h1>
  <time datetime="2021-02-26T15:57:23&#43;0800" class="post-date">2021-02-26 15:57:23</time>
  /* G(n): 长度为 n 的序列能构成的不同二叉搜索树的个数。 F(i, n): 以 i 为根、序列长度为 n 的不同二叉搜索树个数 G(n)=F(1, n)+F(2, n)+...+F(n, n) 1 2 3 ... i ... n A A A AAA BBB B F(i, n)=G(i-1)*G(n-i) ^^ F(i, n)， i已经是root了，那么i左边的部分A是left tree, i右边的部分B是right tree 从A组成的tree list里选一个，从B组成的tree list里选一种，总共就是两者相乘的可能数 i的范围是从1到n，对应到代码里，是从1到i, 因为求的是G[i], 此时n=i */ func numTrees(n int) int { G := make([]int, n + 1) G[0], G[1] = 1, 1 for i := 2; i &lt;= n; i++ { // for j := 1; j &lt;= i; j++ { G[i] += G[j-1] * G[i-j] } } return G[n] }  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0105.construct-binary-tree-from-preorder-and-inorder-traversal/">0105.construct-binary-tree-from-preorder-and-inorder-traversal</a>
  </h1>
  <time datetime="2021-02-26T15:37:56&#43;0800" class="post-date">2021-02-26 15:37:56</time>
  /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func buildTree(preorder []int, inorder []int) *TreeNode { if len(preorder)==0{ return nil } curNode:=&amp;TreeNode{ Val: preorder[0], } rootValIdxInInorder:=0 for idx, v:=range inorder{ if v==preorder[0]{ rootValIdxInInorder=idx break } } // 难在构建左子树、右子树函数的参数 // preorder: root A B // inorder: A root B // 所以找到A与B在preorder/inorder里的起始位置，再将A/B part作为参数即可 curNode.Left=buildTree(preorder[1:len(inorder[:rootValIdxInInorder])+1], inorder[:rootValIdxInInorder]) curNode.Right=buildTree(preorder[len(inorder[:rootValIdxInInorder])+1:], inorder[rootValIdxInInorder+1:]) return curNode }  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0103.binary-tree-zigzag-level-order-traversal/">0103.binary-tree-zigzag-level-order-traversal</a>
  </h1>
  <time datetime="2021-02-26T15:22:21&#43;0800" class="post-date">2021-02-26 15:22:21</time>
  /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func zigzagLevelOrder(root *TreeNode) [][]int { if root==nil{ return nil } ret:=make([][]int, 0) nextQ:=make([]*TreeNode, 0) nextQ=append(nextQ, root) level:=0 for len(nextQ)!=0{ curQ:=nextQ nextQ=make([]*TreeNode, 0) curVals:=make([]int, 0, len(curQ)) for i:=0; i&lt;len(curQ); i++{ curNode:=curQ[i] if curNode.Left!=nil{ nextQ=append(nextQ, curNode.Left) } if curNode.Right!=nil{ nextQ=append(nextQ, curNode.Right) } curVals=append(curVals, curNode.Val) } // 为了简单，直接根据层数的奇偶来做倒置 if level%2==1{ for i:=0; i&lt;len(curVals)/2; i++{ curVals[i], curVals[len(curVals)-i-1]=curVals[len(curVals)-i-1], curVals[i] } } ret=append(ret, curVals) level++ } return ret }  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0124.binary-tree-maximum-path-sum/">0124.binary-tree-maximum-path-sum</a>
  </h1>
  <time datetime="2021-02-26T14:58:35&#43;0800" class="post-date">2021-02-26 14:58:35</time>
  ```go /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ var ret int var retIsSet bool func maxPathSum(root *TreeNode) int { ret=0 retIsSet=false
helper(root) return ret  }
// 获得一定包含root，且以root为起点，且单边(左子树或右子树路径上单链，当然可以只包含root，比如root的下面的节点都是负数，就可以只包含root)的最大值 func helper(root *TreeNode) int { if root==nil{ return 0 }
// 如果helper(root.Left)为负数，还不如不包含后面的节点，直接设置为0 left:=getMax(0, helper(root.Left)) right:=getMax(0, helper(root.Right)) // 以root为最高层节点，的结果的最优值，只要遍历所有节点的最优值，且取最大值，即得到结果 curVal:=left+right+root.Val if retIsSet{ ret=getMax(ret, curVal) }else{ retIsSet=true ret=curVal } if left&gt;right{ return left+root.
  
  <div class="read-more-link">
    <a href="/posts/leetcode/0124.binary-tree-maximum-path-sum/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0199.binary_tree_right_side_view/">0199.binary-tree-right-side-view</a>
  </h1>
  <time datetime="2021-02-26T14:55:03&#43;0800" class="post-date">2021-02-26 14:55:03</time>
  需要区分二叉树的这一层下一层，准备俩queue，一个当前处理的curQ， 一个q存放从curQ里出来的node的孩子节点 然后curQ=q; q=nil 继续下一次循环
/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func rightSideView(root *TreeNode) []int { if root==nil{ return nil } ret:=make([]int, 0) q:=make([]*TreeNode, 0) q=append(q, root) for len(q)!=0{ curRst:=0 curQ:=q q=nil for i:=0; i&lt;len(curQ); i++{ curNode:=curQ[i] curRst=curNode.Val if curNode.Left!=nil{ q=append(q, curNode.Left) } if curNode.Right!=nil{ q=append(q, curNode.Right) } } ret=append(ret, curRst) } return ret }  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0025.reverse-nodes-in-k-group/">0025.reverse-nodes-in-k-group</a>
  </h1>
  <time datetime="2021-02-25T15:58:28&#43;0800" class="post-date">2021-02-25 15:58:28</time>
  1package main 2 3import &#34;fmt&#34; 4 5// Definition for singly-linked list. 6type ListNode struct { 7	Val int 8	Next *ListNode 9} 10 11func reverseKGroup(head *ListNode, k int) *ListNode { 12	if head==nil || head.Next==nil{ 13	return head 14	} 15	if k&lt;=1{ 16	return head 17	} 18 19	lastNode:=head 20	for i:=0; i &lt; k-1; i++ { 21	lastNode = lastNode.Next 22	if lastNode==nil{ 23	return head 24	} 25	} 26 27	// nextPartHead是下一段的开始节点 28	nextPartHead := lastNode.
  
  <div class="read-more-link">
    <a href="/posts/leetcode/0025.reverse-nodes-in-k-group/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/golang/pointer_struct/">Pointer_struct</a>
  </h1>
  <time datetime="2021-02-20T17:58:58&#43;0800" class="post-date">2021-02-20 17:58:58</time>
  package main import ( &quot;fmt&quot; ) type A struct { PointerValue string StructValue string } func (a *A) PointerSet(v string) { a.PointerValue = v } func (a A) StructSet(v string) { a.StructValue = v } func main() { s := A{PointerValue: &quot;beforeChange&quot;, StructValue: &quot;beforeChange&quot;} p := &amp;A{PointerValue: &quot;beforeChange&quot;, StructValue: &quot;beforeChange&quot;} fmt.Printf(&quot;s: %+v\n&quot;, s) // s: {PointerValue:beforeChange StructValue:beforeChange} // changed s.PointerSet(&quot;afterChange&quot;) // not changed s.StructSet(&quot;afterChange&quot;) fmt.Printf(&quot;s: %+v\n&quot;, s) // s: {PointerValue:afterChange StructValue:beforeChange} fmt.
  
  <div class="read-more-link">
    <a href="/posts/golang/pointer_struct/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/golang/interface_pointer_struct/">Interface_pointer_struct</a>
  </h1>
  <time datetime="2021-02-20T17:56:54&#43;0800" class="post-date">2021-02-20 17:56:54</time>
  package main import &quot;fmt&quot; type Inter interface { SetName(name string) } type A struct { Name string } func (a A) SetName(name string) { a.Name = name } type B struct { Name string } func (b *B) SetName(name string) { b.Name = name } func main() { var a Inter = A{Name: &quot;todd&quot;} a.SetName(&quot;alice&quot;) fmt.Printf(&quot;a: %+v\n&quot;, a) // ?相当于 SetName((复制ap然后解引用(*copy_ap)), &quot;alice&quot;) // ?修改的不是同一个值 // 修改失败 var ap Inter = &amp;A{Name: &quot;todd&quot;} ap.
  
  <div class="read-more-link">
    <a href="/posts/golang/interface_pointer_struct/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/golang/interface/">Interface</a>
  </h1>
  <time datetime="2021-02-19T11:05:14&#43;0800" class="post-date">2021-02-19 11:05:14</time>
  https://cmc.gitbook.io/go-internals/chapter-ii-interfaces
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0560.subarray-sum-equals-k/">0560.subarray-sum-equals-k</a>
  </h1>
  <time datetime="2020-12-31T17:01:26&#43;0800" class="post-date">2020-12-31 17:01:26</time>
  题目简介 给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。
示例 1 :
输入:nums = [1,1,1], k = 2 输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。 说明 :
数组的长度为 [1, 20,000]。 数组中元素的范围是 [-1000, 1000] ，且整数 k 的范围是 [-1e7, 1e7]。
解 解1 1/* 2比如 ABCDEFG... 3如果当前所有的和是Sum(A...G) 4如果存在Sum(A...X), 使得 Sum(A...X)+k=Sum(A...G)， 5也就是说，Sum(A...G)-k这个数存在， 6那么，(X...G]就是满足条件的 7*/ 8 9class Solution { 10 public int subarraySum(int[] nums, int k) { 11 // 扫描一遍数组, 使用map记录出现同样的和的次数, 对每个i计算累计和sum并判断map内是否有sum-k 12 Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); 13 // 放0的目的是： 如果Sum(A.
  
  <div class="read-more-link">
    <a href="/posts/leetcode/0560.subarray-sum-equals-k/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0435.non-overlapping-intervals/">0435.non-overlapping-intervals</a>
  </h1>
  <time datetime="2020-12-31T15:23:58&#43;0800" class="post-date">2020-12-31 15:23:58</time>
  示例 1: 输入: [ [1,2], [2,3], [3,4], [1,3] ] 输出: 1 解释: 移除 [1,3] 后，剩下的区间没有重叠。 示例 2: 输入: [ [1,2], [1,2], [1,2] ] 输出: 2 解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。 贪心策略: 先按照右边界从小到大排序，然后依次遍历，不能放进去的(左边界小于左边区间的右边界)，就删掉  1import ( 2	&#34;sort&#34; 3) 4 5// non-overlapping-intervals 6func eraseOverlapIntervals(intervals [][]int) int { 7	if len(intervals) == 0 { 8	return 0 9	} 10	sort.Slice(intervals, func(i, j int) bool { 11	return intervals[i][1] &lt; intervals[j][1] 12	}) 13 14	curRight := intervals[0][1] 15	ret := 0 16	for i := 1; i &lt; len(intervals); i++ { 17	if curRight &lt;= intervals[i][0] { 18	curRight = intervals[i][1] 19	} else { 20	ret++ 21	} 22	} 23	return ret 24} 
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0003.longest-substring-without-repeating-characters/">0003.longest-substring-without-repeating-characters</a>
  </h1>
  <time datetime="2020-12-30T20:48:41&#43;0800" class="post-date">2020-12-30 20:48:41</time>
  1func getMax(a, b int)int{ 2 if a&gt;b{ 3 return a 4 } 5 return b 6} 7func getMin(a, b int)int{ 8 if a&gt;b{ 9 return b 10 } 11 return a 12} 13 14func lengthOfLongestSubstring(s string) int { 15 lookup := make(map[rune]int) 16	curLeft := 0 17	maxLen := 0 18	for k, v := range s { 19	if lastIdx, ok := lookup[v]; ok { 20 curLeft=getMax(lastIdx+1, curLeft) 21	} 22 maxLen=getMax(maxLen, k-curLeft+1) 23 lookup[v]=k 24	} 25	return maxLen 26} 
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0004.median-of-two-sorted-arrays/">0004.median-of-two-sorted-arrays</a>
  </h1>
  <time datetime="2020-12-30T20:04:23&#43;0800" class="post-date">2020-12-30 20:04:23</time>
  示例 1： 输入：nums1 = [1,3], nums2 = [2] 输出：2.00000 解释：合并数组 = [1,2,3] ，中位数 2 示例 2： 输入：nums1 = [1,2], nums2 = [3,4] 输出：2.50000 解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5 示例 3： 输入：nums1 = [0,0], nums2 = [0,0] 输出：0.00000 示例 4： 输入：nums1 = [], nums2 = [1] 输出：1.00000 示例 5： 输入：nums1 = [2], nums2 = [] 输出：2.00000  1import ( 2	&#34;math&#34; 3) 4 5func findMedianSortedArrays(nums1 []int, nums2 []int) float64 { 6	left := (len(nums1) + len(nums2) + 1) / 2 7	right := (len(nums1) + len(nums2) + 2) / 2 8	return (float64(findK(nums1, 0, nums2, 0, left)) + float64(findK(nums1, 0, nums2, 0, right))) / 2.
  
  <div class="read-more-link">
    <a href="/posts/leetcode/0004.median-of-two-sorted-arrays/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0208.mplement-trie-prefix-tree/">0208.mplement-trie-prefix-tree</a>
  </h1>
  <time datetime="2020-12-30T19:12:02&#43;0800" class="post-date">2020-12-30 19:12:02</time>
  1type Node struct { 2	IsEnd bool 3	Val rune 4	Next map[rune]*Node 5} 6 7type Trie struct { 8	root *Node 9} 10 11/** Initialize your data structure here. */ 12func Constructor() Trie { 13	return Trie{ 14	root: &amp;Node{ 15	Next: make(map[rune]*Node), 16	}, 17	} 18} 19 20/** Inserts a word into the trie. */ 21func (this *Trie) Insert(word string) { 22	cur := this.root 23	for _, v := range word { 24	if nextNode, ok := cur.
  
  <div class="read-more-link">
    <a href="/posts/leetcode/0208.mplement-trie-prefix-tree/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/1035.uncrossed-lines/">1035.uncrossed-lines</a>
  </h1>
  <time datetime="2020-12-30T18:40:16&#43;0800" class="post-date">2020-12-30 18:40:16</time>
  给定 1 4 2 1 2 4 上下相同的数连接画一条线，最多只能画两条线 类似： 1143 本质是最长公共子序列  1func maxUncrossedLines(A []int, B []int) int { 2	dp := make([][]int, 0, len(A)+1) 3	for i := 0; i &lt; len(A)+1; i++ { 4	dp = append(dp, make([]int, len(B)+1, len(B)+1)) 5	} 6 7	for i, v1 := range A { 8	for j, v2 := range B { 9	if v1 == v2 { 10	dp[i+1][j+1] = dp[i][j] + 1 11	} else { 12	dp[i+1][j+1] = getMaxInt(dp[i+1][j], dp[i][j+1]) 13	} 14	} 15	} 16 17	return dp[len(A)][len(B)] 18} 19 20func getMaxInt(a, b int) int { 21	if a &gt; b { 22	return a 23	} 24	return b 25} 
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/1143.longest-common-subsequence/">1143.longest-common-subsequence</a>
  </h1>
  <time datetime="2020-12-30T18:32:29&#43;0800" class="post-date">2020-12-30 18:32:29</time>
  两个数组的 最长公共子序列 子序列：不一定连续 1143 子数组：一定连续 718 换汤不换药 1035  1func longestCommonSubsequence(text1 string, text2 string) int { 2	dp := make([][]int, 0, len(text1)+1) 3	for i := 0; i &lt; len(text1)+1; i++ { 4	dp = append(dp, make([]int, len(text2)+1, len(text2)+1)) 5	} 6 7	for i, ch1 := range text1 { 8	for j, ch2 := range text2 { 9	if ch1 == ch2 { 10	dp[i+1][j+1] = dp[i][j] + 1 11	} else { 12	dp[i+1][j+1] = getMaxInt(dp[i+1][j], dp[i][j+1]) 13	} 14	} 15	} 16 17	return dp[len(text1)][len(text2)] 18} 19 20func getMaxInt(a, b int) int { 21	if a &gt; b { 22	return a 23	} 24	return b 25} 
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0718.maximum-length-of-repeated-subarray/">0718.maximum-length-of-repeated-subarray</a>
  </h1>
  <time datetime="2020-12-30T17:26:31&#43;0800" class="post-date">2020-12-30 17:26:31</time>
  两个数组的 最长子数组 子序列：不一定连续 1143 子数组：一定连续 718  1func findLength(A []int, B []int) int { 2	if len(A) == 0 || len(B) == 0 { 3	return 0 4	} 5	6 // dp[i][j]表示以A[i] B[j]结尾的相同子数组的长度 7	dp := make([][]int, 0, len(A)) 8	for i := 0; i &lt; len(A); i++ { 9	dp = append(dp, make([]int, len(B), len(B))) 10	} 11 12 // 为了避免i=0, j=0, 此时0-1=-1，索引非法的问题，先初始化0的情况 13	for i := 0; i &lt; len(A); i++ { 14	if A[i] == B[0] { 15	dp[i][0] = 1 16	} 17	} 18	for j := 0; j &lt; len(B); j++ { 19	if A[0] == B[j] { 20	dp[0][j] = 1 21	} 22	} 23 24	ret := 0 25 26	for i := 1; i &lt; len(A); i++ { 27	for j := 1; j &lt; len(B); j++ { 28	if A[i] == B[j] { 29	dp[i][j] = dp[i-1][j-1] + 1 30	if ret &lt; dp[i][j] { 31	ret = dp[i][j] 32	} 33	} 34	} 35	} 36 37	return ret 38} 或者数组多一位  1func findLength(A []int, B []int) int { 2	if len(A) == 0 || len(B) == 0 { 3	return 0 4	} 5 6	dp := make([][]int, 0, len(A)+1) 7	for i := 0; i &lt; len(A)+1; i++ { 8	dp = append(dp, make([]int, len(B)+1, len(B)+1)) 9	} 10 11	ret := 0 12 13	for i := 1; i &lt;= len(A); i++ { 14	for j := 1; j &lt;= len(B); j++ { 15	if A[i-1] == B[j-1] { 16	dp[i][j] = dp[i-1][j-1] + 1 17	if ret &lt; dp[i][j] { 18	ret = dp[i][j] 19	} 20	} 21	} 22	} 23 24	return ret 25} 26``` 
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/1206.design-skiplist/">1206.design-skiplist</a>
  </h1>
  <time datetime="2020-12-30T16:37:20&#43;0800" class="post-date">2020-12-30 16:37:20</time>
  1import ( 2	&#34;math/rand&#34; 3) 4 5const ( 6	maxLevel = 16 7	skipListPVal = 0.5 8) 9 10// randomLevel 返回一个Next数组的高度, 高度不能超过最大值 11func randomLevel() int { 12	retLevel := 1 13	for retLevel &lt; maxLevel &amp;&amp; rand.Float32() &lt; skipListPVal { 14	retLevel++ 15	} 16	return retLevel 17} 18 19type Node struct { 20	Val int 21	Next [maxLevel]*Node 22} 23 24func NewNode(val int, next [maxLevel]*Node) *Node { 25	return &amp;Node{ 26	Val: val, 27	Next: next, 28	} 29} 30 31type Skiplist struct { 32	head *Node 33	maxLevel int 34} 35 36func Constructor() Skiplist { 37	return Skiplist{ 38	// head 里的值是最小值,这里取-1 39	head: NewNode(-1, [maxLevel]*Node{}), 40	maxLevel: 1, 41	} 42} 43 44func (this *Skiplist) search(target int) [maxLevel]*Node { 45	cur := this.
  
  <div class="read-more-link">
    <a href="/posts/leetcode/1206.design-skiplist/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0032.longest-valid-parentheses/">0032.longest-valid-parentheses</a>
  </h1>
  <time datetime="2020-12-22T16:27:41&#43;0800" class="post-date">2020-12-22 16:27:41</time>
  1func longestValidParentheses(s string) int { 2	rst := 0 3 // dp[i] 表示以s[i]字符结尾的最长的合法的括号长度 4	dp := make([]int, len(s), len(s)) 5	for i := 1; i &lt; len(s); i++ { 6	curByte := s[i] 7 // 如果s[i]是左括号，那么以左括号为结尾的字符串，一定不是合法的，长度就是0 8	if curByte == &#39;(&#39; { 9	continue 10	} 11 // 如果s[i]是右括号，比如这种 ?()) 12 // 就需要看一下，s[i-1]结尾的合法字符串的前一个是不是左括号， 13 // 如果是，需要加2（一个是当前的右括号，一个是dp[i-1]之前的左括号) 14	leftIdx := i - dp[i-1] - 1 15	if leftIdx &gt;= 0 &amp;&amp; s[leftIdx] == &#39;(&#39; { 16	dp[i] = dp[i-1] + 2 17	leftLeftIdx := i - dp[i-1] - 2 18 // 这里还需要加上dp[i-1]之前的合法字符串的长度 19 // 对应这种情况: ()(()) 20 // 这里只需要看一次就行，因为如果前面还有的话，一定包含在dp[i-dp[i-1]-2]里了 21	if leftLeftIdx &gt;= 0 { 22	dp[i] += dp[leftLeftIdx] 23	} 24	} 25	if rst &lt; dp[i] { 26	rst = dp[i] 27	} 28 29	} 30	return rst 31} 
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0030.substring-with-concatenation-of-all-words/">0030.substring-with-concatenation-of-all-words</a>
  </h1>
  <time datetime="2020-12-18T19:56:59&#43;0800" class="post-date">2020-12-18 19:56:59</time>
  有点暴力的解法，就是遍历所有可能的窗口  1func findSubstring(s string, words []string) []int { 2	//声明返回值 3	var result []int 4 5	//判断 6	if len(s) == 0 || len(words) == 0 { 7	return result 8	} 9 10 11	//获取单词长度 12	l := len(words[0]) 13 14	//获取滑动窗口总长度 15	length := l * len(words) 16 17	//判断 18	if length &gt; len(s) { 19	return result 20	} 21 22	//构造map 23	mp := make(map[string]int) 24 25	//统计 26	for _,v := range words { 27	mp[v] += 1 28	} 29 30	//开始遍历 31	for i := 0; i &lt;= (len(s) - length);i++ { 32	//判断i开始length位置 33	tmpMap := map[string]int{} 34 35	//定义标志 36	//默认是true 37	fg := true 38 39	// 这里的逻辑是，如果当前的单词是需要的，且个数还没凑够，那就对应的数减一 40	// 如果遇到不需要的单词，一定就不合法了.
  
  <div class="read-more-link">
    <a href="/posts/leetcode/0030.substring-with-concatenation-of-all-words/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0336.palindrome-pairs/">0336.palindrome-pairs</a>
  </h1>
  <time datetime="2020-12-18T19:36:38&#43;0800" class="post-date">2020-12-18 19:36:38</time>
  1func palindromePairs(words []string) [][]int { 2	m := make(map[string]int, len(words)) 3	for idx, v := range words { 4	m[v] = idx 5	} 6 7	res := make([][]int, 0) 8 9	for idx, v := range words { 10	// 如果非空字符串v是回文串，且字符数组中包含空字符串，那么 v+&#34;&#34; 与 &#34;&#34;+v 都是回文串 11	if emptyStrIdx, ok := m[&#34;&#34;]; ok &amp;&amp; isPalindrome(v) &amp;&amp; v != &#34;&#34; { 12	res = append(res, []int{emptyStrIdx, idx}) 13	res = append(res, []int{idx, emptyStrIdx}) 14	} 15	// v的逆序字符串存在的话，那么这俩一拼也是回文串，注意这里只加一次( 16	// 比如A的逆序是B, 遍历到A的话，加入A,B; 17	// 遍历到B的时候，加入B,A，就不会重复 18	// ) 19 // 其实v !
  
  <div class="read-more-link">
    <a href="/posts/leetcode/0336.palindrome-pairs/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0010.regular-expression-matching/">0010.regular-expression-matching</a>
  </h1>
  <time datetime="2020-12-17T17:22:10&#43;0800" class="post-date">2020-12-17 17:22:10</time>
  1func isMatch(s string, p string) bool { 2 // sBytes := []byte(s) 3 // pBytes := []byte(p) 4 // dp[i][j]表示s[:i+1] p[:j+1]是否匹配 5 dp := make([][]bool, 0, len(s)+1) 6 for i := 0; i &lt; len(s)+1; i++ { 7 dp = append(dp, make([]bool, len(p)+1)) 8 } 9 // s跟p都是空字符，肯定匹配的上 10 dp[0][0] = true 11 for i := 1; i &lt; len(p); i++ { 12 // 如果当前p[i]是*，那么*可以把前面的字符搞没 13 // 比如 &#34;b*a*&#34; 跟 &#34;&#34;比较，a*可以去掉，那么就变成&#34;b*&#34;跟&#34;&#34;比较 14 if p[i] == &#39;*&#39; { 15 dp[0][i+1] = dp[0][i-1] 16 } 17 } 18 19	for i, sByte := range s { 20	for j, pByte := range p { 21	switch { 22	case sByte == pByte: 23 // 最简单的case，俩字符一样，那么前面的如果匹配，这个一定匹配 24	dp[i+1][j+1] = dp[i+1][j+1] || dp[i][j] 25	case pByte == &#39;.
  
  <div class="read-more-link">
    <a href="/posts/leetcode/0010.regular-expression-matching/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0076.minimum-window-substring/">0076.minimum-window-substring</a>
  </h1>
  <time datetime="2020-12-14T16:47:32&#43;0800" class="post-date">2020-12-14 16:47:32</time>
  滑动窗口逻辑： 声明俩变量left right初始化为0 1. 右边界往右遍历，符合条件后， 2. 左边界往右遍历，直到不符合条件，再跳到1 期间符合条件时，更新下当前的最优解 for right&lt;number{ handle value[right] right++ if left&lt;=right and satisfy the condition { current left and right are good result, update final result left++ } }  1func minWindow(s string, t string) string { 2	retLeft := 0 3	retRight := len(s) + 100 4	left := 0 5	right := 0 6	// 记录t中，byte到个数的map 7	visited := make(map[byte]int) 8	// 实时记录，当前left到right之间的t中字符，byte到个数的映射 9	curVisited := make(map[byte]int) 10	curFitNum := 0 11	tBytes := []byte(t) 12	for _, v := range tBytes { 13	visited[v] += 1 14	} 15	for _, v := range tBytes { 16	curVisited[v] = 0 17	} 18	// t中unique的字符个数 19	fitNum := len(visited) 20	for right &lt; len(s) { 21	// 遍历右边，并处理curVisited, curFitNum等中间记录当前状态的变量 22	curRightByte := s[right] 23	if _, ok := curVisited[curRightByte]; ok { 24	curVisited[curRightByte]++ 25	if curVisited[curRightByte] == visited[curRightByte] { 26	curFitNum++ 27	} 28	} 29	right++ 30 31	for left &lt;= right &amp;&amp; curFitNum == fitNum { 32	// 当left在合法范围内，且当前符合条件时 33	// 检查下是否更新返回值 34	if right-left &lt; retRight-retLeft { 35	retRight = right 36	retLeft = left 37	} 38 39 // 去掉left的字符后，处理curVisited, curFitNum等中间记录当前状态的变量 40	curLeftByte := s[left] 41	if v, ok := curVisited[curLeftByte]; ok { 42	if v == visited[curLeftByte] { 43	curFitNum-- 44	} 45	curVisited[curLeftByte]-- 46 47	} 48	left++ 49	} 50	} 51	if retRight &gt; len(s) { 52	return &#34;&#34; 53	} 54	return s[retLeft:retRight] 55} 
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0042.trapping-rain-water/">0042.rapping-rain-water</a>
  </h1>
  <time datetime="2020-12-10T19:03:01&#43;0800" class="post-date">2020-12-10 19:03:01</time>
  单调栈解法 1func trap(height []int) int { 2 if len(height)&lt;=2{ 3 return 0 4 } 5 6 s:=&amp;Stack{ 7 raw: make([]int, 0), 8 } 9 s.Push(0) 10 rst:=0 11 for i:=1; i&lt;len(height); i++{ 12 v:=height[i] 13 for s.Len()&gt;0 &amp;&amp; v&gt;height[s.Top()]{ 14	// 其实要算的是targetIdx位置的雨水 15 targetIdx:=s.Pop() 16 if s.Len()&gt;0{ 17	// 栈顶元素是左边界 18 leftIdx:=s.Top() 19	// i是右边界 20 rightIdx:=i 21	// 存储水量取决于左右边界的最低值，然后减去target的高度，就是存水量的高, 再乘以宽度，就是水量 22	// 宽度是 rightIdx-leftIdx-1， 比如 3， 4， 5， 6， 7 23	// 如果leftIdx=3, rightIdx=7， 那么要取4， 5， 6的宽度3， 7-3=4， 需要再减去1 24 rst+= (getMin(height[leftIdx], height[rightIdx])-height[targetIdx])*(rightIdx-leftIdx-1) 25 } 26 } 27 s.
  
  <div class="read-more-link">
    <a href="/posts/leetcode/0042.trapping-rain-water/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0053.maximum-subarra/">0053.maximum-subarray</a>
  </h1>
  <time datetime="2020-12-10T16:33:51&#43;0800" class="post-date">2020-12-10 16:33:51</time>
  1func maxSubArray(nums []int) int { 2	if len(nums) == 0 { 3	return 0 4	} 5	// dp[i]表示以i结尾的和 6	dp := make([]int, len(nums), len(nums)) 7	dp[0] = nums[0] 8	rst := nums[0] 9	for i := 1; i &lt; len(nums); i++ { 10	// 对于以i结尾的连续数组，要么就他自己，要么他自己加上以i-1为结尾的最大值 11	dp[i] = max(nums[i], nums[i]+dp[i-1]) 12	if dp[i] &gt; rst { 13	rst = dp[i] 14	} 15	} 16 17	return rst 18} 19 20func max(a, b int) int { 21	if a &gt; b { 22	return a 23	} 24	return b 25} 
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0041.first-missing-positive/">0041.first-missing-positive</a>
  </h1>
  <time datetime="2020-12-10T16:17:11&#43;0800" class="post-date">2020-12-10 16:17:11</time>
  比如2， 3，-1， 6 遍历一遍，负数变成默认值: 数组长度 原因是需要拿负号做标记，所以先把原来的负数干掉 先变成 2， 3， 5， 6 然后，遇到2，如果2在len里面，且对应位置的数是整数，就改成负数 2, -3, -5, 6 这样，遍历一遍，第一个正数对应的位置，就是第一个缺失的正整数  1func firstMissingPositive(nums []int) int { 2	for i, _ := range nums { 3	if nums[i] &lt;= 0 { 4	nums[i] = len(nums) + 1 5	} 6	} 7	8	for i, _ := range nums { 9	// abs(nums[i]) 10	// is for 3, 4, -1, 1 11	// otherwise 12	// after checking negative, would be 3, 4, 5, 1 13	// after this lookp, would be 3, 4, -5, -1 14	// then 1 would be returned 15	// the reason is that the last value 1 is set to negative 16	// so we need to ignore negative, just use abs value 17	cur := abs(nums[i]) 18	// nums[cur-1] &gt; 0 19	// is for 1, 1 20	// otherwise 21	// after checking ne4tative, would be 1, 1 22	// after this lookup, would be -1, 1, then 1, 1 23	// the zero index was set two times, and -1*-1=1 24	// so for one index, we only need to set one time 25	if cur &gt; 0 &amp;&amp; cur &lt; len(nums)+1 &amp;&amp; nums[cur-1] &gt; 0 { 26	nums[cur-1] *= -1 27	} 28	} 29 30	for i, _ := range nums { 31	if nums[i] &gt; 0 { 32	return i + 1 33	} 34	} 35 36	return len(nums) + 1 37} 38 39func abs(a int) int { 40	if a &lt; 0 { 41	a *= -1 42	} 43	return a 44} 
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0051.n-queens/">0051.n-queens</a>
  </h1>
  <time datetime="2020-12-10T15:34:43&#43;0800" class="post-date">2020-12-10 15:34:43</time>
  1func solveNQueens(n int) [][]string { 2	rst := make([][]string, 0) 3	4	// initialize chess 5	chess := make([][]byte, 0, n) 6	for i := 0; i &lt; n; i++ { 7	chess = append(chess, getLine(n)) 8	} 9 10	var bs func(row int) 11	bs = func(row int) { 12	if row == n { 13	rst = append(rst, getRst(chess)) 14	return 15	} 16	for col := 0; col &lt; n; col++ { 17	// if location with row and col can not add a Q 18	// then just continue 19	if !
  
  <div class="read-more-link">
    <a href="/posts/leetcode/0051.n-queens/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/git/reset/">Reset</a>
  </h1>
  <time datetime="2020-12-10T14:05:18&#43;0800" class="post-date">2020-12-10 14:05:18</time>
  https://ndpsoftware.com/git-cheatsheet.html
// 取消上一次提交，且代码不要了 git reset --hard HEAD^1 // 取消上一次提交，代码在add状态 git reset --soft HEAD^1 // 取消add状态 git reset git reset &lt;file&gt;  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0056.merge-intervals/">0056.merge-intervals</a>
  </h1>
  <time datetime="2020-12-10T13:44:21&#43;0800" class="post-date">2020-12-10 13:44:21</time>
  1func merge(intervals [][]int) [][]int { 2	if len(intervals) == 0 { 3	return [][]int{} 4	} 5	if len(intervals) == 1 { 6	return intervals 7	} 8	// need to sort by the start value 9	sort.Slice(intervals, func(i, j int) bool { 10	return intervals[i][0] &lt; intervals[j][0] 11	}) 12	rst := make([][]int, 0) 13	cur := intervals[0] 14	for i := 1; i &lt; len(intervals); i++ { 15	if intervals[i][0] &lt;= cur[1] { 16	// cur = [1, 3] intervals[i]=[2, 5] 17	// 对于这种，需要合并，合并后开始还是cur[0], cur[1]=两个结束值的最大值 18	cur[1] = getMaxInt(cur[1], intervals[i][1]) 19	} else { 20	// cur = [1, 3] intervals[i]=[4, 5] 21	rst = append(rst, cur) 22	cur = intervals[i] 23	} 24	} 25 26	rst = append(rst, cur) 27	return rst 28 29} 30 31func getMaxInt(a, b int) int { 32	if a &gt; b { 33	return a 34	} 35	return b 36} 
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0047.permutations-ii/">0047.permutations_II</a>
  </h1>
  <time datetime="2020-12-10T13:31:12&#43;0800" class="post-date">2020-12-10 13:31:12</time>
  1func permuteUnique(s []int) [][]int { 2 // need to sort the s first, so it&#39;s easy for us to skip the duplicated value 3	sort.Ints(s) 4	rst := make([][]int, 0) 5	visited := make([]bool, len(s), len(s)) 6 7	var bs func(idx int, cur []int) 8 9	bs = func(idx int, cur []int) { 10	if idx == len(s) { 11	curRst := make([]int, len(cur), len(cur)) 12	copy(curRst, cur) 13	rst = append(rst, curRst) 14	return 15	} 16 17	for i := 0; i &lt; len(s); i++ { 18	if visited[i] { 19	continue 20	} 21	// s[i]==s[i-1] means the value with last idx equals current value 22	// 23	// i-1 is in front of i 24	// so i-1 must have been handled before i 25	// and visited[i-1]==false means the result of this value has been added to rst 26	// then deleting i-1 from current result and hanlde i 27	if i &gt; 0 &amp;&amp; s[i] == s[i-1] &amp;&amp; !
  
  <div class="read-more-link">
    <a href="/posts/leetcode/0047.permutations-ii/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0046.permutations/">0046.permutations</a>
  </h1>
  <time datetime="2020-12-10T13:21:18&#43;0800" class="post-date">2020-12-10 13:21:18</time>
  1func permute(s []int) [][]int { 2	rst := make([][]int, 0) 3	// to judge if the value of this index has been visited 4	visited := make([]bool, len(s), len(s)) 5 6	var bs func(idx int, cur []int) 7 8	bs = func(idx int, cur []int) { 9	// satisfied 10	if idx == len(s) { 11	curRst := make([]int, len(cur), len(cur)) 12	copy(curRst, cur) 13	rst = append(rst, curRst) 14	return 15	} 16 17	for i := 0; i &lt; len(s); i++ { 18	if visited[i] { 19	continue 20	} 21 22 // visit the value with index i 23	visited[i] = true 24	cur = append(cur, s[i]) 25	26	bs(idx+1, cur) 27	28	// restore the context 29	visited[i] = false 30	cur = cur[:len(cur)-1] 31	} 32	} 33	34	// initialize the state 35	bs(0, make([]int, 0, len(s))) 36	return rst 37} 
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/0084.largest-rectangle-in-histogram/">0084.largest-rectangle-in-histogram</a>
  </h1>
  <time datetime="2020-08-23T18:14:56&#43;0800" class="post-date">2020-08-23 18:14:56</time>
  https://leetcode-cn.com/problems/largest-rectangle-in-histogram/
单调栈
1func largestRectangleArea(heights []int) int { 2	h:=make([]int, 0, len(heights)+2) 3	h=append(h, 0) 4	h=append(h, heights...) 5	h=append(h, 0) 6	// stack里存储的是单调递增的索引 7	stack:=make([]int, 0) 8	res:=0 9 10 // 遍历的是h，not heights 11	for i, v:=range h{ 12	for len(stack)!=0 &amp;&amp; h[stack[len(stack)-1]]&gt;v{ 13	// 如果当前的值小于栈顶位置的元素，说明可以计算栈顶位置元素的矩形面积 14	t:=stack[len(stack)-1] 15	stack=stack[:len(stack)-1] 16	// 出栈之后，栈顶位置的元素为小于t位置的索引 17	left:=stack[len(stack)-1] 18	right:=i 19	// left是小于t的最左侧，right是小于t的最右侧, 1xxx5, 比如计算xxx的长度,5-1=4,需要再减一个1 20	res=getMaxInt(res, (right-left-1)*h[t]) 21	} 22	stack=append(stack, i) 23	} 24 25	return res 26} 27 28func getMaxInt(a, b int)int{ 29	if a&gt;b{ 30	return a 31	} 32	return b 33} 
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/algo/sliding_window/">Sliding_window</a>
  </h1>
  <time datetime="2020-07-23T11:05:24&#43;0800" class="post-date">2020-07-23 11:05:24</time>
  https://lucifer.ren/blog/2020/03/16/slide-window/
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/golang/mem/">Mem</a>
  </h1>
  <time datetime="2020-06-19T17:19:20&#43;0800" class="post-date">2020-06-19 17:19:20</time>
  https://deepu.tech/memory-management-in-golang/#:~:text=Go&rsquo;s%20memory%20management%20involves%20automatic,is%20well%20optimized%20and%20efficient.
https://speakerdeck.com/deepu105/go-memory-allocation
https://blog.learngoprogramming.com/
https://www.bookstack.cn/read/For-learning-Go-Tutorial/
https://draveness.me/golang
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/golang/tool/">Tool</a>
  </h1>
  <time datetime="2020-06-19T14:48:19&#43;0800" class="post-date">2020-06-19 14:48:19</time>
  Copy from: https://rakyll.org/go-tool-flags/ https://studygolang.com/articles/22803
go build -x Lists all the commands go build invokes.
go build -gcflags Used to pass flags to the Go compiler. go tool compile -help lists all the flags that can be passed to the compiler.
For example, to disable compiler optimizations and inlining, you can use the following the gcflags.
# -N disable optimizations # -m print optimization decisions # -l disable inlining # -race enable race detector go build/run -gcflags &quot;&lt;parameters&gt;&quot; main.
  
  <div class="read-more-link">
    <a href="/posts/golang/tool/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/wrk2/intro/">Intro</a>
  </h1>
  <time datetime="2020-06-15T21:10:28&#43;0800" class="post-date">2020-06-15 21:10:28</time>
  https://github.com/giltene/wrk2
wrk -t2 -c100 -d30s -R2000 http://127.0.0.1:8080/index.html # This runs a benchmark for 30 seconds, # using 2 threads, keeping 100 HTTP connections open, # and a constant throughput of 2000 requests per second # (total, across all connections combined).  With script
./wrk -c2 -t2 -L -R6 -d600s -s ./scripts/lookup.lua http://127.0.0.1:8080  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/algo/reverse_list/">Reverse_list</a>
  </h1>
  <time datetime="2020-06-07T18:34:55&#43;0800" class="post-date">2020-06-07 18:34:55</time>
  1package main 2 3import ( 4	&#34;fmt&#34; 5) 6 7type ListNode struct { 8	Val int 9	Next *ListNode 10} 11 12func main() { 13	l := getList([]int{1, 2, 3, 4, 5, 6}) 14	printList(l) 15	l = reverseList(l) 16	printList(l) 17} 18 19func reverseList(l *ListNode) *ListNode { 20	var head *ListNode 21	var next *ListNode 22	cur := l 23	for cur != nil { 24	/* 25好记忆: 26A=B 27B=C 28C=D 29D=A 30*/ 31	// 保存下一个节点 32	next = cur.
  
  <div class="read-more-link">
    <a href="/posts/algo/reverse_list/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/leetcode/1/">1</a>
  </h1>
  <time datetime="2020-05-03T21:07:02&#43;0800" class="post-date">2020-05-03 21:07:02</time>
  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/algo/backtrack/">Backtrack</a>
  </h1>
  <time datetime="2020-05-03T21:04:31&#43;0800" class="post-date">2020-05-03 21:04:31</time>
  result = [] def backtrack(路径, 选择列表): if 满足结束条件: result.add(路径) return for 选择 in 选择列表: 做选择 backtrack(路径, 选择列表(抠掉这次选择)) 撤销选择  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/algo/alien_dictionary/">Alien_dictionary</a>
  </h1>
  <time datetime="2020-04-26T11:56:22&#43;0800" class="post-date">2020-04-26 11:56:22</time>
  1# -*- encoding: utf-8 -*- 2 3from heapq import heappush, heappop, heapify 4 5class Solution: 6 &#34;&#34;&#34; 7@param board: A list of lists of character 8@param words: A list of string 9@return: A list of string 10&#34;&#34;&#34; 11 def alienOrder(self, words): 12 # write your code here 13 # TODO: check params 14 graph=self.buildGraph(words) 15 print graph 16 17 # print graph 18 19 inDegree=self.buildInDegree(words, graph) 20 21 # print inDegree 22 23 q=[] 24 for i in inDegree: 25 if inDegree[i]==0: 26 q.
  
  <div class="read-more-link">
    <a href="/posts/algo/alien_dictionary/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/algo/reservoir_sampling/">Reservoir_sampling</a>
  </h1>
  <time datetime="2020-04-25T14:59:29&#43;0800" class="post-date">2020-04-25 14:59:29</time>
  array result for i=0; i&lt;n; i++{ if i&lt;k{ result[i]=array[i] }else{ r=random(0, i) if r&gt;=k{ continue } result[r]=array[i] } }  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/algo/union_find/">Union find</a>
  </h1>
  <time datetime="2020-04-25T14:40:38&#43;0800" class="post-date">2020-04-25 14:40:38</time>
  1class UnionFindSet: 2 def __init__(self, n): 3 self.parents=[] 4 self.ranks=[] 5 for i in range(n): 6 self.parents.append(i) 7 self.ranks.append(0) 8 def connected(self, a, b): 9 return self.find(a)==self.find(b) 10 11 def find(self, x): 12 if x!=self.parents[x]: 13 self.parents[x]=self.find(self.parents[x]) 14 return self.parents[x] 15 16 def union(self, x, y): 17 px=self.find(x) 18 py=self.find(y) 19 # 谁大谁是爹 20 if self.ranks[px]&gt;self.ranks[py]: 21 self.parents[py]=px 22 if self.ranks[px]&lt;self.ranks[py]: 23 self.parents[px]=py 24 if self.ranks[px]==self.ranks[py]: 25 self.parents[py]=px 26 self.ranks[px]+=1 27 28 29t=UnionFindSet(5) 30print t.
  
  <div class="read-more-link">
    <a href="/posts/algo/union_find/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/algo/heap/">Heap</a>
  </h1>
  <time datetime="2020-04-24T22:56:43&#43;0800" class="post-date">2020-04-24 22:56:43</time>
  1package main 2 3import ( 4	&#34;fmt&#34; 5) 6 7func parent(i int) int { 8	return (i - 1) / 2 9} 10 11func left(i int) int { 12	return i*2 + 1 13} 14 15func right(i int) int { 16	return i*2 + 2 17} 18 19func maxHeapify(a []int, i int) { 20	l := left(i) 21	r := right(i) 22	largestIdx := i 23	if l &lt; len(a) &amp;&amp; a[largestIdx] &lt; a[l] { 24	largestIdx = l 25	} 26	if r &lt; len(a) &amp;&amp; a[largestIdx] &lt; a[r] { 27	largestIdx = r 28	} 29 30	if largestIdx !
  
  <div class="read-more-link">
    <a href="/posts/algo/heap/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/algo/trie/">Trie</a>
  </h1>
  <time datetime="2020-04-24T22:54:49&#43;0800" class="post-date">2020-04-24 22:54:49</time>
  1import collections 2import json 3 4class TrieNode(object): 5 def __init__(self, value=0): 6 self.value = value 7 self.isWord = False 8 self.children = collections.OrderedDict() 9 10 @classmethod 11 def insert(cls, root, word): 12 p = root 13 for c in word: 14 child = p.children.get(c) 15 if not child: 16 child = TrieNode(c) 17 p.children[c] = child 18 p = child 19 20 p.isWord = True 
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/algo/merge_sort/">Merge Sort</a>
  </h1>
  <time datetime="2020-04-22T20:16:37&#43;0800" class="post-date">2020-04-22 20:16:37</time>
  1package main 2 3import( 4	&#34;fmt&#34; 5) 6 7func merge(a, b []int)[]int{ 8	rst:=make([]int, 0, len(a)+len(b)) 9	i:=0 10	j:=0 11	for i&lt;len(a) &amp;&amp; j&lt;len(b){ 12	if a[i]&lt;b[j]{ 13	rst=append(rst, a[i]) 14	i++ 15	}else{ 16	rst=append(rst, b[j]) 17	j++ 18	} 19	} 20	rst=append(rst, a[i:]...) 21	rst=append(rst, b[j:]...) 22	return rst 23} 24 25func mergeSort(s []int)[]int{ 26	if len(s)&lt;=1{ 27	return s 28	} 29 30	middleIdx:=len(s)/2 31	left:=mergeSort(s[:middleIdx]) 32	right:=mergeSort(s[middleIdx:]) 33	return merge(left, right) 34} 35 36func main(){ 37	a:=[]int{3, 1, 0, 2, 9, 7, 6, 8, 5, 4} 38	b:=mergeSort(a) 39	fmt.
  
  <div class="read-more-link">
    <a href="/posts/algo/merge_sort/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/golang/dlv/">Dlv</a>
  </h1>
  <time datetime="2020-01-20T19:44:06&#43;0800" class="post-date">2020-01-20 19:44:06</time>
  dlv debug main.go list: list current codes s(step): step in stepout: step out n(next): move to next line(step over) args: break a/b/c.go:213 break pkg.GetName bp(breakpoints): list all break points c(continue): continue to next break point or the end  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/algo/quick_sort/">Quick Sort</a>
  </h1>
  <time datetime="2020-01-19T18:16:32&#43;0800" class="post-date">2020-01-19 18:16:32</time>
  QuickSort(A, p, r) if p&lt;r mid=Partition(A, p, r) QuickSort(A, p, mid-1) QuickSort(A, mid+1, r) Partition(A, p, r) x=A[r] i=p-1 for j=p to r-1 if A[j]&lt;=x i=i+1 exchange A[i] with A[j] i=i+1 exchange A[i] with A[r] // r==j return i  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/algo/dfs/">DFS</a>
  </h1>
  <time datetime="2020-01-19T17:53:40&#43;0800" class="post-date">2020-01-19 17:53:40</time>
  DFS(G) for each u in G.V u.color=WHITE u.parent=nil time=0 for each u in G.V if u.color==WHITE DFS-Visit(G, u) DFS-Visit(G, u) time=time+1 u.displayTime=time u.color=GRAY for each v in G.Adj[u] if v.color==WHITE v.parent=u DFS-Visit(G, v) u.color=BLACK time=time+1 u.finishTime=time  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/algo/bfs/">BFS</a>
  </h1>
  <time datetime="2020-01-19T17:41:20&#43;0800" class="post-date">2020-01-19 17:41:20</time>
  WHITE: before join the queue GRAY: in the queue BLACK: pop from queue, and after visit all the children
BFS(G, s) for each u in (G.V-{s}) u.color=WHITE u.d=inf u.parent=nil s.color=GRAY s.d=0 s.parent=nil ENQUEUE(Q, s) while Q is not empty: u=DEQUEUE(Q) for each v in G.Adj(u) if v.color=WHITE v.color=GRAY v.d=u.d+1 v.parent=u ENQUEUE(Q, v) u.color=BLACK  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/algo/bellman_ford/">Bellman Ford</a>
  </h1>
  <time datetime="2020-01-19T15:45:10&#43;0800" class="post-date">2020-01-19 15:45:10</time>
  References:
 https://www.geeksforgeeks.org/bellman-ford-algorithm-dp-23/
从A出发是否存在到达各个节点的路径(有计算出值当然就可以到达)； 从A出发到达各个节点最短路径(时间最少、或者路径最少等) 图中是否存在负环路（权重之和为负数）   Example: k-flight
time: O(|V|*|E|)
1package main 2 3import ( 4	&#34;fmt&#34; 5	&#34;math&#34; 6) 7 8// Edge means the edge in graph 9type Edge struct { 10	src string 11	dst string 12	weight int 13} 14 15func bf(edges []Edge, fromV string) map[string]int { 16 // key为点，value为目前位置到达key点的距离，刚开始全是无限大 17	distMap := make(map[string]int, 0) 18	for _, v := range edges { 19	distMap[v.src] = math.
  
  <div class="read-more-link">
    <a href="/posts/algo/bellman_ford/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/algo/floyd/">Floyd</a>
  </h1>
  <time datetime="2020-01-19T15:42:53&#43;0800" class="post-date">2020-01-19 15:42:53</time>
  1package main 2 3import ( 4	&#34;fmt&#34; 5	&#34;math&#34; 6) 7 8func f(m [][]int) [][]int { 9	v := len(m) 10	dist := make([][]int, v, v) 11	for i := 0; i &lt; v; i++ { 12	dist[i] = make([]int, v, v) 13	} 14	for i := 0; i &lt; v; i++ { 15	for j := 0; j &lt; v; j++ { 16	dist[i][j] = m[i][j] 17	} 18	} 19 20	for k := 0; k &lt; v; k++ { 21	for i := 0; i &lt; v; i++ { 22	for j := 0; j &lt; v; j++ { 23	newMinForIJ := dist[i][k] + dist[k][j] 24	if newMinForIJ &lt; dist[i][j] { 25	dist[i][j] = newMinForIJ 26	} 27	} 28	} 29	} 30	return dist 31} 32 33func main() { 34	// a b c d 35	// 0 1 2 3 36	// a 0 0 1 6 10 37	// b 1 na 0 2 na 38	// c 2 na na 0 5 39	// d 3 na na na 0 40	m := [][]int{ 41	{0, 1, 6, 10}, 42	{math.
  
  <div class="read-more-link">
    <a href="/posts/algo/floyd/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/algo/dijkstra/">dijkstra</a>
  </h1>
  <time datetime="2020-01-19T15:05:01&#43;0800" class="post-date">2020-01-19 15:05:01</time>
  可以处理有环 无法处理包含有负数权值的边的图 (dijkastra是中间可以确定一部分点的最短距离，后面如果可以加上一个负数，那前面的确定的就不对了)  1from collections import defaultdict 2from heapq import * 3 4def dijkstra(edges, fromV, toV): 5 g=defaultdict(list) 6 for src, dst, cost in edges: 7 g[src].append((cost, dst)) 8 9 q, seen, mins=[(0, fromV, [])], set(), {fromV: 0} 10 while q: 11 (cost, src, path)=heappop(q) 12 if src not in seen: 13 seen.add(src) 14 path.append(src) 15 if src==toV: 16 return (cost, path) 17 for w, dst in g.get(src, []): 18 if dst in seen: 19 continue 20 oldCostForDst=mins.
  
  <div class="read-more-link">
    <a href="/posts/algo/dijkstra/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/docker/common/">Common</a>
  </h1>
  <time datetime="2019-11-15T15:48:28&#43;0800" class="post-date">2019-11-15 15:48:28</time>
  docker ps docker ps -a docker container ls docker container ls -a docker container prune docker run -p 8501:8501 \ --mount type=bind,\ source=/tmp/tfserving/serving/tensorflow_serving/servables/tensorflow/testdata/saved_model_half_plus_two_cpu,\ target=/models/half_plus_two \ -e MODEL_NAME=half_plus_two -t tensorflow/serving &amp;  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/docker/volume/">Volume</a>
  </h1>
  <time datetime="2019-11-15T15:41:03&#43;0800" class="post-date">2019-11-15 15:41:03</time>
  docker volume create &lt;volume name&gt; docker volume ls docker volume inspect &lt;volume name&gt;  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/tensorflow/serving_1/">Serving_1</a>
  </h1>
  <time datetime="2019-11-15T14:34:39&#43;0800" class="post-date">2019-11-15 14:34:39</time>
   Install tensorflow https://docs.python.org/3/library/venv.html
python3 -m venv &lt;path&gt; source &lt;path&gt;/bin/activate pip install tensorflow==&lt;version&gt;  Use tensorflow/serving git: https://github.com/tensorflow/serving
doc: https://www.tensorflow.org/tfx/serving/docker
Multi Version(hot reload), Multi Model(cold reload) docker run -t --rm -p 8501:8501 \ -v &quot;$TESTDATA:/models&quot; -d \ -t tensorflow/serving --model_config_file=/models/models.config  models.config
model_config_list:{ config:{ name:&quot;hello-world&quot;, base_path:&quot;/models/hello-world&quot;, model_platform:&quot;tensorflow&quot;, model_version_policy:{ all:{} } }, config:{ name:&quot;modelA&quot;, base_path:&quot;/models/modelA&quot;, model_platform:&quot;tensorflow&quot;, model_version_policy:{ all:{} } } }  
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/golang/slice_1/">Slice_1</a>
  </h1>
  <time datetime="2019-11-07T22:06:32&#43;0800" class="post-date">2019-11-07 22:06:32</time>
  The struct of slice in go: 1type slice struct { 2	array unsafe.Pointer 3	len int 4	cap int 5}
1package main 2 3import &#34;fmt&#34; 4 5func main() { 6	a := make([]int, 10, 20) 7	for i := 0; i &lt; 10; i = i + 1 { 8	a[i] = i 9	} 10 11	// means the length of b is 6-3=3, the capicity is 9-3=6 12	b := a[3:6:9] 13	// len(b)=3 14	fmt.
  
  <div class="read-more-link">
    <a href="/posts/golang/slice_1/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://wncbb.github.io/posts/how_to_create/">How to create hugo site</a>
  </h1>
  <time datetime="2018-10-06T18:52:24&#43;0800" class="post-date">2018-10-06 18:52:24</time>
  0x00 basic commands 1go get -u -v github.com/spf13/hugo 2hugo new site &lt;directory&gt; 3git init 4git submodule add https://github.com/spf13/hyde.git themes/hyde 5hugo new posts/how-to-create.md 0x01 config.toml 1baseURL = &#34;http://wncbb.github.io/&#34; 2languageCode = &#34;en-us&#34; 3title = &#34;WNCBB&#39;s blog&#34; 4theme = &#34;hyde&#34; 5 6[Menus] 7 main = [ 8 {Name = &#34;Github&#34;, URL = &#34;https://github.com/wncbb/&#34;}, 9 ] 10[params] 11 description = &#34;A man is only as good as what he loves&#34; 12 themeColor = &#34;theme-base-0c&#34; 13 layoutReverse = true 0x02 codes highlight https://gohugo.
  
  <div class="read-more-link">
    <a href="/posts/how_to_create/">Read More…</a>
  </div>
  
</article>
</div>
    </main>

    
  </body>
</html>
