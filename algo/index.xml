<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Algoes on WNCBB&#39;s blog</title>
    <link>https://wncbb.github.io/algo/</link>
    <description>Recent content in Algoes on WNCBB&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 08 Oct 2021 10:33:18 +0800</lastBuildDate><atom:link href="https://wncbb.github.io/algo/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Find_target_index_using_binary_search</title>
      <link>https://wncbb.github.io/algo/find_target_index_using_binary_search/</link>
      <pubDate>Fri, 08 Oct 2021 10:33:18 +0800</pubDate>
      
      <guid>https://wncbb.github.io/algo/find_target_index_using_binary_search/</guid>
      <description>在从小到大排好序的数组中，查找某个数字应该插入的位置
func SearchInts(a []int, x int) int { return Search(len(a), func(i int) bool { return a[i] &amp;gt;= x }) } func Search(n int, f func(int) bool) int { // Define f(-1) == false and f(n) == true.  // Invariant: f(i-1) == false, f(j) == true.  i, j := 0, n for i &amp;lt; j { h := int(uint(i+j) &amp;gt;&amp;gt; 1) // avoid overflow when computing h  // i ≤ h &amp;lt; j  if !</description>
    </item>
    
    <item>
      <title>Stack_queue</title>
      <link>https://wncbb.github.io/algo/stack_queue/</link>
      <pubDate>Mon, 13 Sep 2021 11:45:09 +0800</pubDate>
      
      <guid>https://wncbb.github.io/algo/stack_queue/</guid>
      <description>两个栈模拟队列 搞两个栈，stack1,stack2 入队列时，把数据放入stack1， 出队列时，如果stack2非空，stack2出栈；如果stack2为空，把stack1里所有数据放到stack2，然后stack出栈。 判空时，stack1/stack2都为空，则为空 peek时，先pop出数据，再放到stack2(或者跟出队一样的逻辑，最后知识不出栈，只是stack2.top)
两个队列模拟栈 搞两个队列，que1, que2 入栈时把数据放入que1 出栈时，也就是获取que1里最新的数据，把que1里除了最新的数据，全部输入到que2，然后从que1里输出最后一个元素，然后que1,que2互换。 判空时，判断que1是否为空</description>
    </item>
    
  </channel>
</rss>
